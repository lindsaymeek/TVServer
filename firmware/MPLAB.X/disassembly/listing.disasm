Disassembly Listing for USB Device - Mass Storage - Internal Flash
Generated From:
F:/microchip/mla/v2013_12_20/apps/usb/device/msd_internal_flash/firmware/MPLAB.X/dist/PIC24FJ64GB002/production/MPLAB.X.production.elf
08/06/2014 9:15:52 PM

---  F:/microchip/mla/v2013_12_20/framework/usb/src/usb_device_msd.c  -----------------------------------
1:                 /*********************************************************************
2:                   File Information:
3:                     FileName:        usb_device_msd.c
4:                     Dependencies:    See INCLUDES section below
5:                     Processor:       PIC18, PIC24, or PIC32
6:                     Compiler:        C18, C30, or C32
7:                     Company:         Microchip Technology, Inc.
8:                 
9:                     Software License Agreement
10:                
11:                    The software supplied herewith by Microchip Technology Incorporated
12:                    (the "Company") for its PIC(r) Microcontroller is intended and
13:                    supplied to you, the Company's customer, for use solely and
14:                    exclusively on Microchip PICmicro Microcontroller products. The
15:                    software is owned by the Company and/or its supplier, and is
16:                    protected under applicable copyright laws. All rights are reserved.
17:                    Any use in violation of the foregoing restrictions may subject the
18:                    user to criminal sanctions under applicable laws, as well as to
19:                    civil liability for the breach of the terms and conditions of this
20:                    license.
21:                
22:                    THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
23:                    WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
24:                    TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
25:                    PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
26:                    IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
27:                    CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
28:                ********************************************************************/
29:                 
30:                /** I N C L U D E S **************************************************/
31:                #include "usb/usb.h"
32:                #include "system.h"
33:                #include "system_config.h"
34:                
35:                #include "usb/usb_device_msd.h"
36:                
37:                #ifdef USB_USE_MSD
38:                
39:                #if MAX_LUN == 0
40:                    #define LUN_INDEX 0
41:                #else
42:                    #define LUN_INDEX gblCBW.bCBWLUN
43:                #endif
44:                
45:                #if defined(USE_INTERNAL_FLASH)
46:                    #include "driver/fileio/internal_flash.h"
47:                #endif
48:                
49:                #if defined(USE_SD_INTERFACE_WITH_SPI)
50:                    #include "driver/fileio/sd_spi.h"
51:                #endif
52:                
53:                extern LUN_FUNCTIONS LUN[MAX_LUN + 1];
54:                #define LUNMediaInitialize()                LUN[LUN_INDEX].MediaInitialize(LUN[LUN_INDEX].mediaParameters)
55:                #define LUNReadCapacity()                   LUN[LUN_INDEX].ReadCapacity(LUN[LUN_INDEX].mediaParameters)
56:                #define LUNReadSectorSize()                 LUN[LUN_INDEX].ReadSectorSize(LUN[LUN_INDEX].mediaParameters)
57:                #define LUNMediaDetect()                    LUN[LUN_INDEX].MediaDetect(LUN[LUN_INDEX].mediaParameters)
58:                #define LUNSectorWrite(bLBA,pDest,Write0)   LUN[LUN_INDEX].SectorWrite(LUN[LUN_INDEX].mediaParameters, bLBA, pDest, Write0)
59:                #define LUNWriteProtectState()              LUN[LUN_INDEX].WriteProtectState(LUN[LUN_INDEX].mediaParameters)
60:                #define LUNSectorRead(bLBA,pSrc)            LUN[LUN_INDEX].SectorRead(LUN[LUN_INDEX].mediaParameters, bLBA, pSrc)
61:                
62:                //Adjustable user options
63:                #define MSD_FAILED_READ_MAX_ATTEMPTS  (uint8_t)100u    //Used for error case handling
64:                #define MSD_FAILED_WRITE_MAX_ATTEMPTS (uint8_t)100u    //Used for error case handling
65:                
66:                /** V A R I A B L E S ************************************************/
67:                #if defined(__18CXX)
68:                    #pragma udata
69:                #endif
70:                
71:                //State machine variables
72:                uint8_t MSD_State;			// Takes values MSD_WAIT, MSD_DATA_IN or MSD_DATA_OUT
73:                uint8_t MSDCommandState;
74:                uint8_t MSDReadState;
75:                uint8_t MSDWriteState;
76:                uint8_t MSDRetryAttempt;
77:                //Other variables
78:                USB_MSD_CBW gblCBW;	
79:                uint8_t gblCBWLength;
80:                RequestSenseResponse gblSenseData[MAX_LUN + 1];
81:                uint8_t *ptrNextData;
82:                USB_HANDLE USBMSDOutHandle;
83:                USB_HANDLE USBMSDInHandle;
84:                uint16_t MSBBufferIndex;
85:                uint16_t gblMediaPresent; 
86:                bool SoftDetach[MAX_LUN + 1];
87:                bool MSDHostNoData;
88:                bool MSDCBWValid;
89:                
90:                static USB_MSD_TRANSFER_LENGTH TransferLength;
91:                static USB_MSD_LBA LBA;
92:                
93:                /* 
94:                 * Number of Blocks and Block Length are global because 
95:                 * for every READ_10 and WRITE_10 command need to verify if the last LBA 
96:                 * is less than gblNumBLKS	
97:                 */	
98:                USB_MSD_BLK gblNumBLKS,gblBLKLen;
99:                extern const InquiryResponse inq_resp;
100:               
101:               /** P R I V A T E  P R O T O T Y P E S ***************************************/
102:               uint8_t MSDProcessCommand(void);
103:               void MSDProcessCommandMediaAbsent(void);
104:               void MSDProcessCommandMediaPresent(void);
105:               uint8_t MSDReadHandler(void);
106:               uint8_t MSDWriteHandler(void);
107:               void ResetSenseData(void);
108:               uint8_t MSDCheckForErrorCases(uint32_t);
109:               void MSDErrorHandler(uint8_t);
110:               static void MSDComputeDeviceInAndResidue(uint16_t);
111:               
112:               /** D E C L A R A T I O N S **************************************************/
113:               #if defined(__18CXX)
114:                   #pragma code
115:               #endif
116:               
117:               /** C L A S S  S P E C I F I C  R E Q ****************************************/
118:               
119:               /******************************************************************************
120:                 Function:
121:                   void USBMSDInit(void)
122:                   
123:                 Summary:
124:                   This routine initializes the MSD class packet handles, prepares to
125:                   receive a MSD packet, and initializes the MSD state machine. This
126:                   \function should be called once after the device is enumerated.
127:               
128:                 Description:
129:                   This routine initializes the MSD class packet handles, prepares to
130:                   receive a MSD packet, and initializes the MSD state machine. This
131:                   \function should be called once after the device is enumerated.
132:                   
133:                   Typical Usage:
134:                   <code>
135:                   void USBCBInitEP(void)
136:                   {
137:                       USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
138:                       USBMSDInit();
139:                   }
140:                   </code>
141:                 Conditions:
142:                   The device should already be enumerated with a configuration that
143:                   supports MSD before calling this function.
144:                   
145:                 Paramters: None
146:               
147:                 Remarks:
148:                   None                                                                                                          
149:                 ****************************************************************************/	
150:               void USBMSDInit(void)
151:               {
0010C8  BE9F88     MOV.D W8, [W15++]
152:                   //Prepare to receive the first CBW
153:                   USBMSDOutHandle = USBRxOnePacket(MSD_DATA_OUT_EP,(uint8_t*)&msd_cbw,MSD_OUT_EP_SIZE);
0010CA  B3C403     MOV #0x40, W3
0010CC  2081E2     MOV #0x81E, W2
0010CE  EB4080     CLR.B W1
0010D0  B3C010     MOV #0x1, W0
0010D2  07FCA2     RCALL USBTransferOnePacket
0010D4  885380     MOV W0, USBMSDOutHandle
154:                   //Initialize IN handle to point to first available IN MSD bulk endpoint entry
155:                   USBMSDInHandle = USBGetNextHandle(MSD_DATA_IN_EP, IN_TO_HOST);
0010D6  F8081C     PUSH 0x81C
0010D8  F90A72     POP USBMSDInHandle
156:                   MSD_State = MSD_WAIT;
0010DA  EB4200     CLR.B W4
0010DC  784004     MOV.B W4, W0
0010DE  B7EA76     MOV.B WREG, MSD_State
157:                   MSDCommandState = MSD_COMMAND_WAIT;
0010E0  EFEA77     SETM.B MSDCommandState
158:                   MSDReadState = MSD_READ10_WAIT;
0010E2  B7EA78     MOV.B WREG, MSDReadState
0010E4  B7EA79     MOV.B WREG, MSDWriteState
0010E6  B7EAB6     MOV.B WREG, MSDHostNoData
159:                   MSDWriteState = MSD_WRITE10_WAIT;
160:                   MSDHostNoData = false;
161:                   gblNumBLKS.Val = 0;
0010E8  B83360     MUL.UU W6, #0, W6
0010EA  8855C6     MOV W6, gblNumBLKS
0010EC  8855D7     MOV W7, 0xABA
162:                   gblBLKLen.Val = 0;
0010EE  8855E6     MOV W6, gblBLKLen
0010F0  8855F7     MOV W7, 0xABE
163:                   MSDCBWValid = true;
0010F2  B3C010     MOV #0x1, W0
0010F4  B7EA75     MOV.B WREG, MSDCBWValid
164:               
165:                   gblMediaPresent = 0;
0010F6  EF2AB4     CLR gblMediaPresent
166:               
167:                   //For each of the possible logical units
168:                   for(gblCBW.bCBWLUN=0;gblCBW.bCBWLUN<(MAX_LUN + 1);gblCBW.bCBWLUN++)
0010F8  784004     MOV.B W4, W0
0010FA  B7EA89     MOV.B WREG, 0xA89
001122  EC4A89     INC.B 0xA89, WREG
001124  B7EA89     MOV.B WREG, 0xA89
001126  32FFEC     BRA Z, 0x1100
169:                   {
170:                       //clear all of the soft detach variables
171:                       SoftDetach[gblCBW.bCBWLUN] =  false;
0010FC  784400     MOV.B W0, W8
001100  784008     MOV.B W8, W0
001102  B7EA74     MOV.B WREG, SoftDetach
172:               
173:                       //see if the media is attached
174:                       if(LUNMediaDetect())
001104  805970     MOV 0xB2E, W0
001106  805934     MOV 0xB26, W4
001108  010004     CALL W4
00110A  504FE0     SUB.B W0, #0x0, [W15]
00110C  320009     BRA Z, 0x1120
175:                       {
176:                           //initialize the media
177:                           if(LUNMediaInitialize())
00110E  805970     MOV 0xB2E, W0
001110  805904     MOV LUN, W4
001112  010004     CALL W4
001114  500FE0     SUB W0, #0x0, [W15]
001116  320004     BRA Z, 0x1120
178:                           {
179:                               //if the media was present and successfully initialized
180:                               //  then mark and indicator that the media is ready
181:                               gblMediaPresent |= ((uint16_t)1<<gblCBW.bCBWLUN);
0010FE  200019     MOV #0x1, W9
001118  BFCA89     MOV.B 0xA89, WREG
00111A  FB8000     ZE W0, W0
00111C  DD4800     SL W9, W0, W0
00111E  B72AB4     IOR gblMediaPresent
182:                           }
183:                       }
184:                       ResetSenseData();
001120  07FFAF     RCALL ResetSenseData
185:                   }
186:               }
001128  BE044F     MOV.D [--W15], W8
00112A  060000     RETURN
187:               
188:               /******************************************************************************
189:                	Function:
190:                		void USBCheckMSDRequest(void)
191:               
192:                	Summary:
193:                		This routine handles MSD specific request that happen on EP0.  
194:                       This function should be called from the USBCBCheckOtherReq() call back 
195:                       function whenever implementing an MSD device.
196:               
197:                	Description:
198:                		This routine handles MSD specific request that happen on EP0.  These
199:                       include, but are not limited to, the standard RESET and GET_MAX_LUN 
200:                		command requests.  This function should be called from the 
201:                       USBCBCheckOtherReq() call back function whenever using an MSD device.	
202:               
203:                       Typical Usage:
204:                       <code>
205:                       void USBCBCheckOtherReq(void)
206:                       {
207:                           //Since the stack didn't handle the request I need to check
208:                           //  my class drivers to see if it is for them
209:                           USBCheckMSDRequest();
210:                       }
211:                       </code>
212:               
213:                	PreCondition:
214:                		None
215:                		
216:                	Parameters:
217:                		None
218:                	
219:                	Return Values:
220:                		None
221:                		
222:                	Remarks:
223:                		None
224:                
225:                *****************************************************************************/	
226:               void USBCheckMSDRequest(void)
227:               {
228:                   if(SetupPkt.Recipient != USB_SETUP_RECIPIENT_INTERFACE_BITFIELD)
000FE4  20A4C4     MOV #0xA4C, W4
000FE6  784214     MOV.B [W4], W4
000FE8  62427F     AND.B W4, #0x1F, W4
000FEA  524FE1     SUB.B W4, #0x1, [W15]
000FEC  3A0048     BRA NZ, 0x107E
229:                   {
230:                       return;
231:                   }
232:                   
233:                   if(SetupPkt.bIntfID != MSD_INTF_ID) 
000FEE  20A504     MOV #0xA50, W4
000FF0  784214     MOV.B [W4], W4
000FF2  524FE0     SUB.B W4, #0x0, [W15]
000FF4  3A0044     BRA NZ, 0x107E
234:                   {
235:                       return;
236:                   }
237:               
238:                   switch(SetupPkt.bRequest)
000FF6  20A4D4     MOV #0xA4D, W4
000FF8  784214     MOV.B [W4], W4
000FFA  424FE2     ADD.B W4, #0x2, [W15]
000FFC  320028     BRA Z, 0x104E
000FFE  424FE1     ADD.B W4, #0x1, [W15]
001000  3A003E     BRA NZ, 0x107E
239:                   {
240:                       case MSD_RESET:
241:                           //First make sure all request parameters are correct:
242:                           //MSD BOT specs require wValue to be == 0x0000 and wLength == 0x0000
243:                           if((SetupPkt.wValue != 0) || (SetupPkt.wLength != 0))
001002  20A4E5     MOV #0xA4E, W5
001004  784295     MOV.B [W5], W5
001006  FB8285     ZE W5, W5
001008  20A4F4     MOV #0xA4F, W4
00100A  784214     MOV.B [W4], W4
00100C  DD2248     SL W4, #8, W4
00100E  720205     IOR W4, W5, W4
001010  3A0036     BRA NZ, 0x107E
001012  20A525     MOV #0xA52, W5
001014  784295     MOV.B [W5], W5
001016  FB8285     ZE W5, W5
001018  20A534     MOV #0xA53, W4
00101A  784214     MOV.B [W4], W4
00101C  DD2248     SL W4, #8, W4
00101E  720205     IOR W4, W5, W4
001020  3A002E     BRA NZ, 0x107E
244:                           {
245:                               return; //Return without handling the request (results in STALL)
246:                           }
247:               
248:                           //Host would typically issue this after a STALL event on an MSD
249:                           //bulk endpoint.  The MSD reset should re-initialize status
250:                           //so as to prepare for a new CBW.  Any currently ongoing command
251:                           //block should be aborted, but the STALL and DTS states need to be
252:                           //maintained (host will re-initialize these seperately using
253:                           //CLEAR_FEATURE, endpoint halt).
254:                           MSD_State = MSD_WAIT;
001022  784004     MOV.B W4, W0
001024  B7EA76     MOV.B WREG, MSD_State
255:                           MSDCommandState = MSD_COMMAND_WAIT;
001026  EFEA77     SETM.B MSDCommandState
256:                           MSDReadState = MSD_READ10_WAIT;
001028  B7EA78     MOV.B WREG, MSDReadState
00102A  B7EA79     MOV.B WREG, MSDWriteState
257:                           MSDWriteState = MSD_WRITE10_WAIT;
258:                           MSDCBWValid = true;
00102C  B3C010     MOV #0x1, W0
00102E  B7EA75     MOV.B WREG, MSDCBWValid
259:                           //Need to re-arm MSD bulk OUT endpoint, if it isn't currently armed,
260:                           //to be able to receive next CBW.  If it is already armed, don't need
261:                           //to do anything, since we can already receive the next CBW (or we are
262:                           //STALLed, and the host will issue clear halt first).
263:                           if(!USBHandleBusy(USBGetNextHandle(MSD_DATA_OUT_EP, OUT_FROM_HOST)))
001030  8040C4     MOV 0x818, W4
001032  520FE0     SUB W4, #0x0, [W15]
001034  320003     BRA Z, 0x103C
001036  EB0280     CLR W5
001038  128F94     SUBR W5, [W4], [W15]
00103A  350006     BRA LT, 0x1048
264:                           {
265:                               USBMSDOutHandle = USBRxOnePacket(MSD_DATA_OUT_EP,(uint8_t*)&msd_cbw,MSD_OUT_EP_SIZE);
00103C  B3C403     MOV #0x40, W3
00103E  2081E2     MOV #0x81E, W2
001040  EB4080     CLR.B W1
001042  B3C010     MOV #0x1, W0
001044  07FCE9     RCALL USBTransferOnePacket
001046  885380     MOV W0, USBMSDOutHandle
266:                           }
267:               
268:                           //Let USB stack know we took care of handling the EP0 SETUP request.
269:                           //Allow zero byte status stage to proceed normally now.
270:                           USBEP0Transmit(USB_EP0_NO_DATA);
001048  B3C800     MOV #0x80, W0
00104A  B7E806     MOV.B WREG, 0x806
271:                           break;
00104C  370018     BRA 0x107E
272:                           
273:                       case GET_MAX_LUN:
274:                           //First make sure all request parameters are correct:
275:                           //MSD BOT specs require wValue to be == 0x0000, and wLengh == 1
276:                           if((SetupPkt.wValue != 0) || (SetupPkt.wLength != 1))
00104E  20A4E5     MOV #0xA4E, W5
001050  784295     MOV.B [W5], W5
001052  FB8285     ZE W5, W5
001054  20A4F4     MOV #0xA4F, W4
001056  784214     MOV.B [W4], W4
001058  DD2248     SL W4, #8, W4
00105A  720205     IOR W4, W5, W4
00105C  3A0010     BRA NZ, 0x107E
00105E  20A525     MOV #0xA52, W5
001060  784295     MOV.B [W5], W5
001062  FB8285     ZE W5, W5
001064  20A534     MOV #0xA53, W4
001066  784214     MOV.B [W4], W4
001068  DD2248     SL W4, #8, W4
00106A  720205     IOR W4, W5, W4
00106C  520FE1     SUB W4, #0x1, [W15]
00106E  3A0007     BRA NZ, 0x107E
277:                           {
278:                               break;  //Return without handling the request (results in STALL)
279:                           }
280:               
281:                           //If the host asks for the maximum number of logical units
282:                           //  then send out a packet with that information
283:                           CtrlTrfData[0] = MAX_LUN;
001070  EF6A54     CLR.B CtrlTrfData
284:                           USBEP0SendRAMPtr((uint8_t*)&CtrlTrfData[0],1,USB_EP0_INCLUDE_ZERO);
001072  20A544     MOV #0xA54, W4
001074  884024     MOV W4, inPipes
001076  200014     MOV #0x1, W4
001078  884044     MOV W4, 0x808
00107A  B3CC10     MOV #0xC1, W0
00107C  B7E806     MOV.B WREG, 0x806
285:                           break;
286:                   }	//end switch(SetupPkt.bRequest)
287:               }
00107E  060000     RETURN
288:               
289:               /*********************************************************************************
290:                 Function:
291:                       uint8_t MSDTasks(void)
292:                   
293:                 Summary:
294:                   This function runs the MSD class state machines and all of its
295:                   sub-systems. This function should be called periodically once the
296:                   device is in the configured state in order to keep the MSD state
297:                   machine going.
298:                 Description:
299:                   This function runs the MSD class state machines and all of its
300:                   sub-systems. This function should be called periodically once the
301:                   device is in the configured state in order to keep the MSD state
302:                   machine going.
303:                   
304:                   Typical Usage:
305:                   <code>
306:                   void main(void)
307:                   {
308:                       USBDeviceInit();
309:                       while(1)
310:                       {
311:                           USBDeviceTasks();
312:                           if((USBGetDeviceState() \< CONFIGURED_STATE) ||
313:                              (USBIsDeviceSuspended() == true))
314:                           {
315:                               //Either the device is not configured or we are suspended
316:                               //  so we don't want to do execute any application code
317:                               continue;   //go back to the top of the while loop
318:                           }
319:                           else
320:                           {
321:                               //Keep the MSD state machine going
322:                               MSDTasks();
323:                   
324:                               //Run application code.
325:                               UserApplication();
326:                           }
327:                       }
328:                   }
329:                   </code>
330:                 Conditions:
331:                   None
332:                 Return Values:
333:                   uint8_t -  the current state of the MSD state machine the valid values are
334:                           defined in MSD.h under the MSDTasks state machine declaration section.
335:                           The possible values are the following\:
336:                           * MSD_WAIT
337:                           * MSD_DATA_IN
338:                           * MSD_DATA_OUT
339:                           * MSD_SEND_CSW
340:                 Remarks:
341:                   None                                                                          
342:                 *********************************************************************************/	
343:               uint8_t MSDTasks(void)
344:               {
345:                   uint8_t i;
346:                   
347:                   //Error check to make sure we have are in the CONFIGURED_STATE, prior to
348:                   //performing MSDTasks().  Some of the MSDTasks require that the device be
349:                   //configured first.
350:                   if(USBGetDeviceState() != CONFIGURED_STATE)
0017C0  804065     MOV USBDeviceState, W5
0017C4  200204     MOV #0x20, W4
0017C6  528F84     SUB W5, W4, [W15]
0017C8  3A00AF     BRA NZ, 0x1928
351:                   {
352:                       return MSD_WAIT;
0017C2  EB4000     CLR.B W0
353:                   }
354:                   
355:                   //Note: Both the USB stack code (usb_device.c) and this MSD handler code 
356:                   //have the ability to modify the BDT values for the MSD bulk endpoints.  If the 
357:                   //USB stack operates in USB_INTERRUPT mode (user option in usb_config.h), we
358:                   //should temporily disable USB interrupts, to avoid any possibility of both 
359:                   //the USB stack and this MSD handler from modifying the same BDT entry, or
360:                   //MSD state machine variables (ex: in the case of MSD_RESET) at the same time.
361:                   USBMaskInterrupts();
0017CA  A9C09E     BCLR IEC5, #6
362:                   
363:                   //Main MSD task dispatcher.  Receives MSD Command Block Wrappers (CBW) and
364:                   //dispatches appropriate lower level handlers to service the requests.
365:                   switch(MSD_State)
0017CC  20A764     MOV #0xA76, W4
0017CE  784214     MOV.B [W4], W4
0017D0  FB8204     ZE W4, W4
0017D2  200005     MOV #0x0, W5
0017D4  520FE3     SUB W4, #0x3, [W15]
0017D6  5A8FE0     SUBB W5, #0x0, [W15]
0017D8  3E009E     BRA GTU, 0x1916
0017DA  016004     BRA W4
0017DC  370003     BRA 0x17E4
0017DE  37006A     BRA 0x18B4
0017E0  37006F     BRA 0x18C0
0017E2  37007F     BRA 0x18E2
366:                   {
367:                       case MSD_WAIT: //idle state, when we are waiting for a command from the host
368:                       {
369:                           //Check if we have received a new command block wrapper (CBW)
370:                           if(!USBHandleBusy(USBMSDOutHandle))
0017E4  805381     MOV USBMSDOutHandle, W1
0017E6  508FE0     SUB W1, #0x0, [W15]
0017E8  320006     BRA Z, 0x17F6
0017EA  EB0000     CLR W0
0017EC  B3C1F5     MOV #0x1F, W5
0017EE  EB4200     CLR.B W4
0017F0  100F91     SUBR W0, [W1], [W15]
0017F2  3D0003     BRA GE, 0x17FA
0017F4  370097     BRA 0x1924
0017F6  B3C1F5     MOV #0x1F, W5
0017F8  EB4200     CLR.B W4
371:                           {
372:                               //If we are in the MSD_WAIT state, and we received an OUT transaction
373:                               //on the MSD OUT endpoint, then we must have just received an MSD
374:                               //Command Block Wrapper (CBW).
375:                               //First copy the the received data to to the gblCBW structure, so
376:                               //that we keep track of the command, but free up the MSD OUT endpoint
377:                               //buffer for fulfilling whatever request may have been received.
378:                               //gblCBW = msd_cbw; //we are doing this, but below method can yeild smaller code size
379:                               for(i = 0; i < MSD_CBW_SIZE; i++)
001802  E84204     INC.B W4, W4
001804  E94285     DEC.B W5, W5
001806  3AFFF9     BRA NZ, 0x17FA
380:                               {
381:                                   *((uint8_t*)&gblCBW.dCBWSignature + i) = *((uint8_t*)&msd_cbw.dCBWSignature + i);
0017FA  FB8304     ZE W4, W6
0017FC  2081E0     MOV #0x81E, W0
0017FE  20A7C7     MOV #0xA7C, W7
001800  7B73E0     MOV.B [W0+W6], [W7+W6]
382:                               }
383:               
384:                               //If this CBW is valid?
385:                               if((USBHandleGetLength(USBMSDOutHandle) == MSD_CBW_SIZE) && (gblCBW.dCBWSignature == MSD_VALID_CBW_SIGNATURE))
001808  B3C1F4     MOV #0x1F, W4
00180A  124F91     SUBR.B W4, [W1], [W15]
00180C  3A004B     BRA NZ, 0x18A4
00180E  253554     MOV #0x5355, W4
001810  243425     MOV #0x4342, W5
001812  8053E6     MOV gblCBW, W6
001814  8053F7     MOV 0xA7E, W7
001816  530F84     SUB W6, W4, [W15]
001818  5B8F85     SUBB W7, W5, [W15]
00181A  3A0044     BRA NZ, 0x18A4
386:                               {
387:                                   //The CBW was valid, set flag meaning any stalls after this point
388:                                   //should not be "persistent" (as in the case of non-valid CBWs).
389:                                   MSDCBWValid = true;
00181C  B3C010     MOV #0x1, W0
00181E  B7EA75     MOV.B WREG, MSDCBWValid
390:               
391:                                   //Is this CBW meaningful?
392:                                   if((gblCBW.bCBWLUN <= MAX_LUN)                                      //Verify the command is addressed to a supported LUN
001820  20A894     MOV #0xA89, W4
001822  784214     MOV.B [W4], W4
001824  524FE0     SUB.B W4, #0x0, [W15]
001826  3A0037     BRA NZ, 0x1896
393:                                       &&(gblCBW.bCBWCBLength <= MSD_MAX_CB_SIZE)                          //Verify the claimed CB length is reasonable/valid
001828  20A8A4     MOV #0xA8A, W4
00182A  784214     MOV.B [W4], W4
00182C  524FF0     SUB.B W4, #0x10, [W15]
00182E  3E0033     BRA GTU, 0x1896
394:                                       &&(gblCBW.bCBWCBLength >= 0x01)                                     //Verify the claimed CB length is reasonable/valid
001830  524FE0     SUB.B W4, #0x0, [W15]
001832  320031     BRA Z, 0x1896
395:                                       &&((gblCBW.bCBWFlags & MSD_CBWFLAGS_RESERVED_BITS_MASK) == 0x00))   //Verify reserved bits are clear
001834  20A885     MOV #0xA88, W5
001836  784295     MOV.B [W5], W5
001838  780205     MOV W5, W4
00183A  B203F4     AND #0x3F, W4
00183C  3A002C     BRA NZ, 0x1896
396:                                   {
397:               
398:                                       //The CBW was both valid and meaningful.
399:                                       //Begin preparing a valid Command Status Wrapper (CSW),
400:                                       //in anticipation of completing the request successfully.
401:                                       //If an error detected is later, we will change the status
402:                                       //before sending the CSW.
403:                                       msd_csw.dCSWSignature = MSD_VALID_CSW_SIGNATURE;
00183E  253554     MOV #0x5355, W4
001840  8841F4     MOV W4, msd_csw
001842  253424     MOV #0x5342, W4
001844  884204     MOV W4, 0x840
404:                                       msd_csw.dCSWTag = gblCBW.dCBWTag;
001846  805406     MOV 0xA80, W6
001848  805417     MOV 0xA82, W7
00184A  884216     MOV W6, 0x842
00184C  884227     MOV W7, 0x844
405:                                       msd_csw.dCSWDataResidue = 0x0;
00184E  EF2846     CLR 0x846
001850  EF2848     CLR 0x848
406:                                       msd_csw.bCSWStatus = MSD_CSW_COMMAND_PASSED;
001852  B3C000     MOV #0x0, W0
001854  B7E84A     MOV.B WREG, 0x84A
001856  B7EA78     MOV.B WREG, MSDReadState
001858  B7EA79     MOV.B WREG, MSDWriteState
00185A  B7EA7A     MOV.B WREG, MSDRetryAttempt
407:               
408:                                       //Since a new CBW just arrived, we should re-init the
409:                                       //lower level state machines to their default states.
410:                                       //Even if the prior operation didn't fully complete
411:                                       //normally, we should abandon the prior operation, when
412:                                       //a new CBW arrives.
413:                                       MSDCommandState = MSD_COMMAND_WAIT;
414:                                       MSDReadState = MSD_READ10_WAIT;
415:                                       MSDWriteState = MSD_WRITE10_WAIT;
416:               
417:                                       //Keep track of retry attempts, in case of temporary
418:                                       //failures during read or write of the media.
419:                                       MSDRetryAttempt = 0;
420:               
421:                                       //Check the command.  With the exception of the REQUEST_SENSE
422:                                       //command, we should reset the sense key info for each new command block.
423:                                       //Assume the command will get processed successfully (and hence "NO SENSE"
424:                                       //response, which is used for success cases), unless handler code
425:                                       //later on detects some kind of error.  If it does, it should
426:                                       //update the sense keys to reflect the type of error detected,
427:                                       //prior to sending the CSW.
428:                                       if(gblCBW.CBWCB[0] != MSD_REQUEST_SENSE)
00185C  20A8B4     MOV #0xA8B, W4
00185E  784214     MOV.B [W4], W4
001860  524FE3     SUB.B W4, #0x3, [W15]
001862  320006     BRA Z, 0x1870
429:                                       {
430:                                           gblSenseData[LUN_INDEX].SenseKey=S_NO_SENSE;
001864  A90A9F     BCLR 0xA9F, #0
001866  A92A9F     BCLR 0xA9F, #1
001868  A94A9F     BCLR 0xA9F, #2
00186A  A96A9F     BCLR 0xA9F, #3
431:                                           gblSenseData[LUN_INDEX].ASC=ASC_NO_ADDITIONAL_SENSE_INFORMATION;
00186C  B7EAA9     MOV.B WREG, 0xAA9
00186E  B7EAAA     MOV.B WREG, 0xAAA
432:                                           gblSenseData[LUN_INDEX].ASCQ=ASCQ_NO_ADDITIONAL_SENSE_INFORMATION;
433:                                       }
434:               
435:                                       //Isolate the data direction bit.  The direction bit is bit 7 of the bCBWFlags byte.
436:                                       //Then, based on the direction of the data transfer, prepare the MSD state machine
437:                                       //so it knows how to proceed with processing the request.
438:                                       //If bit7 = 0, then direction is OUT from host.  If bit7 = 1, direction is IN to host
439:                                       if (gblCBW.bCBWFlags & MSD_CBW_DIRECTION_BITMASK)
001870  52CFE0     SUB.B W5, #0x0, [W15]
001872  3D0003     BRA GE, 0x187A
440:                                       {
441:                                           MSD_State = MSD_DATA_IN;
001874  B3C010     MOV #0x1, W0
001876  B7EA76     MOV.B WREG, MSD_State
001878  370002     BRA 0x187E
442:                                       }
443:                                       else //else direction must be OUT from host
444:                                       {
445:                                           MSD_State = MSD_DATA_OUT;
00187A  B3C020     MOV #0x2, W0
00187C  B7EA76     MOV.B WREG, MSD_State
446:                                       }
447:               
448:                                       //Determine if the host is expecting there to be data transfer or not.
449:                                       //Doing this now will make for quicker error checking later.
450:                                       if(gblCBW.dCBWDataTransferLength != 0)
00187E  805426     MOV 0xA84, W6
001880  805437     MOV 0xA86, W7
001882  530FE0     SUB W6, #0x0, [W15]
001884  5B8FE0     SUBB W7, #0x0, [W15]
001886  320002     BRA Z, 0x188C
451:                                       {
452:                                           MSDHostNoData = false;
001888  EF6AB6     CLR.B MSDHostNoData
00188A  370002     BRA 0x1890
453:                                       }
454:                                       else
455:                                       {
456:                                           MSDHostNoData = true;
00188C  B3C010     MOV #0x1, W0
00188E  B7EAB6     MOV.B WREG, MSDHostNoData
457:                                       }
458:               
459:                                       //Copy the received command to the lower level command
460:                                       //state machine, so it knows what to do.
461:                                       MSDCommandState = gblCBW.CBWCB[0];
001890  784004     MOV.B W4, W0
001892  B7EA77     MOV.B WREG, MSDCommandState
001894  370047     BRA 0x1924
462:                                   }
463:                                   else
464:                                   {
465:                                       //else the CBW wasn't meaningful.  Section 6.4 of BOT specs v1.0 says,
466:                                       //"The response of a device to a CBW that is not meaningful is not specified."
467:                                       //Lets STALL the bulk endpoints, so as to promote the possibility of recovery.
468:                                       USBStallEndpoint(MSD_DATA_IN_EP, IN_TO_HOST);
001896  B3C011     MOV #0x1, W1
001898  784001     MOV.B W1, W0
00189A  07F8E8     RCALL USBStallEndpoint
469:                                       USBStallEndpoint(MSD_DATA_OUT_EP, OUT_FROM_HOST);
00189C  EB4080     CLR.B W1
00189E  B3C010     MOV #0x1, W0
0018A0  07F8E5     RCALL USBStallEndpoint
0018A2  370040     BRA 0x1924
470:                                   }
471:                               }//end of: if((USBHandleGetLength(USBMSDOutHandle) == MSD_CBW_SIZE) && (gblCBW.dCBWSignature == MSD_VALID_CBW_SIGNATURE))
472:                               else  //The CBW was not valid.
473:                               {
474:                                   //Section 6.6.1 of the BOT specifications rev. 1.0 says the device shall STALL bulk IN and OUT
475:                                   //endpoints (or should discard OUT data if not stalled), and should stay in this state until a
476:                                   //"Reset Recovery" (MSD Reset + clear endpoint halt commands on EP0, see section 5.3.4)
477:                                   USBStallEndpoint(MSD_DATA_IN_EP, IN_TO_HOST);
0018A4  B3C011     MOV #0x1, W1
0018A6  784001     MOV.B W1, W0
0018A8  07F8E1     RCALL USBStallEndpoint
478:                                   USBStallEndpoint(MSD_DATA_OUT_EP, OUT_FROM_HOST);
0018AA  EB4080     CLR.B W1
0018AC  B3C010     MOV #0x1, W0
0018AE  07F8DE     RCALL USBStallEndpoint
479:                                   MSDCBWValid = false;    //Flag so as to enable a "persistent"
0018B0  EF6A75     CLR.B MSDCBWValid
0018B2  370038     BRA 0x1924
480:                                   //stall (cannot be cleared by clear endpoint halt, unless preceded
481:                                   //by an MSD reset).
482:                               }
483:                           }//if(!USBHandleBusy(USBMSDOutHandle))
484:                           break;
485:                       }//end of: case MSD_WAIT:
486:                       case MSD_DATA_IN:
487:                           if(MSDProcessCommand() == MSD_COMMAND_WAIT)
0018B4  07FF52     RCALL MSDProcessCommand
0018B6  404FE1     ADD.B W0, #0x1, [W15]
0018B8  3A0035     BRA NZ, 0x1924
488:                           {
489:                               // Done processing the command, send the status
490:                               MSD_State = MSD_SEND_CSW;
0018BA  B3C030     MOV #0x3, W0
0018BC  B7EA76     MOV.B WREG, MSD_State
0018BE  370032     BRA 0x1924
491:                           }
492:                           break;
493:                       case MSD_DATA_OUT:
494:                           if(MSDProcessCommand() == MSD_COMMAND_WAIT)
0018C0  07FF4C     RCALL MSDProcessCommand
0018C2  404FE1     ADD.B W0, #0x1, [W15]
0018C4  3A002F     BRA NZ, 0x1924
495:                           {
496:                               /* Finished receiving the data prepare and send the status */
497:                               if ((msd_csw.bCSWStatus == MSD_CSW_COMMAND_PASSED)&&(msd_csw.dCSWDataResidue!=0))
0018C6  2084A4     MOV #0x84A, W4
0018C8  784214     MOV.B [W4], W4
0018CA  524FE0     SUB.B W4, #0x0, [W15]
0018CC  3A0007     BRA NZ, 0x18DC
0018CE  804234     MOV 0x846, W4
0018D0  804245     MOV 0x848, W5
0018D2  520FE0     SUB W4, #0x0, [W15]
0018D4  5A8FE0     SUBB W5, #0x0, [W15]
0018D6  320002     BRA Z, 0x18DC
498:                               {
499:                                   msd_csw.bCSWStatus = MSD_CSW_PHASE_ERROR;
0018D8  B3C020     MOV #0x2, W0
0018DA  B7E84A     MOV.B WREG, 0x84A
500:                               }
501:                               MSD_State = MSD_SEND_CSW;
0018DC  B3C030     MOV #0x3, W0
0018DE  B7EA76     MOV.B WREG, MSD_State
0018E0  370021     BRA 0x1924
502:                           }
503:                           break;
504:                       case MSD_SEND_CSW:
505:                           //Check to make sure the bulk IN endpoint is available before sending CSW.
506:                           //The endpoint might still be busy sending the last packet on the IN endpoint.
507:                           if(USBHandleBusy(USBGetNextHandle(MSD_DATA_IN_EP, IN_TO_HOST)) == true)
0018E2  8040E4     MOV 0x81C, W4
0018E4  520FE0     SUB W4, #0x0, [W15]
0018E6  320003     BRA Z, 0x18EE
0018E8  EB0280     CLR W5
0018EA  128F94     SUBR W5, [W4], [W15]
0018EC  35001B     BRA LT, 0x1924
508:                           {
509:                               break;  //Not available yet.  Just stay in this state and try again later.
510:                           }
511:                           
512:                           //Send the Command Status Wrapper (CSW) packet            
513:                           USBMSDInHandle = USBTxOnePacket(MSD_DATA_IN_EP,(uint8_t*)&msd_csw,MSD_CSW_SIZE);
0018EE  B3C0D3     MOV #0xD, W3
0018F0  2083E2     MOV #0x83E, W2
0018F2  B3C011     MOV #0x1, W1
0018F4  784001     MOV.B W1, W0
0018F6  07F890     RCALL USBTransferOnePacket
0018F8  885390     MOV W0, USBMSDInHandle
514:                           //If the bulk OUT endpoint isn't already armed, make sure to do so 
515:                           //now so we can receive the next CBW packet from the host.
516:                           if(!USBHandleBusy(USBMSDOutHandle))
0018FA  805384     MOV USBMSDOutHandle, W4
0018FC  520FE0     SUB W4, #0x0, [W15]
0018FE  320003     BRA Z, 0x1906
001900  EB0300     CLR W6
001902  130F94     SUBR W6, [W4], [W15]
001904  350006     BRA LT, 0x1912
517:                           {
518:                               USBMSDOutHandle = USBRxOnePacket(MSD_DATA_OUT_EP,(uint8_t*)&msd_cbw,MSD_OUT_EP_SIZE);
001906  B3C403     MOV #0x40, W3
001908  2081E2     MOV #0x81E, W2
00190A  EB4080     CLR.B W1
00190C  B3C010     MOV #0x1, W0
00190E  07F884     RCALL USBTransferOnePacket
001910  885380     MOV W0, USBMSDOutHandle
519:                           }
520:                           MSD_State=MSD_WAIT;
001912  EF6A76     CLR.B MSD_State
521:                           break;
001914  370007     BRA 0x1924
522:                       default:
523:                           //Illegal condition that should not happen, but might occur if the
524:                           //device firmware incorrectly calls MSDTasks() prior to calling
525:                           //USBMSDInit() during the set-configuration portion of enumeration.
526:                           MSD_State=MSD_WAIT;
001916  EB4080     CLR.B W1
001918  784001     MOV.B W1, W0
00191A  B7EA76     MOV.B WREG, MSD_State
527:                           msd_csw.bCSWStatus = MSD_CSW_PHASE_ERROR;
00191C  B3C020     MOV #0x2, W0
00191E  B7E84A     MOV.B WREG, 0x84A
528:                           USBStallEndpoint(MSD_DATA_OUT_EP, OUT_FROM_HOST);
001920  B3C010     MOV #0x1, W0
001922  07F8A4     RCALL USBStallEndpoint
529:                   }//switch(MSD_State)
530:                   
531:                   //Safe to re-enable USB interrupts now.
532:                   USBUnmaskInterrupts();
001924  A8C09E     BSET IEC5, #6
533:                   
534:                   return MSD_State;
001926  BFCA76     MOV.B MSD_State, WREG
535:               }
001928  060000     RETURN
536:               
537:               
538:               /******************************************************************************
539:                	Function:
540:                		uint8_t MSDProcessCommand(void)
541:                		
542:                	Description:
543:                		This funtion processes a command received through the MSD
544:                		class driver
545:                		
546:                	PreCondition:
547:                		None
548:                		
549:                	Paramters:
550:                		None
551:                		
552:                	Return Values:
553:                		uint8_t - the current state of the MSDProcessCommand state
554:                		machine.  The valid values are defined in MSD.h under the
555:                		MSDProcessCommand state machine declaration section
556:                		
557:                	Remarks:
558:                		None
559:                
560:                *****************************************************************************/	
561:               uint8_t MSDProcessCommand(void)
562:               {   
563:                   //Check if the media is either not present, or has been flagged by firmware
564:                   //to pretend to be non-present (ex: SoftDetached).
565:                   if((LUNMediaDetect() == false) || (SoftDetach[gblCBW.bCBWLUN] == true))
00175A  805970     MOV 0xB2E, W0
00175C  805934     MOV 0xB26, W4
00175E  010004     CALL W4
001760  504FE0     SUB.B W0, #0x0, [W15]
001762  320007     BRA Z, 0x1772
001764  20A894     MOV #0xA89, W4
001766  784214     MOV.B [W4], W4
001768  FB8204     ZE W4, W4
00176A  20A745     MOV #0xA74, W5
00176C  7A42E5     MOV.B [W5+W4], W5
00176E  52CFE0     SUB.B W5, #0x0, [W15]
001770  320008     BRA Z, 0x1782
566:                   {
567:                       //Clear flag so we know the media need initialization, if it becomes 
568:                       //present in the future.
569:                       gblMediaPresent &= ~((uint16_t)1<<gblCBW.bCBWLUN);
001772  BFCA89     MOV.B 0xA89, WREG
001774  FB8000     ZE W0, W0
001776  200014     MOV #0x1, W4
001778  DD2000     SL W4, W0, W0
00177A  EA8000     COM W0, W0
00177C  B62AB4     AND gblMediaPresent
570:                       MSDProcessCommandMediaAbsent();
00177E  07FFC9     RCALL MSDProcessCommandMediaAbsent
001780  37001D     BRA 0x17BC
571:                  	}
572:                   else
573:                   {
574:                       //Check if the media is present and hasn't been already flagged as initialized.
575:                       if((gblMediaPresent & ((uint16_t)1<<gblCBW.bCBWLUN)) == 0)
001782  200015     MOV #0x1, W5
001784  DD2A04     SL W5, W4, W4
001786  8055A0     MOV gblMediaPresent, W0
001788  600204     AND W0, W4, W4
00178A  3A0017     BRA NZ, 0x17BA
576:                       {
577:                           //Try to initialize the media
578:                           if(LUNMediaInitialize())
00178C  805970     MOV 0xB2E, W0
00178E  805904     MOV LUN, W4
001790  010004     CALL W4
001792  500FE0     SUB W0, #0x0, [W15]
001794  320010     BRA Z, 0x17B6
579:                           {
580:                               //The media initialized successfully.  Set flag letting software
581:                               //know that it doesn't need re-initialization again (unless the 
582:                               //media is removable and is subsequently removed and re-inserted). 
583:                               gblMediaPresent |= ((uint16_t)1<<gblCBW.bCBWLUN);
001796  BFCA89     MOV.B 0xA89, WREG
001798  FB8000     ZE W0, W0
00179A  200014     MOV #0x1, W4
00179C  DD2000     SL W4, W0, W0
00179E  B72AB4     IOR gblMediaPresent
584:               
585:                               //The media is present and has initialized successfully.  However,
586:                               //we should still notify the host that the media may have changed,
587:                               //from the host's perspective, since we just initialized it for 
588:                               //the first time.         
589:                               gblSenseData[LUN_INDEX].SenseKey = S_UNIT_ATTENTION;
0017A0  A90A9F     BCLR 0xA9F, #0
0017A2  A82A9F     BSET 0xA9F, #1
0017A4  A84A9F     BSET 0xA9F, #2
0017A6  A96A9F     BCLR 0xA9F, #3
590:                               gblSenseData[LUN_INDEX].ASC = ASC_NOT_READY_TO_READY_CHANGE;
0017A8  B3C280     MOV #0x28, W0
0017AA  B7EAA9     MOV.B WREG, 0xAA9
591:                               gblSenseData[LUN_INDEX].ASCQ = ASCQ_MEDIUM_MAY_HAVE_CHANGED;
0017AC  EF6AAA     CLR.B 0xAAA
592:                               //Signify a soft error to the host, so it knows to check the 
593:                               //sense keys to learn that the media just changed.
594:                               msd_csw.bCSWStatus = MSD_CSW_COMMAND_FAILED; //No real "error" per se has occurred
0017AE  784004     MOV.B W4, W0
0017B0  B7E84A     MOV.B WREG, 0x84A
595:                               //Process the command now.
596:                               MSDProcessCommandMediaPresent();
0017B2  07FEBD     RCALL MSDProcessCommandMediaPresent
0017B4  370003     BRA 0x17BC
597:                           }
598:                           else
599:                           {
600:                               //The media failed to initialize for some reason.
601:                               MSDProcessCommandMediaAbsent();
0017B6  07FFAD     RCALL MSDProcessCommandMediaAbsent
0017B8  370001     BRA 0x17BC
602:                           }
603:                       }
604:                       else
605:                       {
606:                           //The media was present and was already initialized/ready to process
607:                           //the host's command.
608:                           MSDProcessCommandMediaPresent();
0017BA  07FEB9     RCALL MSDProcessCommandMediaPresent
609:                       }
610:                   }
611:               
612:                   return MSDCommandState;
613:               }
0017BC  BFCA77     MOV.B MSDCommandState, WREG
0017BE  060000     RETURN
614:               
615:               /******************************************************************************
616:                	Function:
617:                		void MSDProcessCommandMediaAbsent(void)
618:                		
619:                	Description:
620:                		This funtion processes a command received through the MSD
621:                		class driver, when the removable MSD media (ex: MMC/SD card) is not 
622:                		present, or has been "soft detached" deliberately by the application
623:                		firmware.
624:                		
625:                	PreCondition:
626:                		The MSD function should have already been initialized (the media isn't
627:                		required to be initalized however).  Additionally, a valid MSD Command 
628:                		Block Wrapper (CBW) should have been received and partially parsed 
629:                		prior to calling this function.
630:                		
631:                	Parameters:
632:                		None
633:                	
634:                	Return Values:
635:                		uint8_t - the current state of the MSDProcessCommand state
636:                		machine.  The valid values are defined in usb_device_msd.h under the 
637:                		MSDProcessCommand state machine declaration section
638:                		
639:                	Remarks:
640:                		None
641:                
642:                 *****************************************************************************/	
643:               void MSDProcessCommandMediaAbsent(void)
644:               {
645:                   //Check what command we are currently processing, to decide how to handle it.
646:                   switch(MSDCommandState)
001712  20A774     MOV #0xA77, W4
001714  784214     MOV.B [W4], W4
001716  524FF2     SUB.B W4, #0x12, [W15]
001718  320019     BRA Z, 0x174C
00171A  3E0005     BRA GTU, 0x1726
00171C  524FE0     SUB.B W4, #0x0, [W15]
00171E  320012     BRA Z, 0x1744
001720  524FE3     SUB.B W4, #0x3, [W15]
001722  3A0018     BRA NZ, 0x1754
001724  370005     BRA 0x1730
001726  524FFE     SUB.B W4, #0x1E, [W15]
001728  32000D     BRA Z, 0x1744
00172A  424FE3     ADD.B W4, #0x3, [W15]
00172C  3A0013     BRA NZ, 0x1754
00172E  370010     BRA 0x1750
647:                   {
648:                       case MSD_REQUEST_SENSE:
649:                           //The host sends this request when it wants to check the status of 
650:                           //the device, and/or identify the reason for the last error that was 
651:                           //reported by the device.
652:                           //Set the sense keys to let the host know that the reason the last
653:                           //command failed was because the media was not present.
654:                           ResetSenseData();
001730  07FCA7     RCALL ResetSenseData
655:                           gblSenseData[LUN_INDEX].SenseKey=S_NOT_READY;
001732  A90A9F     BCLR 0xA9F, #0
001734  A82A9F     BSET 0xA9F, #1
001736  A94A9F     BCLR 0xA9F, #2
001738  A96A9F     BCLR 0xA9F, #3
656:                           gblSenseData[LUN_INDEX].ASC=ASC_MEDIUM_NOT_PRESENT;
00173A  B3C3A0     MOV #0x3A, W0
00173C  B7EAA9     MOV.B WREG, 0xAA9
657:                           gblSenseData[LUN_INDEX].ASCQ=ASCQ_MEDIUM_NOT_PRESENT;
00173E  EF6AAA     CLR.B 0xAAA
658:               
659:                           //After initializing the sense keys above, the subsequent handling 
660:                           //code for this state is the same with or without media.
661:                           //Therefore, to save code size, we just call the media present handler.
662:                           MSDProcessCommandMediaPresent();
001740  07FEF6     RCALL MSDProcessCommandMediaPresent
663:                           break;
001742  37000A     BRA 0x1758
664:               
665:                       case MSD_PREVENT_ALLOW_MEDIUM_REMOVAL:
666:                       case MSD_TEST_UNIT_READY:
667:                           //The host will typically periodically poll the device by sending this
668:                           //request.  Since this is a removable media device, and the media isn't
669:                           //present, we need to indicate an error to let the host know (to 
670:                           //check the sense keys, which will tell it the media isn't present).
671:                           msd_csw.bCSWStatus = MSD_CSW_COMMAND_FAILED;
001744  B3C010     MOV #0x1, W0
001746  B7E84A     MOV.B WREG, 0x84A
672:                           MSDCommandState = MSD_COMMAND_WAIT;
001748  EFEA77     SETM.B MSDCommandState
673:                           break;
00174A  370006     BRA 0x1758
674:               
675:                       case MSD_INQUIRY:
676:                           //The handling code for this state is the same with or without media.
677:                           //Therefore, to save code size, we just call the media present handler.
678:                           MSDProcessCommandMediaPresent();
00174C  07FEF0     RCALL MSDProcessCommandMediaPresent
679:                           break;
00174E  370004     BRA 0x1758
680:               
681:                       case MSD_COMMAND_RESPONSE:
682:                           //The handling code for this state is the same with or without media.
683:                           //Therefore, to save code size, we just call the media present handler.
684:                           MSDProcessCommandMediaPresent();
001750  07FEEE     RCALL MSDProcessCommandMediaPresent
685:                           break;
001752  370002     BRA 0x1758
686:               
687:                       default:
688:                           //An unsupported command was received.  Since we are uncertain how
689:                           //many bytes we should send/or receive, we should set sense key data
690:                           //and then STALL, to force the host to perform error recovery.
691:                           MSDErrorHandler(MSD_ERROR_UNSUPPORTED_COMMAND);
001754  B3C7F0     MOV #0x7F, W0
001756  07FCEA     RCALL MSDErrorHandler
692:                           break;
693:                   }
694:               }//void MSDProcessCommandMediaAbsent(void)
001758  060000     RETURN
695:               
696:               
697:               /******************************************************************************
698:                	Function:
699:                		void MSDProcessCommandMediaPresent(void)
700:                		
701:                	Description:
702:                		This funtion processes a command received through the MSD
703:                		class driver
704:                		
705:                	PreCondition:
706:                		None
707:                		
708:                	Paramters:
709:                		None
710:                	
711:                	Return Values:
712:                		uint8_t - the current state of the MSDProcessCommand state
713:                		machine.  The valid values are defined in MSD.h under the 
714:                		MSDProcessCommand state machine declaration section
715:                		
716:                	Remarks:
717:                		None
718:                
719:                *****************************************************************************/	
720:               void MSDProcessCommandMediaPresent(void)
721:               {
00152E  BE9F88     MOV.D W8, [W15++]
722:                   uint8_t i; 
723:                   uint8_t NumBytesInPacket;
724:               
725:                   //Check what command we are currently processing, to decide how to handle it.
726:                   switch(MSDCommandState)
001530  20A774     MOV #0xA77, W4
001532  784214     MOV.B [W4], W4
001534  524FFE     SUB.B W4, #0x1E, [W15]
001536  32008A     BRA Z, 0x164C
001538  3E000D     BRA GTU, 0x1554
00153A  524FF2     SUB.B W4, #0x12, [W15]
00153C  320026     BRA Z, 0x158A
00153E  3E0005     BRA GTU, 0x154A
001540  524FE0     SUB.B W4, #0x0, [W15]
001542  320091     BRA Z, 0x1666
001544  524FE3     SUB.B W4, #0x3, [W15]
001546  3A00E1     BRA NZ, 0x170A
001548  370059     BRA 0x15FC
00154A  524FFA     SUB.B W4, #0x1A, [W15]
00154C  32006C     BRA Z, 0x1626
00154E  524FFB     SUB.B W4, #0x1B, [W15]
001550  3A00DC     BRA NZ, 0x170A
001552  37009D     BRA 0x168E
001554  B3C2A5     MOV #0x2A, W5
001556  524F85     SUB.B W4, W5, [W15]
001558  320013     BRA Z, 0x1580
00155A  3E0007     BRA GTU, 0x156A
00155C  52C2E5     SUB.B W5, #0x5, W5
00155E  524F85     SUB.B W4, W5, [W15]
001560  32002C     BRA Z, 0x15BA
001562  42C2E3     ADD.B W5, #0x3, W5
001564  524F85     SUB.B W4, W5, [W15]
001566  3A00D1     BRA NZ, 0x170A
001568  370006     BRA 0x1576
00156A  B3C2F5     MOV #0x2F, W5
00156C  524F85     SUB.B W4, W5, [W15]
00156E  32008F     BRA Z, 0x168E
001570  424FE3     ADD.B W4, #0x3, [W15]
001572  3A00CB     BRA NZ, 0x170A
001574  370090     BRA 0x1696
727:                   {
728:                       case MSD_READ_10:
729:                           //The host issues a "Read 10" request when it wants to read some number
730:                           //of 10-bit length blocks (512 byte blocks) of data from the media.
731:                           //Since this is a common request and is part of the "critical path"
732:                           //performance wise, we put this at the top of the state machine checks.
733:                           if(MSDReadHandler() == MSD_READ10_WAIT)
001576  07FF49     RCALL MSDReadHandler
001578  504FE0     SUB.B W0, #0x0, [W15]
00157A  3A00C9     BRA NZ, 0x170E
734:                           {
735:                               MSDCommandState = MSD_COMMAND_WAIT;
00157C  EFEA77     SETM.B MSDCommandState
00157E  3700C7     BRA 0x170E
736:                           }
737:                           break;
738:               
739:                   	case MSD_WRITE_10:
740:                           //The host issues a "Write 10" request when it wants to write some number
741:                           //of 10-bit length blocks (512 byte blocks) of data to the media.
742:                           //Since this is a common request and is part of the "critical path"
743:                           //performance wise, we put this near the top of the state machine checks.
744:                           if(MSDWriteHandler() == MSD_WRITE10_WAIT)
001580  07FE84     RCALL MSDWriteHandler
001582  504FE0     SUB.B W0, #0x0, [W15]
001584  3A00C4     BRA NZ, 0x170E
745:                           {
746:                               MSDCommandState = MSD_COMMAND_WAIT;
001586  EFEA77     SETM.B MSDCommandState
001588  3700C2     BRA 0x170E
747:                           }
748:                           break;
749:                           
750:                   	case MSD_INQUIRY:
751:                   	{
752:                           //The host wants to learn more about our MSD device (spec version,
753:                           //supported abilities, etc.)
754:               
755:                           //Error check: If host doesn't want any data, then just advance to CSW phase.
756:                           if(MSDHostNoData == true)
00158A  20AB64     MOV #0xAB6, W4
00158C  784214     MOV.B [W4], W4
00158E  524FE0     SUB.B W4, #0x0, [W15]
001590  320002     BRA Z, 0x1596
757:                           {
758:                               MSDCommandState = MSD_COMMAND_WAIT;
001592  EFEA77     SETM.B MSDCommandState
759:                               break;
001594  3700BC     BRA 0x170E
760:                           }    
761:                           
762:                           //Get the 16-bit "Allocation Length" (Number of bytes to respond 
763:                           //with.  Note: Value provided in CBWCB is in big endian format)
764:                           TransferLength.byte.HB = gblCBW.CBWCB[3]; //MSB
001596  BFCA8E     MOV.B 0xA8E, WREG
001598  B7EAC5     MOV.B WREG, 0xAC5
765:                           TransferLength.byte.LB = gblCBW.CBWCB[4]; //LSB
00159A  BFCA8F     MOV.B 0xA8F, WREG
00159C  B7EAC4     MOV.B WREG, TransferLength
766:                       	//Check for possible errors.  
767:                           if(MSDCheckForErrorCases(TransferLength.Val) != MSD_ERROR_CASE_NO_ERROR)
00159E  805620     MOV TransferLength, W0
0015A0  200001     MOV #0x0, W1
0015A2  07FE1E     RCALL MSDCheckForErrorCases
0015A4  504FE0     SUB.B W0, #0x0, [W15]
0015A6  3A00B3     BRA NZ, 0x170E
768:                           {
769:                               break;
770:                           }
771:               
772:                         	//Compute and load proper csw residue and device in number of byte.
773:                           MSDComputeDeviceInAndResidue(sizeof(InquiryResponse));
0015A8  200240     MOV #0x24, W0
0015AA  07FD08     RCALL _MSDComputeDeviceInAndResidue
774:               
775:                           //If we get to here, this implies no errors were found and the command is legit.
776:               
777:                           //copy the inquiry results from the defined const buffer 
778:                           //  into the USB buffer so that it can be transmitted
779:                           memcpy((void *)&msd_buffer[0], (const void*)&inq_resp, sizeof(InquiryResponse));   //Inquiry response is 36 bytes total
0015AC  2084C1     MOV #0x84C, W1
0015AE  2844C4     MOV #0x844C, W4
0015B0  090023     REPEAT #0x23
0015B2  7858B4     MOV.B [W4++], [W1++]
780:                           MSDCommandState = MSD_COMMAND_RESPONSE;
0015B4  B3CFD0     MOV #0xFD, W0
0015B6  B7EA77     MOV.B WREG, MSDCommandState
781:                           break;
0015B8  3700AA     BRA 0x170E
782:                       }
783:                       case MSD_READ_CAPACITY:
784:                       {
785:                           //The host asked for the total capacity of the device.  The response
786:                           //packet is 8-bytes (32-bits for last LBA implemented, 32-bits for block size).
787:                           USB_MSD_SECTOR_SIZE sectorSize;
788:                           USB_MSD_CAPACITY capacity;
789:               
790:                           //get the information from the physical media
791:                           capacity.Val = LUNReadCapacity();
0015BA  805970     MOV 0xB2E, W0
0015BC  805914     MOV 0xB22, W4
0015BE  010004     CALL W4
0015C0  BE0400     MOV.D W0, W8
792:                           sectorSize.Val = LUNReadSectorSize();
0015C2  805970     MOV 0xB2E, W0
0015C4  805924     MOV 0xB24, W4
0015C6  010004     CALL W4
0015C8  780280     MOV W0, W5
793:                           
794:                           //Copy the data to the buffer.  Host expects the response in big endian format.
795:                           msd_buffer[0]=capacity.v[3];
0015CA  DE4A48     LSR W9, #8, W4
0015CC  784004     MOV.B W4, W0
0015CE  B7E84C     MOV.B WREG, msd_buffer
796:                           msd_buffer[1]=capacity.v[2];
0015D0  784009     MOV.B W9, W0
0015D2  B7E84D     MOV.B WREG, 0x84D
797:                           msd_buffer[2]=capacity.v[1];
0015D4  DE4248     LSR W8, #8, W4
0015D6  784004     MOV.B W4, W0
0015D8  B7E84E     MOV.B WREG, 0x84E
798:                           msd_buffer[3]=capacity.v[0];
0015DA  784008     MOV.B W8, W0
0015DC  B7E84F     MOV.B WREG, 0x84F
799:               
800:                           msd_buffer[4]=sectorSize.v[3];
0015DE  B82A61     MUL.UU W5, #1, W4
0015E0  EF6850     CLR.B 0x850
801:                           msd_buffer[5]=sectorSize.v[2];
0015E2  784005     MOV.B W5, W0
0015E4  B7E851     MOV.B WREG, 0x851
802:                           msd_buffer[6]=sectorSize.v[1];
0015E6  DE2348     LSR W4, #8, W6
0015E8  784006     MOV.B W6, W0
0015EA  B7E852     MOV.B WREG, 0x852
803:                           msd_buffer[7]=sectorSize.v[0];
0015EC  784004     MOV.B W4, W0
0015EE  B7E853     MOV.B WREG, 0x853
804:               
805:                           //Compute and load proper csw residue and device in number of byte.
806:                           TransferLength.Val = 0x08;      //READ_CAPACITY always has an 8-byte response.
0015F0  200080     MOV #0x8, W0
0015F2  885620     MOV W0, TransferLength
807:                           MSDComputeDeviceInAndResidue(0x08);
0015F4  07FCE3     RCALL _MSDComputeDeviceInAndResidue
808:                       
809:                           MSDCommandState = MSD_COMMAND_RESPONSE;
0015F6  B3CFD0     MOV #0xFD, W0
0015F8  B7EA77     MOV.B WREG, MSDCommandState
810:                           break;
0015FA  370089     BRA 0x170E
811:                       }
812:                       case MSD_REQUEST_SENSE:    
813:                           //The host normally sends this request after a CSW completed, where
814:                           //the device indicated some kind of error on the previous transfer.
815:                           //In this case, the host will typically issue this request, so it can
816:                           //learn more details about the cause/source of the error condition.
817:                           
818:                           //Error check: if the host doesn't want any data, just advance to CSW phase.
819:                           if(MSDHostNoData == true)
0015FC  20AB64     MOV #0xAB6, W4
0015FE  784214     MOV.B [W4], W4
001600  524FE0     SUB.B W4, #0x0, [W15]
001602  320002     BRA Z, 0x1608
820:                           {
821:                               MSDCommandState = MSD_COMMAND_WAIT;
001604  EFEA77     SETM.B MSDCommandState
822:                               break;
001606  370083     BRA 0x170E
823:                           }    
824:               
825:                         	//Compute and load proper csw residue and device in number of byte.
826:                           TransferLength.Val = sizeof(RequestSenseResponse);      //REQUEST_SENSE has an 18-byte response.
001608  200128     MOV #0x12, W8
00160A  885628     MOV W8, TransferLength
827:                           MSDComputeDeviceInAndResidue(sizeof(RequestSenseResponse));
00160C  780008     MOV W8, W0
00160E  07FCD6     RCALL _MSDComputeDeviceInAndResidue
828:                            
829:                           //Copy the requested response data from flash to the USB ram buffer.
830:                           for(i=0;i<sizeof(RequestSenseResponse);i++)
001610  EB4200     CLR.B W4
00161A  E84204     INC.B W4, W4
00161C  E94408     DEC.B W8, W8
00161E  3AFFF9     BRA NZ, 0x1612
831:                           {
832:                               msd_buffer[i]=gblSenseData[LUN_INDEX]._byte[i];
001612  FB8284     ZE W4, W5
001614  2084C6     MOV #0x84C, W6
001616  20A9D7     MOV #0xA9D, W7
001618  7AF367     MOV.B [W7+W5], [W6+W5]
833:                           }
834:                           MSDCommandState = MSD_COMMAND_RESPONSE;
001620  B3CFD0     MOV #0xFD, W0
001622  B7EA77     MOV.B WREG, MSDCommandState
835:                           break;
001624  370074     BRA 0x170E
836:                           
837:                       case MSD_MODE_SENSE:
838:                           msd_buffer[0]=0x03;
001626  B3C030     MOV #0x3, W0
001628  B7E84C     MOV.B WREG, msd_buffer
839:                           msd_buffer[1]=0x00;
00162A  EF684D     CLR.B 0x84D
840:                           msd_buffer[2]=(LUNWriteProtectState()) ? 0x80 : 0x00;
00162C  805970     MOV 0xB2E, W0
00162E  805954     MOV 0xB2A, W4
001630  010004     CALL W4
001632  EB4200     CLR.B W4
001634  504F84     SUB.B W0, W4, [W15]
001636  320001     BRA Z, 0x163A
001638  B3C804     MOV #0x80, W4
00163A  784004     MOV.B W4, W0
00163C  B7E84E     MOV.B WREG, 0x84E
841:                           msd_buffer[3]= 0x00;
00163E  EF684F     CLR.B 0x84F
842:               
843:                           //Compute and load proper csw residue and device in number of byte.
844:                           TransferLength.Val = 0x04;
001640  200040     MOV #0x4, W0
001642  885620     MOV W0, TransferLength
845:                           MSDComputeDeviceInAndResidue(0x04);
001644  07FCBB     RCALL _MSDComputeDeviceInAndResidue
846:                           MSDCommandState = MSD_COMMAND_RESPONSE;
001646  B3CFD0     MOV #0xFD, W0
001648  B7EA77     MOV.B WREG, MSDCommandState
847:                   	    break;
00164A  370061     BRA 0x170E
848:               
849:                       case MSD_PREVENT_ALLOW_MEDIUM_REMOVAL:
850:                           gblSenseData[LUN_INDEX].SenseKey=S_ILLEGAL_REQUEST;
00164C  A80A9F     BSET 0xA9F, #0
00164E  A92A9F     BCLR 0xA9F, #1
001650  A84A9F     BSET 0xA9F, #2
001652  A96A9F     BCLR 0xA9F, #3
851:                           gblSenseData[LUN_INDEX].ASC=ASC_INVALID_COMMAND_OPCODE;
001654  B3C200     MOV #0x20, W0
001656  B7EAA9     MOV.B WREG, 0xAA9
852:                           gblSenseData[LUN_INDEX].ASCQ=ASCQ_INVALID_COMMAND_OPCODE;
001658  EF6AAA     CLR.B 0xAAA
853:                           msd_csw.bCSWStatus = MSD_CSW_COMMAND_FAILED;
00165A  B3C010     MOV #0x1, W0
00165C  B7E84A     MOV.B WREG, 0x84A
854:                           msd_csw.dCSWDataResidue = 0x00;
00165E  EF2846     CLR 0x846
001660  EF2848     CLR 0x848
855:                           MSDCommandState = MSD_COMMAND_WAIT;
001662  EFEA77     SETM.B MSDCommandState
856:                           break;
001664  370054     BRA 0x170E
857:               
858:                       case MSD_TEST_UNIT_READY:
859:                           //The host will typically send this command periodically to check if
860:                           //it is ready to be used and to obtain polled notification of changes
861:                           //in status (ex: user removed media from a removable media MSD volume).
862:                           //There is no data stage for this request.  The information we send to
863:                           //the host in response to this request is entirely contained in the CSW.
864:                           
865:                           //First check for possible errors.
866:                           if(MSDCheckForErrorCases(0) != MSD_ERROR_CASE_NO_ERROR)
001666  B80060     MUL.UU W0, #0, W0
001668  07FDBB     RCALL MSDCheckForErrorCases
00166A  504FE0     SUB.B W0, #0x0, [W15]
00166C  3A0050     BRA NZ, 0x170E
867:                           {
868:                               break;
869:                           }    
870:                           //The stack sets this condition when the status of the removable media
871:                           //has just changed (ex: the user just plugged in the removable media,
872:                           //in which case we want to notify the host of the changed status, by
873:                           //sending a deliberate "error" notification).  This doesn't mean any 
874:                           //real error has occurred.
875:                           if((gblSenseData[LUN_INDEX].SenseKey==S_UNIT_ATTENTION) && (msd_csw.bCSWStatus==MSD_CSW_COMMAND_FAILED))
00166E  20A9F4     MOV #0xA9F, W4
001670  784214     MOV.B [W4], W4
001672  62426F     AND.B W4, #0xF, W4
001674  524FE6     SUB.B W4, #0x6, [W15]
001676  3A0006     BRA NZ, 0x1684
001678  2084A4     MOV #0x84A, W4
00167A  784214     MOV.B [W4], W4
00167C  524FE1     SUB.B W4, #0x1, [W15]
00167E  3A0002     BRA NZ, 0x1684
876:                           {
877:                               MSDCommandState = MSD_COMMAND_WAIT;
001680  EFEA77     SETM.B MSDCommandState
001682  370045     BRA 0x170E
878:                           }
879:                           else
880:                           {
881:                           	ResetSenseData();
001684  07FCFD     RCALL ResetSenseData
882:                           	msd_csw.dCSWDataResidue=0x00;
001686  EF2846     CLR 0x846
001688  EF2848     CLR 0x848
883:                               MSDCommandState = MSD_COMMAND_WAIT;
00168A  EFEA77     SETM.B MSDCommandState
00168C  370040     BRA 0x170E
884:                           }
885:                           break;
886:               
887:                       case MSD_VERIFY:
888:                       //Fall through to STOP_START
889:                           
890:                       case MSD_STOP_START:
891:                           msd_csw.dCSWDataResidue=0x00;
00168E  EF2846     CLR 0x846
001690  EF2848     CLR 0x848
892:                           MSDCommandState = MSD_COMMAND_WAIT;
001692  EFEA77     SETM.B MSDCommandState
893:                           break;
001694  37003C     BRA 0x170E
894:                           
895:                       case MSD_COMMAND_RESPONSE:
896:                           //This command state didn't originate from the host.  This state was
897:                           //set by the firmware (for one of the other handlers) when it was 
898:                           //finished preparing the data to send to the host, and it is now time
899:                           //to transmit the data over the bulk IN endpoint.
900:                           if(USBHandleBusy(USBMSDInHandle) == false)
001696  805394     MOV USBMSDInHandle, W4
001698  520FE0     SUB W4, #0x0, [W15]
00169A  320003     BRA Z, 0x16A2
00169C  EB0080     CLR W1
00169E  108F94     SUBR W1, [W4], [W15]
0016A0  350036     BRA LT, 0x170E
901:                           {
902:                               //We still have more bytes needing to be sent.  Compute how many 
903:                               //bytes should be in the next IN packet that we send.
904:                               if(gblCBW.dCBWDataTransferLength >= MSD_IN_EP_SIZE)
0016A2  805424     MOV 0xA84, W4
0016A4  805435     MOV 0xA86, W5
0016A6  2003F6     MOV #0x3F, W6
0016A8  520F86     SUB W4, W6, [W15]
0016AA  5A8FE0     SUBB W5, #0x0, [W15]
0016AC  360008     BRA LEU, 0x16BE
905:                               {
906:                                   NumBytesInPacket = MSD_IN_EP_SIZE;
0016BA  B3C403     MOV #0x40, W3
0016BC  370003     BRA 0x16C4
907:                                   gblCBW.dCBWDataTransferLength -= MSD_IN_EP_SIZE;
0016AE  2FFC06     MOV #0xFFC0, W6
0016B0  2FFFF7     MOV #0xFFFF, W7
0016B2  430004     ADD W6, W4, W0
0016B4  4B8085     ADDC W7, W5, W1
0016B6  885420     MOV W0, 0xA84
0016B8  885431     MOV W1, 0xA86
908:                               }   
909:                               else
910:                               {
911:                                   //This is a short packet and will be our last IN packet sent
912:                                   //in the transfer.
913:                                   NumBytesInPacket = gblCBW.dCBWDataTransferLength;
0016BE  784184     MOV.B W4, W3
914:                                   gblCBW.dCBWDataTransferLength = 0;
0016C0  EF2A84     CLR 0xA84
0016C2  EF2A86     CLR 0xA86
915:                               } 
916:                               
917:                               //We still have more bytes needing to be sent.  Check if we have
918:                               //already fulfilled the device input expected quantity of bytes.
919:                               //If so, we need to keep sending IN packets, but pad the extra
920:                               //bytes with value = 0x00 (see error case 5 MSD device BOT v1.0 
921:                               //spec handling).
922:                               if(TransferLength.Val >= NumBytesInPacket)
0016C4  805625     MOV TransferLength, W5
0016C6  FB8203     ZE W3, W4
0016C8  528F84     SUB W5, W4, [W15]
0016CA  310005     BRA C, 0x16D6
923:                               {
924:                                   //No problem, just send the requested data and keep track of remaining count.
925:                                   TransferLength.Val -= NumBytesInPacket;
0016D6  528204     SUB W5, W4, W4
0016D8  885624     MOV W4, TransferLength
0016DA  37000B     BRA 0x16F2
926:                               }    
927:                               else
928:                               {
929:                                   //The host is reading more bytes than the device has to send.
930:                                   //In this case, we still need to send the quantity of bytes requested,
931:                                   //but we have to fill the pad bytes with 0x00.  The below for loop
932:                                   //is execution speed inefficient, but performance isn't important 
933:                                   //since this code only executes in the case of a host error 
934:                                   //anyway (Hi > Di).
935:                                   for(i = 0; i < NumBytesInPacket; i++)
0016CC  EB4200     CLR.B W4
0016D0  51CF84     SUB.B W3, W4, [W15]
0016D2  3A0004     BRA NZ, 0x16DC
0016D4  37000E     BRA 0x16F2
0016EA  E84204     INC.B W4, W4
0016EC  51CF84     SUB.B W3, W4, [W15]
0016EE  3EFFF6     BRA GTU, 0x16DC
0016F0  885625     MOV W5, TransferLength
936:                                   {
937:                                       if(TransferLength.Val != 0)
0016DC  528FE0     SUB W5, #0x0, [W15]
0016DE  320002     BRA Z, 0x16E4
938:                                       {
939:                                           TransferLength.Val--;     
0016E0  E90285     DEC W5, W5
0016E2  370003     BRA 0x16EA
940:                                       }    
941:                                       else
942:                                       {
943:                                           msd_buffer[i] = 0x00;
0016CE  784004     MOV.B W4, W0
0016E4  FB8304     ZE W4, W6
0016E6  2084C7     MOV #0x84C, W7
0016E8  7B7380     MOV.B W0, [W7+W6]
944:                                       }    
945:                                   }    
946:                               }    
947:                               
948:                               //We are now ready to send the packet to the host.                   
949:                               USBMSDInHandle = USBTxOnePacket(MSD_DATA_IN_EP,(uint8_t*)&msd_buffer[0],NumBytesInPacket);
0016F2  2084C2     MOV #0x84C, W2
0016F4  B3C011     MOV #0x1, W1
0016F6  784001     MOV.B W1, W0
0016F8  07F98F     RCALL USBTransferOnePacket
0016FA  885390     MOV W0, USBMSDInHandle
950:                               
951:                               //Check to see if we are done sending all requested bytes of data
952:                               if(gblCBW.dCBWDataTransferLength == 0)
0016FC  805424     MOV 0xA84, W4
0016FE  805435     MOV 0xA86, W5
001700  520FE0     SUB W4, #0x0, [W15]
001702  5A8FE0     SUBB W5, #0x0, [W15]
001704  3A0004     BRA NZ, 0x170E
953:                               {
954:                                   //We have sent all the requested bytes.  Go ahead and
955:                                   //advance state so as to send the CSW.
956:                                   MSDCommandState = MSD_COMMAND_WAIT;
001706  EFEA77     SETM.B MSDCommandState
957:                                   break;                    
001708  370002     BRA 0x170E
958:                               }                    
959:                           }
960:                           break;
961:                       case MSD_COMMAND_ERROR:
962:                           default:
963:                               //An unsupported command was received.  Since we are uncertain how many
964:                               //bytes we should send/or receive, we should set sense key data and then
965:                               //STALL, to force the host to perform error recovery.
966:                               MSDErrorHandler(MSD_ERROR_UNSUPPORTED_COMMAND);
00170A  B3C7F0     MOV #0x7F, W0
00170C  07FD0F     RCALL MSDErrorHandler
967:                               break;
968:               	} // end switch	
969:               }//void MSDProcessCommandMediaPresent(void)
00170E  BE044F     MOV.D [--W15], W8
001710  060000     RETURN
970:               
971:               
972:               /******************************************************************************
973:                	Function:
974:                		static void MSDComputeDeviceInAndResidue(uint16_t DiExpected)
975:                		
976:                	Description:
977:                		This is a private function that performs Hi > Di data size checking
978:                		and handling.  This function also computes the proper CSW data residue
979:                		and updates the global variable.
980:                		
981:                	PreCondition:
982:                		Should only be called in the context of the 
983:                		MSDProcessCommandMediaPresent() handler function, after receiving a new
984:                		command that needs processing.  Before calling this function, make sure
985:                		the gblCBW.dCBWDataTransferLength and TransferLength.Val variables have
986:                		been pre-loaded with the expected host and device data size values.
987:                		
988:                	Parameters:
989:                		uint16_t DiExpected - Input: Firmware can specify an addional value that 
990:                		might be smaller than the TransferLength.Val value.  The function will
991:                		update TransferLength.Val with the smaller of the original value, or
992:                		DiExpected.
993:                		
994:                	Return Values:
995:                		None
996:                		
997:                	Remarks:
998:                		None
999:                
1000:                *****************************************************************************/
1001:              static void MSDComputeDeviceInAndResidue(uint16_t DiExpected)
1002:              {
1003:                  //Error check number of bytes to send.  Check for Hi < Di
1004:                  if(gblCBW.dCBWDataTransferLength < DiExpected)
000FBC  805424     MOV 0xA84, W4
000FBE  805435     MOV 0xA86, W5
000FC0  B80361     MUL.UU W0, #1, W6
000FC2  520F86     SUB W4, W6, [W15]
000FC4  5A8F87     SUBB W5, W7, [W15]
000FC6  310004     BRA C, 0xFD0
1005:                  {
1006:                      //The host has requested less data than the entire reponse.  We
1007:                      //send only the host requested quantity of bytes.
1008:                      msd_csw.dCSWDataResidue = 0;
000FC8  EF2846     CLR 0x846
000FCA  EF2848     CLR 0x848
1009:                      TransferLength.Val = gblCBW.dCBWDataTransferLength;
000FCC  885624     MOV W4, TransferLength
000FCE  370009     BRA 0xFE2
1010:                  }   	
1011:                  else
1012:                  {
1013:                      //The host requested greater than or equal to the number of bytes expected.
1014:                      if(DiExpected < TransferLength.Val)
000FD0  805626     MOV TransferLength, W6
000FD2  500F86     SUB W0, W6, [W15]
000FD4  310001     BRA C, 0xFD8
1015:                      {
1016:                          TransferLength.Val = DiExpected;
000FD6  885620     MOV W0, TransferLength
1017:                      }    
1018:                      msd_csw.dCSWDataResidue = gblCBW.dCBWDataTransferLength - TransferLength.Val;
000FD8  805626     MOV TransferLength, W6
000FDA  520206     SUB W4, W6, W4
000FDC  5A82E0     SUBB W5, #0x0, W5
000FDE  884234     MOV W4, 0x846
000FE0  884245     MOV W5, 0x848
1019:                  }     
1020:              }    
000FE2  060000     RETURN
1021:              
1022:              
1023:              /******************************************************************************
1024:               	Function:
1025:               		uint8_t MSDReadHandler(void)
1026:               		
1027:               	Description:
1028:               		This funtion processes a read command received through 
1029:               		the MSD class driver
1030:               		
1031:               	PreCondition:
1032:               		None
1033:               		
1034:               	Parameters:
1035:               		None
1036:               		
1037:               	Return Values:
1038:               		uint8_t - the current state of the MSDReadHandler state
1039:               		machine.  The valid values are defined in MSD.h under the 
1040:               		MSDReadHandler state machine declaration section
1041:               		
1042:               	Remarks:
1043:               		None
1044:               
1045:                *****************************************************************************/
1046:              uint8_t MSDReadHandler(void)
1047:              {
00140A  781F88     MOV W8, [W15++]
1048:                  switch(MSDReadState)
00140C  20A784     MOV #0xA78, W4
00140E  784214     MOV.B [W4], W4
001410  FB8204     ZE W4, W4
001412  200005     MOV #0x0, W5
001414  520FE4     SUB W4, #0x4, [W15]
001416  5A8FE0     SUBB W5, #0x0, [W15]
001418  3E0081     BRA GTU, 0x151C
00141A  016004     BRA W4
00141C  370004     BRA 0x1426
00141E  370018     BRA 0x1450
001420  370020     BRA 0x1462
001422  370053     BRA 0x14CA
001424  37005C     BRA 0x14DE
1049:                  {
1050:                      case MSD_READ10_WAIT:
1051:                          //Extract the LBA from the CBW.  Note: Also need to perform endian 
1052:                          //swap, since the multi-byte CBW fields are stored big endian, but 
1053:                          //the Microchip C compilers are little endian.
1054:                          LBA.v[3]=gblCBW.CBWCB[2];
001426  BFCA8D     MOV.B 0xA8D, WREG
001428  B7EAC3     MOV.B WREG, 0xAC3
1055:                          LBA.v[2]=gblCBW.CBWCB[3];
00142A  BFCA8E     MOV.B 0xA8E, WREG
00142C  B7EAC2     MOV.B WREG, 0xAC2
1056:                          LBA.v[1]=gblCBW.CBWCB[4];
00142E  BFCA8F     MOV.B 0xA8F, WREG
001430  B7EAC1     MOV.B WREG, 0xAC1
1057:                          LBA.v[0]=gblCBW.CBWCB[5];
001432  BFCA90     MOV.B 0xA90, WREG
001434  B7EAC0     MOV.B WREG, LBA
1058:              
1059:                          TransferLength.byte.HB = gblCBW.CBWCB[7];   //MSB of Transfer Length (in number of blocks, not bytes)
001436  BFCA92     MOV.B 0xA92, WREG
001438  B7EAC5     MOV.B WREG, 0xAC5
1060:                          TransferLength.byte.LB = gblCBW.CBWCB[8];   //LSB of Transfer Length (in number of blocks, not bytes)
00143A  BFCA93     MOV.B 0xA93, WREG
00143C  B7EAC4     MOV.B WREG, TransferLength
1061:              
1062:                          //Check for possible error cases before proceeding
1063:                          if(MSDCheckForErrorCases(TransferLength.Val * (uint32_t)FILEIO_CONFIG_MEDIA_SECTOR_SIZE) != MSD_ERROR_CASE_NO_ERROR)
00143E  805624     MOV TransferLength, W4
001440  200005     MOV #0x0, W5
001442  DD2849     SL W5, #9, W0
001444  DE20C7     LSR W4, #7, W1
001446  700081     IOR W0, W1, W1
001448  DD2049     SL W4, #9, W0
00144A  07FECA     RCALL MSDCheckForErrorCases
00144C  504FE0     SUB.B W0, #0x0, [W15]
00144E  3A006C     BRA NZ, 0x1528
1064:                          {
1065:                              break;
1066:                          }    
1067:              
1068:                          MSDReadState = MSD_READ10_BLOCK;
1069:                          //Fall through to MSD_READ_BLOCK
1070:                          
1071:                      case MSD_READ10_BLOCK:
1072:                          if(TransferLength.Val == 0)
001450  805624     MOV TransferLength, W4
001452  520FE0     SUB W4, #0x0, [W15]
001454  3A0002     BRA NZ, 0x145A
1073:                          {
1074:                              MSDReadState = MSD_READ10_WAIT;
001456  EF6A78     CLR.B MSDReadState
1075:                              break;
001458  370067     BRA 0x1528
1076:                          }
1077:                          
1078:                          TransferLength.Val--;					// we have read 1 LBA
00145A  E90204     DEC W4, W4
00145C  885624     MOV W4, TransferLength
1079:                          MSDReadState = MSD_READ10_SECTOR;
00145E  B3C020     MOV #0x2, W0
001460  B7EA78     MOV.B WREG, MSDReadState
1080:                          //Fall through to MSD_READ10_SECTOR
1081:                          
1082:                      case MSD_READ10_SECTOR:
1083:                          //if the old data isn't completely sent yet
1084:                          if(USBHandleBusy(USBMSDInHandle) != 0)
001462  805394     MOV USBMSDInHandle, W4
001464  520FE0     SUB W4, #0x0, [W15]
001466  320003     BRA Z, 0x146E
001468  EB0280     CLR W5
00146A  128F94     SUBR W5, [W4], [W15]
00146C  35005D     BRA LT, 0x1528
1085:                          {
1086:                              break;
1087:                          }
1088:                          
1089:                          //Try to read a sector worth of data from the media, but check for
1090:                          //possible errors.
1091:                          if(LUNSectorRead(LBA.Val, (uint8_t*)&msd_buffer[0]) != true)
00146E  2084C1     MOV #0x84C, W1
001470  805602     MOV LBA, W2
001472  805613     MOV 0xAC2, W3
001474  805970     MOV 0xB2E, W0
001476  805944     MOV 0xB28, W4
001478  010004     CALL W4
00147A  504FE1     SUB.B W0, #0x1, [W15]
00147C  320019     BRA Z, 0x14B0
1092:                          {
1093:                              if(MSDRetryAttempt < MSD_FAILED_READ_MAX_ATTEMPTS)
00147E  20A7A4     MOV #0xA7A, W4
001480  784214     MOV.B [W4], W4
001482  B3C635     MOV #0x63, W5
001484  524F85     SUB.B W4, W5, [W15]
001486  3E0004     BRA GTU, 0x1490
1094:                              {
1095:                                  MSDRetryAttempt++;
001488  E84204     INC.B W4, W4
00148A  784004     MOV.B W4, W0
00148C  B7EA7A     MOV.B WREG, MSDRetryAttempt
1096:                                  break;
00148E  37004C     BRA 0x1528
1097:                              }
1098:                              else
1099:                              {
1100:                                  //Too many consecutive failed reads have occurred.  Need to
1101:                                  //give up and abandon the sector read attempt; something must
1102:                                  //be wrong and we don't want to get stuck in an infinite loop.
1103:                                  //Need to indicate to the host that a device error occurred.
1104:                                  //However, we can't send the CSW immediately, since the host
1105:                                  //still expects to receive sector read data on the IN endpoint
1106:                                  //first.  Therefore, we still send dummy bytes, before
1107:                                  //we send the CSW with the failed status in it.
1108:                                  msd_csw.bCSWStatus=0x02;		// Indicate phase error 0x02
001490  B3C020     MOV #0x2, W0
001492  B7E84A     MOV.B WREG, 0x84A
1109:              													// (option #1 from BOT section 6.6.2)
1110:                                  //Set error status sense keys, so the host can check them later
1111:                                  //to determine how to proceed.
1112:                                  gblSenseData[LUN_INDEX].SenseKey=S_MEDIUM_ERROR;
001494  A80A9F     BSET 0xA9F, #0
001496  A82A9F     BSET 0xA9F, #1
001498  A94A9F     BCLR 0xA9F, #2
00149A  A96A9F     BCLR 0xA9F, #3
1113:                                  gblSenseData[LUN_INDEX].ASC=ASC_NO_ADDITIONAL_SENSE_INFORMATION;
00149C  EB4400     CLR.B W8
00149E  784008     MOV.B W8, W0
0014A0  B7EAA9     MOV.B WREG, 0xAA9
0014A2  B7EAAA     MOV.B WREG, 0xAAA
1114:                                  gblSenseData[LUN_INDEX].ASCQ=ASCQ_NO_ADDITIONAL_SENSE_INFORMATION;
1115:                                  USBStallEndpoint(MSD_DATA_IN_EP, IN_TO_HOST);
0014A4  B3C011     MOV #0x1, W1
0014A6  784001     MOV.B W1, W0
0014A8  07FAE1     RCALL USBStallEndpoint
1116:                                  MSDReadState = MSD_READ10_WAIT;
0014AA  784008     MOV.B W8, W0
0014AC  B7EA78     MOV.B WREG, MSDReadState
1117:                                  break;
0014AE  37003C     BRA 0x1528
1118:                              }
1119:                          }//else we successfully read a sector worth of data from our media
1120:              
1121:                          LBA.Val++;
0014B0  805604     MOV LBA, W4
0014B2  805615     MOV 0xAC2, W5
0014B4  420261     ADD W4, #0x1, W4
0014B6  4A82E0     ADDC W5, #0x0, W5
0014B8  885604     MOV W4, LBA
0014BA  885615     MOV W5, 0xAC2
1122:                          msd_csw.dCSWDataResidue=BLOCKLEN_512;//in order to send the
0014BC  202005     MOV #0x200, W5
0014BE  884235     MOV W5, 0x846
0014C0  EF2848     CLR 0x848
1123:                          //512 bytes of data read
1124:              
1125:                          ptrNextData=(uint8_t *)&msd_buffer[0];
0014C2  2084C4     MOV #0x84C, W4
0014C4  885584     MOV W4, ptrNextData
1126:                          
1127:                          MSDReadState = MSD_READ10_TX_SECTOR;
0014C6  B3C030     MOV #0x3, W0
0014C8  B7EA78     MOV.B WREG, MSDReadState
1128:                          //Fall through to MSD_READ10_TX_SECTOR
1129:                          
1130:                      case MSD_READ10_TX_SECTOR:
1131:                          if(msd_csw.dCSWDataResidue == 0)
0014CA  804234     MOV 0x846, W4
0014CC  804245     MOV 0x848, W5
0014CE  520FE0     SUB W4, #0x0, [W15]
0014D0  5A8FE0     SUBB W5, #0x0, [W15]
0014D2  3A0003     BRA NZ, 0x14DA
1132:                          {
1133:                              MSDReadState = MSD_READ10_BLOCK;
0014D4  B3C010     MOV #0x1, W0
0014D6  B7EA78     MOV.B WREG, MSDReadState
1134:                              break;
0014D8  370027     BRA 0x1528
1135:                          }
1136:                          
1137:                          MSDReadState = MSD_READ10_TX_PACKET;
0014DA  B3C040     MOV #0x4, W0
0014DC  B7EA78     MOV.B WREG, MSDReadState
1138:                          //Fall through to MSD_READ10_TX_PACKET
1139:                          
1140:                      case MSD_READ10_TX_PACKET:
1141:                          /* Write next chunk of data to EP Buffer and send */
1142:                          
1143:                          //Make sure the endpoint is available before using it.
1144:                          if(USBHandleBusy(USBMSDInHandle))
0014DE  805394     MOV USBMSDInHandle, W4
0014E0  520FE0     SUB W4, #0x0, [W15]
0014E2  320003     BRA Z, 0x14EA
0014E4  EB0280     CLR W5
0014E6  128F94     SUBR W5, [W4], [W15]
0014E8  35001F     BRA LT, 0x1528
1145:                          {
1146:                              break;
1147:                          }
1148:                          
1149:                          //Prepare the USB module to send an IN transaction worth of data to the host.
1150:                          USBMSDInHandle = USBTxOnePacket(MSD_DATA_IN_EP,ptrNextData,MSD_IN_EP_SIZE);
0014EA  B3C403     MOV #0x40, W3
0014EC  805582     MOV ptrNextData, W2
0014EE  B3C011     MOV #0x1, W1
0014F0  784001     MOV.B W1, W0
0014F2  07FA92     RCALL USBTransferOnePacket
0014F4  885390     MOV W0, USBMSDInHandle
1151:                          
1152:                          MSDReadState = MSD_READ10_TX_SECTOR;
0014F6  B3C030     MOV #0x3, W0
0014F8  B7EA78     MOV.B WREG, MSDReadState
1153:              
1154:                          gblCBW.dCBWDataTransferLength-=	MSD_IN_EP_SIZE;
0014FA  2FFC04     MOV #0xFFC0, W4
0014FC  2FFFF5     MOV #0xFFFF, W5
0014FE  805426     MOV 0xA84, W6
001500  805437     MOV 0xA86, W7
001502  420306     ADD W4, W6, W6
001504  4A8387     ADDC W5, W7, W7
001506  885426     MOV W6, 0xA84
001508  885437     MOV W7, 0xA86
1155:                          msd_csw.dCSWDataResidue-=MSD_IN_EP_SIZE;
00150A  804236     MOV 0x846, W6
00150C  804247     MOV 0x848, W7
00150E  420306     ADD W4, W6, W6
001510  4A8387     ADDC W5, W7, W7
001512  884236     MOV W6, 0x846
001514  884247     MOV W7, 0x848
1156:                          ptrNextData+=MSD_IN_EP_SIZE;
001516  200400     MOV #0x40, W0
001518  B42AB0     ADD ptrNextData
1157:                          break;
00151A  370006     BRA 0x1528
1158:                      
1159:                      default:
1160:                          //Illegal condition, should never occur.  In the event that it ever
1161:                          //did occur anyway, try to notify the host of the error.
1162:                          msd_csw.bCSWStatus=0x02;  //indicate "Phase Error"
00151C  B3C020     MOV #0x2, W0
00151E  B7E84A     MOV.B WREG, 0x84A
1163:                          USBStallEndpoint(MSD_DATA_IN_EP, IN_TO_HOST);
001520  B3C011     MOV #0x1, W1
001522  784001     MOV.B W1, W0
001524  07FAA3     RCALL USBStallEndpoint
1164:                          //Advance state machine
1165:                          MSDReadState = MSD_READ10_WAIT;
001526  EF6A78     CLR.B MSDReadState
1166:                          break;
1167:                  }//switch(MSDReadState)
1168:                  
1169:                  return MSDReadState;
1170:              }
001528  BFCA78     MOV.B MSDReadState, WREG
00152A  78044F     MOV [--W15], W8
00152C  060000     RETURN
1171:              
1172:              
1173:              /******************************************************************************
1174:               	Function:
1175:               		uint8_t MSDWriteHandler(void)
1176:               		
1177:               	Description:
1178:               		This funtion processes a write command received through 
1179:               		the MSD class driver
1180:               		
1181:               	PreCondition:
1182:               		None
1183:               		
1184:               	Parameters:
1185:               		None
1186:               		
1187:               	Return Values:
1188:               		uint8_t - the current state of the MSDWriteHandler state
1189:               		machine.  The valid values are defined in MSD.h under the 
1190:               		MSDWriteHandler state machine declaration section
1191:               		
1192:               	Remarks:
1193:               		None
1194:               
1195:               *****************************************************************************/
1196:              uint8_t MSDWriteHandler(void)
1197:              {
00128A  781F88     MOV W8, [W15++]
1198:                  switch(MSDWriteState)
00128C  20A794     MOV #0xA79, W4
00128E  784214     MOV.B [W4], W4
001290  FB8204     ZE W4, W4
001292  200005     MOV #0x0, W5
001294  520FE4     SUB W4, #0x4, [W15]
001296  5A8FE0     SUBB W5, #0x0, [W15]
001298  3E00AF     BRA GTU, 0x13F8
00129A  016004     BRA W4
00129C  370004     BRA 0x12A6
00129E  370031     BRA 0x1302
0012A0  37007E     BRA 0x139E
0012A2  37003B     BRA 0x131A
0012A4  37005F     BRA 0x1364
1199:                  {
1200:                      case MSD_WRITE10_WAIT:
1201:                          /* Read the LBA, TransferLength fields from Command Block
1202:                          NOTE: CB is Big-Endian */
1203:                          LBA.v[3]=gblCBW.CBWCB[2];
0012A6  BFCA8D     MOV.B 0xA8D, WREG
0012A8  B7EAC3     MOV.B WREG, 0xAC3
1204:                          LBA.v[2]=gblCBW.CBWCB[3];
0012AA  BFCA8E     MOV.B 0xA8E, WREG
0012AC  B7EAC2     MOV.B WREG, 0xAC2
1205:                          LBA.v[1]=gblCBW.CBWCB[4];
0012AE  BFCA8F     MOV.B 0xA8F, WREG
0012B0  B7EAC1     MOV.B WREG, 0xAC1
1206:                          LBA.v[0]=gblCBW.CBWCB[5];
0012B2  BFCA90     MOV.B 0xA90, WREG
0012B4  B7EAC0     MOV.B WREG, LBA
1207:                          TransferLength.v[1]=gblCBW.CBWCB[7];
0012B6  BFCA92     MOV.B 0xA92, WREG
0012B8  B7EAC5     MOV.B WREG, 0xAC5
1208:                          TransferLength.v[0]=gblCBW.CBWCB[8];
0012BA  BFCA93     MOV.B 0xA93, WREG
0012BC  B7EAC4     MOV.B WREG, TransferLength
1209:              
1210:                          //Do some error case checking.
1211:                          if(MSDCheckForErrorCases(TransferLength.Val * (uint32_t)FILEIO_CONFIG_MEDIA_SECTOR_SIZE) != MSD_ERROR_CASE_NO_ERROR)
0012BE  805624     MOV TransferLength, W4
0012C0  200005     MOV #0x0, W5
0012C2  DD2849     SL W5, #9, W0
0012C4  DE20C7     LSR W4, #7, W1
0012C6  700081     IOR W0, W1, W1
0012C8  DD2049     SL W4, #9, W0
0012CA  07FF8A     RCALL MSDCheckForErrorCases
0012CC  504FE0     SUB.B W0, #0x0, [W15]
0012CE  3A009A     BRA NZ, 0x1404
1212:                          {
1213:                              //An error was detected.  The MSDCheckForErrorCases() function will
1214:                              //have taken care of setting the proper states to report the error to the host.
1215:                              break;
1216:                          }
1217:                          
1218:                          //Check if the media is write protected before deciding what
1219:                          //to do with the data.
1220:                          if(LUNWriteProtectState())
0012D0  805970     MOV 0xB2E, W0
0012D2  805954     MOV 0xB2A, W4
0012D4  010004     CALL W4
0012D6  504FE0     SUB.B W0, #0x0, [W15]
0012D8  320012     BRA Z, 0x12FE
1221:                          {
1222:                              //The media appears to be write protected.
1223:                              //Let host know error occurred.  The bCSWStatus flag is also used by
1224:                              //the write handler, to know not to even attempt the write sequence.
1225:                              msd_csw.bCSWStatus = MSD_CSW_COMMAND_FAILED;
0012DA  B3C015     MOV #0x1, W5
0012DC  784005     MOV.B W5, W0
0012DE  B7E84A     MOV.B WREG, 0x84A
1226:              
1227:                              //Set sense keys so the host knows what caused the error.
1228:                              gblSenseData[LUN_INDEX].SenseKey=S_DATA_PROTECT;
0012E0  A80A9F     BSET 0xA9F, #0
0012E2  A82A9F     BSET 0xA9F, #1
0012E4  A84A9F     BSET 0xA9F, #2
0012E6  A96A9F     BCLR 0xA9F, #3
1229:                              gblSenseData[LUN_INDEX].ASC=ASC_WRITE_PROTECTED;
0012E8  B3C270     MOV #0x27, W0
0012EA  B7EAA9     MOV.B WREG, 0xAA9
1230:                              gblSenseData[LUN_INDEX].ASCQ=ASCQ_WRITE_PROTECTED;
0012EC  EB4400     CLR.B W8
0012EE  784008     MOV.B W8, W0
0012F0  B7EAAA     MOV.B WREG, 0xAAA
1231:              
1232:                              //Stall the OUT endpoint, so as to promptly inform the host
1233:                              //that the data cannot be accepted, due to write protected media.
1234:                              USBStallEndpoint(MSD_DATA_OUT_EP, OUT_FROM_HOST);
0012F2  784088     MOV.B W8, W1
0012F4  784005     MOV.B W5, W0
0012F6  07FBBA     RCALL USBStallEndpoint
1235:                              MSDWriteState = MSD_WRITE10_WAIT;
0012F8  784008     MOV.B W8, W0
0012FA  B7EA79     MOV.B WREG, MSDWriteState
1236:                              return MSDWriteState;
0012FC  370084     BRA 0x1406
1237:                          }
1238:                      	
1239:                          MSD_State = MSD_WRITE10_BLOCK;
0012FE  B3C010     MOV #0x1, W0
001300  B7EA76     MOV.B WREG, MSD_State
1240:                          //Fall through to MSD_WRITE10_BLOCK
1241:                          
1242:                      case MSD_WRITE10_BLOCK:
1243:                          if(TransferLength.Val == 0)
001302  805624     MOV TransferLength, W4
001304  520FE0     SUB W4, #0x0, [W15]
001306  3A0002     BRA NZ, 0x130C
1244:                          {
1245:                              MSDWriteState = MSD_WRITE10_WAIT;
001308  EF6A79     CLR.B MSDWriteState
1246:                              break;
00130A  37007C     BRA 0x1404
1247:                          }
1248:                          
1249:                          MSDWriteState = MSD_WRITE10_RX_SECTOR;
00130C  B3C030     MOV #0x3, W0
00130E  B7EA79     MOV.B WREG, MSDWriteState
1250:                          ptrNextData=(uint8_t *)&msd_buffer[0];
001310  2084C4     MOV #0x84C, W4
001312  885584     MOV W4, ptrNextData
1251:                            
1252:                          msd_csw.dCSWDataResidue=BLOCKLEN_512;
001314  202004     MOV #0x200, W4
001316  884234     MOV W4, 0x846
001318  EF2848     CLR 0x848
1253:                      	
1254:                          //Fall through to MSD_WRITE10_RX_SECTOR
1255:                      case MSD_WRITE10_RX_SECTOR:
1256:                      {
1257:                          /* Read 512B into msd_buffer*/
1258:                          if(msd_csw.dCSWDataResidue>0)
00131A  804234     MOV 0x846, W4
00131C  804245     MOV 0x848, W5
00131E  520FE0     SUB W4, #0x0, [W15]
001320  5A8FE0     SUBB W5, #0x0, [W15]
001322  32000F     BRA Z, 0x1342
1259:                          {
1260:                              if(USBHandleBusy(USBMSDOutHandle) == true)
001324  805384     MOV USBMSDOutHandle, W4
001326  520FE0     SUB W4, #0x0, [W15]
001328  320003     BRA Z, 0x1330
00132A  EB0280     CLR W5
00132C  128F94     SUBR W5, [W4], [W15]
00132E  35006A     BRA LT, 0x1404
1261:                              {
1262:                                  break;
1263:                              }
1264:              
1265:                              USBMSDOutHandle = USBRxOnePacket(MSD_DATA_OUT_EP,ptrNextData,MSD_OUT_EP_SIZE);
001330  B3C403     MOV #0x40, W3
001332  805582     MOV ptrNextData, W2
001334  EB4080     CLR.B W1
001336  B3C010     MOV #0x1, W0
001338  07FB6F     RCALL USBTransferOnePacket
00133A  885380     MOV W0, USBMSDOutHandle
1266:                              MSDWriteState = MSD_WRITE10_RX_PACKET;
00133C  B3C040     MOV #0x4, W0
00133E  B7EA79     MOV.B WREG, MSDWriteState
001340  370011     BRA 0x1364
1267:                              //Fall through to MSD_WRITE10_RX_PACKET
1268:                    	    }
1269:                    	    else
1270:                    	    {
1271:                              //We finished receiving a sector worth of data from the host.
1272:                              //Check if the media is write protected before deciding what
1273:                              //to do with the data.
1274:                              if(LUNWriteProtectState())
001342  805970     MOV 0xB2E, W0
001344  805954     MOV 0xB2A, W4
001346  010004     CALL W4
001348  504FE0     SUB.B W0, #0x0, [W15]
00134A  320009     BRA Z, 0x135E
1275:                              {
1276:                                  //The device appears to be write protected.
1277:                                  //Let host know error occurred.  The bCSWStatus flag is also used by
1278:                                  //the write handler, to know not to even attempt the write sequence.
1279:                                  msd_csw.bCSWStatus=0x01;
00134C  B3C010     MOV #0x1, W0
00134E  B7E84A     MOV.B WREG, 0x84A
1280:              
1281:                                  //Set sense keys so the host knows what caused the error.
1282:                                  gblSenseData[LUN_INDEX].SenseKey=S_NOT_READY;
001350  A90A9F     BCLR 0xA9F, #0
001352  A82A9F     BSET 0xA9F, #1
001354  A94A9F     BCLR 0xA9F, #2
001356  A96A9F     BCLR 0xA9F, #3
1283:                                  gblSenseData[LUN_INDEX].ASC=ASC_WRITE_PROTECTED;
001358  B3C270     MOV #0x27, W0
00135A  B7EAA9     MOV.B WREG, 0xAA9
1284:                                  gblSenseData[LUN_INDEX].ASCQ=ASCQ_WRITE_PROTECTED;
00135C  EF6AAA     CLR.B 0xAAA
1285:                              }
1286:              
1287:                              MSDWriteState = MSD_WRITE10_SECTOR;
00135E  B3C020     MOV #0x2, W0
001360  B7EA79     MOV.B WREG, MSDWriteState
1288:                              break;
001362  370050     BRA 0x1404
1289:                          }
1290:                      }
1291:                      //Fall through to MSD_WRITE10_RX_PACKET
1292:                      case MSD_WRITE10_RX_PACKET:
1293:                          if(USBHandleBusy(USBMSDOutHandle) == true)
001364  805384     MOV USBMSDOutHandle, W4
001366  520FE0     SUB W4, #0x0, [W15]
001368  320003     BRA Z, 0x1370
00136A  EB0280     CLR W5
00136C  128F94     SUBR W5, [W4], [W15]
00136E  35004A     BRA LT, 0x1404
1294:                          {
1295:                              break;
1296:                          }
1297:                          
1298:                          gblCBW.dCBWDataTransferLength-=USBHandleGetLength(USBMSDOutHandle);		// 64B read
001370  784314     MOV.B [W4], W6
001372  FB8306     ZE W6, W6
001374  200007     MOV #0x0, W7
001376  805420     MOV 0xA84, W0
001378  805431     MOV 0xA86, W1
00137A  500306     SUB W0, W6, W6
00137C  588387     SUBB W1, W7, W7
00137E  885426     MOV W6, 0xA84
001380  885437     MOV W7, 0xA86
1299:                          msd_csw.dCSWDataResidue-=USBHandleGetLength(USBMSDOutHandle);
001382  804236     MOV 0x846, W6
001384  804247     MOV 0x848, W7
001386  784214     MOV.B [W4], W4
001388  FB8204     ZE W4, W4
00138A  200005     MOV #0x0, W5
00138C  530204     SUB W6, W4, W4
00138E  5B8285     SUBB W7, W5, W5
001390  884234     MOV W4, 0x846
001392  884245     MOV W5, 0x848
1300:                          ptrNextData += MSD_OUT_EP_SIZE;
001394  200400     MOV #0x40, W0
001396  B42AB0     ADD ptrNextData
1301:                          
1302:                          MSDWriteState = MSD_WRITE10_RX_SECTOR;
001398  B3C030     MOV #0x3, W0
00139A  B7EA79     MOV.B WREG, MSDWriteState
1303:                          break;
00139C  370033     BRA 0x1404
1304:                          
1305:                      case MSD_WRITE10_SECTOR:
1306:                      {
1307:                          //Make sure that no error has been detected, before performing the write
1308:                          //operation.  If there was an error, skip the write operation, but allow
1309:                          //the TransferLength to continue decrementing, so that we can eventually
1310:                          //receive all OUT bytes that the host is planning on sending us.  Only
1311:                          //after that is complete will the host send the IN token for the CSW packet,
1312:                          //which will contain the bCSWStatus letting it know an error occurred.
1313:                          if(msd_csw.bCSWStatus == 0x00)
00139E  2084A4     MOV #0x84A, W4
0013A0  784214     MOV.B [W4], W4
0013A2  524FE0     SUB.B W4, #0x0, [W15]
0013A4  3A001F     BRA NZ, 0x13E4
1314:                          {
1315:                              if(LUNSectorWrite(LBA.Val, (uint8_t*)&msd_buffer[0], (LBA.Val==0)?true:false) != true)
0013A6  805602     MOV LBA, W2
0013A8  805613     MOV 0xAC2, W3
0013AA  710203     IOR W2, W3, W4
0013AC  A7F004     BTSC W4, #15
0013AE  EA0204     NEG W4, W4
0013B0  E90204     DEC W4, W4
0013B2  DE224F     LSR W4, #15, W4
0013B4  2084C1     MOV #0x84C, W1
0013B6  805970     MOV 0xB2E, W0
0013B8  805965     MOV 0xB2C, W5
0013BA  010005     CALL W5
0013BC  504FE1     SUB.B W0, #0x1, [W15]
0013BE  320012     BRA Z, 0x13E4
1316:                              {
1317:                                  //The write operation failed for some reason.  Keep track of retry
1318:                                  //attempts and abort if repeated write attempts also fail.
1319:                                  if(MSDRetryAttempt < MSD_FAILED_WRITE_MAX_ATTEMPTS)
0013C0  20A7A4     MOV #0xA7A, W4
0013C2  784214     MOV.B [W4], W4
0013C4  B3C635     MOV #0x63, W5
0013C6  524F85     SUB.B W4, W5, [W15]
0013C8  3E0004     BRA GTU, 0x13D2
1320:                                  {
1321:                                      MSDRetryAttempt++;
0013CA  E84204     INC.B W4, W4
0013CC  784004     MOV.B W4, W0
0013CE  B7EA7A     MOV.B WREG, MSDRetryAttempt
1322:                                      break;
0013D0  370019     BRA 0x1404
1323:                                  }
1324:                                  else
1325:                                  {
1326:                                      //Too many consecutive failed write attempts have occurred.
1327:                                      //Need to give up and abandon the write attempt.
1328:                                      msd_csw.bCSWStatus = MSD_CSW_COMMAND_FAILED; //Indicate error during CSW phase
0013D2  B3C010     MOV #0x1, W0
0013D4  B7E84A     MOV.B WREG, 0x84A
1329:                                      //Set error status sense keys, so the host can check them later
1330:                                      //to determine how to proceed.
1331:                                      gblSenseData[LUN_INDEX].SenseKey=S_MEDIUM_ERROR;
0013D6  A80A9F     BSET 0xA9F, #0
0013D8  A82A9F     BSET 0xA9F, #1
0013DA  A94A9F     BCLR 0xA9F, #2
0013DC  A96A9F     BCLR 0xA9F, #3
1332:                                      gblSenseData[LUN_INDEX].ASC=ASC_NO_ADDITIONAL_SENSE_INFORMATION;
0013DE  B3C000     MOV #0x0, W0
0013E0  B7EAA9     MOV.B WREG, 0xAA9
0013E2  B7EAAA     MOV.B WREG, 0xAAA
1333:                                      gblSenseData[LUN_INDEX].ASCQ=ASCQ_NO_ADDITIONAL_SENSE_INFORMATION;
1334:                                  }
1335:                              }
1336:                          }
1337:              
1338:                          //One LBA is written (unless an error occurred).  Advance state
1339:                          //variables so we can eventually finish handling the CBW request.
1340:                          LBA.Val++;
0013E4  805604     MOV LBA, W4
0013E6  805615     MOV 0xAC2, W5
0013E8  420261     ADD W4, #0x1, W4
0013EA  4A82E0     ADDC W5, #0x0, W5
0013EC  885604     MOV W4, LBA
0013EE  885615     MOV W5, 0xAC2
1341:                          TransferLength.Val--;
0013F0  ED2AC4     DEC TransferLength
1342:                          MSDWriteState = MSD_WRITE10_BLOCK;
0013F2  B3C010     MOV #0x1, W0
0013F4  B7EA79     MOV.B WREG, MSDWriteState
1343:                          break;
0013F6  370006     BRA 0x1404
1344:                      } 
1345:                      
1346:                      default:
1347:                          //Illegal condition which should not occur.  If for some reason it
1348:                          //does, try to let the host know know an error has occurred.
1349:                          msd_csw.bCSWStatus=0x02;    //Phase Error
0013F8  B3C020     MOV #0x2, W0
0013FA  B7E84A     MOV.B WREG, 0x84A
1350:                          USBStallEndpoint(MSD_DATA_OUT_EP, OUT_FROM_HOST);
0013FC  EB4080     CLR.B W1
0013FE  B3C010     MOV #0x1, W0
001400  07FB35     RCALL USBStallEndpoint
1351:                          MSDWriteState = MSD_WRITE10_WAIT;
001402  EF6A79     CLR.B MSDWriteState
1352:                          break;
1353:                  }
1354:                  
1355:                  return MSDWriteState;
001404  BFCA79     MOV.B MSDWriteState, WREG
1356:              }
001406  78044F     MOV [--W15], W8
001408  060000     RETURN
1357:              
1358:              
1359:              
1360:              /******************************************************************************
1361:               	Function:
1362:               		void ResetSenseData(void)
1363:               		
1364:               	Description:
1365:               		This routine resets the Sense Data, initializing the
1366:               		structure RequestSenseResponse gblSenseData.
1367:               		
1368:               	PreCondition:
1369:               		None 
1370:               		
1371:               	Parameters:
1372:               		None
1373:               		
1374:               	Return Values:
1375:               		None
1376:               		
1377:               	Remarks:
1378:               		None
1379:               			
1380:                *****************************************************************************/
1381:              void ResetSenseData(void) 
1382:              {
1383:                  gblSenseData[LUN_INDEX].ResponseCode=S_CURRENT;
001080  B3C804     MOV #0x80, W4
001082  20A9D5     MOV #0xA9D, W5
001084  784295     MOV.B [W5], W5
001086  62C204     AND.B W5, W4, W4
001088  B34704     IOR.B #0x70, W4
00108A  784004     MOV.B W4, W0
00108C  B7EA9D     MOV.B WREG, gblSenseData
1384:                  gblSenseData[LUN_INDEX].VALID=0;			// no data in the information field
00108E  A9EA9D     BCLR gblSenseData, #7
1385:                  gblSenseData[LUN_INDEX].Obsolete=0x0;
001090  EB4200     CLR.B W4
001092  784004     MOV.B W4, W0
001094  B7EA9E     MOV.B WREG, 0xA9E
1386:                  gblSenseData[LUN_INDEX].SenseKey=S_NO_SENSE;
001096  A90A9F     BCLR 0xA9F, #0
001098  A92A9F     BCLR 0xA9F, #1
00109A  A94A9F     BCLR 0xA9F, #2
00109C  A96A9F     BCLR 0xA9F, #3
1387:                  //gblSenseData.Resv;
1388:                  gblSenseData[LUN_INDEX].ILI=0;
00109E  A9AA9F     BCLR 0xA9F, #5
1389:                  gblSenseData[LUN_INDEX].EOM=0;
0010A0  A9CA9F     BCLR 0xA9F, #6
1390:                  gblSenseData[LUN_INDEX].FILEMARK=0;
0010A2  A9EA9F     BCLR 0xA9F, #7
1391:                  gblSenseData[LUN_INDEX].InformationB0=0x00;
0010A4  B7EAA0     MOV.B WREG, 0xAA0
0010A6  B7EAA1     MOV.B WREG, 0xAA1
0010A8  B7EAA2     MOV.B WREG, 0xAA2
0010AA  B7EAA3     MOV.B WREG, 0xAA3
1392:                  gblSenseData[LUN_INDEX].InformationB1=0x00;
1393:                  gblSenseData[LUN_INDEX].InformationB2=0x00;
1394:                  gblSenseData[LUN_INDEX].InformationB3=0x00;
1395:                  gblSenseData[LUN_INDEX].AddSenseLen=0x0a;	// n-7 (n=17 (0..17))
0010AC  B3C0A0     MOV #0xA, W0
0010AE  B7EAA4     MOV.B WREG, 0xAA4
1396:                  gblSenseData[LUN_INDEX].CmdSpecificInfo.Val=0x0;
0010B0  784004     MOV.B W4, W0
0010B2  B7EAA5     MOV.B WREG, 0xAA5
0010B4  B7EAA6     MOV.B WREG, 0xAA6
0010B6  B7EAA7     MOV.B WREG, 0xAA7
0010B8  B7EAA8     MOV.B WREG, 0xAA8
0010BA  B7EAA9     MOV.B WREG, 0xAA9
1397:                  gblSenseData[LUN_INDEX].ASC=0x0;
1398:                  gblSenseData[LUN_INDEX].ASCQ=0x0;
0010BC  B7EAAA     MOV.B WREG, 0xAAA
0010BE  B7EAAB     MOV.B WREG, 0xAAB
0010C0  B7EAAC     MOV.B WREG, 0xAAC
0010C2  B7EAAD     MOV.B WREG, 0xAAD
0010C4  B7EAAE     MOV.B WREG, 0xAAE
1399:                  gblSenseData[LUN_INDEX].FRUC=0x0;
1400:                  gblSenseData[LUN_INDEX].SenseKeySpecific[0]=0x0;
1401:                  gblSenseData[LUN_INDEX].SenseKeySpecific[1]=0x0;
1402:                  gblSenseData[LUN_INDEX].SenseKeySpecific[2]=0x0;
1403:              }
0010C6  060000     RETURN
1404:              
1405:              
1406:              
1407:              /******************************************************************************
1408:               	Function:
1409:               		uint8_t MSDCheckForErrorCases(uint32_t DeviceBytes)
1410:               		
1411:               	Description:
1412:               	   This function can be called to check for various error cases, primarily 
1413:               	   the "Thirteen Cases" errors described in the MSD BOT v1.0 specs.  If an
1414:               	   error is detected, the function internally calls the MSDErrorHandler()
1415:               	   handler function, to take care of appropriately responding to the host, 
1416:               	   based on the error condition.
1417:               	PreCondition:
1418:               	    None
1419:               	     		
1420:               	Parameters:
1421:               		uint32_t DeviceBytes - Input: This is the total number of bytes the MSD 
1422:               		            device firmware is expecting in the MSD transfer.  
1423:               	Return Values:
1424:               		uint8_t - Returns a byte containing the error code.  The possible error
1425:               		    cases that can be detected and reported are:
1426:                          MSD_ERROR_CASE_NO_ERROR - None of the "Thirteen cases" errors were detected
1427:                          MSD_ERROR_CASE_2 	            
1428:                          MSD_ERROR_CASE_3 	            
1429:                          MSD_ERROR_CASE_4 	            
1430:                          MSD_ERROR_CASE_5 	            
1431:                          MSD_ERROR_CASE_7 	            
1432:                          MSD_ERROR_CASE_8 	            
1433:                          MSD_ERROR_CASE_9 	            
1434:                          MSD_ERROR_CASE_11               
1435:                          MSD_ERROR_CASE_10               
1436:                          MSD_ERROR_CASE_13               
1437:               		
1438:               	Remarks:
1439:               		None
1440:               			
1441:                *****************************************************************************/
1442:              uint8_t MSDCheckForErrorCases(uint32_t DeviceBytes)
0011E2  700201     IOR W0, W1, W4
0011E4  A7F004     BTSC W4, #15
0011E6  EA0204     NEG W4, W4
0011E8  E90204     DEC W4, W4
0011EA  DE22CF     LSR W4, #15, W5
001228  B3C012     MOV #0x1, W2
00122A  500F86     SUB W0, W6, [W15]
00122C  588F87     SUBB W1, W7, [W15]
00122E  390001     BRA NC, 0x1232
001230  EB4100     CLR.B W2
1443:              {
0011E0  781F88     MOV W8, [W15++]
1444:                  uint8_t MSDErrorCase;
1445:                  bool HostMoreDataThanDevice;
1446:                  bool DeviceNoData;
1447:                
1448:                  //Check if device is expecting no data (Dn)
1449:                  if(DeviceBytes == 0)
1450:                  {
1451:                      DeviceNoData = true;
1452:                  }    
1453:                  else
1454:                  {
1455:                      DeviceNoData = false;
1456:                  }     
1457:                  
1458:                  //First check for the three good/non-error cases
1459:                  
1460:                  //Check for good case: Hn = Dn (Case 1)
1461:                  if((MSDHostNoData == true) && (DeviceNoData == true))
0011EC  20AB64     MOV #0xAB6, W4
0011EE  784214     MOV.B [W4], W4
0011F0  524FE0     SUB.B W4, #0x0, [W15]
0011F2  320003     BRA Z, 0x11FA
0011F6  52CF88     SUB.B W5, W8, [W15]
0011F8  3A0045     BRA NZ, 0x1284
1462:                  {
1463:                      return MSD_ERROR_CASE_NO_ERROR;
0011F4  EB4400     CLR.B W8
1464:                  }    
1465:              
1466:                  //Check for good cases where the data sizes between host and device match
1467:                  if(gblCBW.dCBWDataTransferLength == DeviceBytes)
0011FA  805426     MOV 0xA84, W6
0011FC  805437     MOV 0xA86, W7
0011FE  530F80     SUB W6, W0, [W15]
001200  5B8F81     SUBB W7, W1, [W15]
001202  3A0012     BRA NZ, 0x1228
1468:                  {
1469:                      //Check for good case: Hi = Di (Case 6)
1470:                      if(MSD_State == MSD_DATA_IN)
001204  20A762     MOV #0xA76, W2
001206  784112     MOV.B [W2], W2
001208  514FE1     SUB.B W2, #0x1, [W15]
00120A  3A0008     BRA NZ, 0x121C
1471:                      {
1472:                          //Make sure Hi = Di, instead of Hi = Do
1473:                          if(MSDCommandState != MSD_WRITE_10)
00120E  B3C2A4     MOV #0x2A, W4
001210  20A775     MOV #0xA77, W5
001212  784295     MOV.B [W5], W5
001214  52CF84     SUB.B W5, W4, [W15]
001216  3A0036     BRA NZ, 0x1284
1474:                          {
1475:                              return MSD_ERROR_CASE_NO_ERROR;
00120C  EB4400     CLR.B W8
1476:                          }    
1477:                      }
1478:                      else //if(MSD_State == MSD_DATA_OUT)  
1479:                      {
1480:                          //Check for good case: Ho = Do (Case 12)
1481:                          //Make sure Ho = Do, instead of Ho = Di
1482:                          if(MSDCommandState == MSD_WRITE_10)
00121E  B3C2A2     MOV #0x2A, W2
001220  20A773     MOV #0xA77, W3
001222  784193     MOV.B [W3], W3
001224  51CF82     SUB.B W3, W2, [W15]
001226  32002E     BRA Z, 0x1284
1483:                          {
1484:                              return MSD_ERROR_CASE_NO_ERROR;
00121C  EB4400     CLR.B W8
1485:                          }             
1486:                      }      
1487:                  }    
1488:              
1489:                  //If we get to here, this implies some kind of error is occuring.  Do some
1490:                  //checks to find out which error occurred, so we know how to handle it.
1491:              
1492:                  //Check if the host is expecting to transfer more bytes than the device. (Hx > Dx)
1493:                  if(gblCBW.dCBWDataTransferLength > DeviceBytes)
1494:                  {
1495:                      HostMoreDataThanDevice = true;
1496:                  }   
1497:                  else
1498:                  {
1499:                      HostMoreDataThanDevice = false;
1500:                  } 
1501:               
1502:                  //Check host's expected data direction
1503:              	if(MSD_State == MSD_DATA_OUT)
001232  20A766     MOV #0xA76, W6
001234  784316     MOV.B [W6], W6
001236  534FE2     SUB.B W6, #0x2, [W15]
001238  3A0013     BRA NZ, 0x1260
1504:              	{
1505:                  	//First check for Ho <> Di (Case 10)
1506:                  	if((MSDCommandState != MSD_WRITE_10) && (DeviceNoData == false))
00123A  B3C2A6     MOV #0x2A, W6
00123C  20A777     MOV #0xA77, W7
00123E  784397     MOV.B [W7], W7
001240  53CF86     SUB.B W7, W6, [W15]
001242  320003     BRA Z, 0x124A
001246  52CFE0     SUB.B W5, #0x0, [W15]
001248  32001B     BRA Z, 0x1280
1507:                  	    MSDErrorCase = MSD_ERROR_CASE_10;
001244  B3C058     MOV #0x5, W8
1508:                 	   	//Check for Hn < Do  (Case 3)
1509:                  	else if(MSDHostNoData == true)  
00124C  524FE0     SUB.B W4, #0x0, [W15]
00124E  3A0018     BRA NZ, 0x1280
1510:                  	    MSDErrorCase = MSD_ERROR_CASE_3;
00124A  B3C018     MOV #0x1, W8
1511:                  	//Check for Ho > Dn  (Case 9)
1512:                  	else if(DeviceNoData == true)
001252  52CFE0     SUB.B W5, #0x0, [W15]
001254  3A0015     BRA NZ, 0x1280
1513:                  	    MSDErrorCase = MSD_ERROR_CASE_9;
001250  B3C048     MOV #0x4, W8
1514:                  	//Check for Ho > Do  (Case 11)
1515:                  	else if(HostMoreDataThanDevice == true)
001258  514FE0     SUB.B W2, #0x0, [W15]
00125A  320012     BRA Z, 0x1280
1516:                  	    MSDErrorCase = MSD_ERROR_CASE_11;
00125C  B3C048     MOV #0x4, W8
00125E  370010     BRA 0x1280
1517:                  	//Check for Ho < Do  (Case 13)
1518:                  	else //if(gblCBW.dCBWDataTransferLength < DeviceBytes)
1519:                  	    MSDErrorCase = MSD_ERROR_CASE_13;
001256  B3C058     MOV #0x5, W8
1520:                  }    
1521:                  else //else the MSD_State must be == MSD_DATA_IN
1522:                  {
1523:                  	//First check for Hi <> Do (Case 8)
1524:                  	if(MSDCommandState == MSD_WRITE_10)
001262  B3C2A6     MOV #0x2A, W6
001264  20A777     MOV #0xA77, W7
001266  784397     MOV.B [W7], W7
001268  53CF86     SUB.B W7, W6, [W15]
00126A  32000A     BRA Z, 0x1280
1525:                  	    MSDErrorCase = MSD_ERROR_CASE_8;    	
001218  B3C038     MOV #0x3, W8
00121A  370032     BRA 0x1280
001260  B3C038     MOV #0x3, W8
1526:                  	//Check for Hn < Di  (Case 2)
1527:                  	else if(MSDHostNoData == true)  
00126E  524FE0     SUB.B W4, #0x0, [W15]
001270  3A0007     BRA NZ, 0x1280
1528:                  	    MSDErrorCase = MSD_ERROR_CASE_2;
00126C  B3C018     MOV #0x1, W8
1529:                  	//Check for Hi > Dn  (Case 4)
1530:                  	else if(DeviceNoData == true)
001274  52CFE0     SUB.B W5, #0x0, [W15]
001276  3A0004     BRA NZ, 0x1280
1531:                  	    MSDErrorCase = MSD_ERROR_CASE_4;
001272  B3C028     MOV #0x2, W8
1532:                  	//Check for Hi > Di  (Case 5)
1533:                  	else if(HostMoreDataThanDevice == true)
00127A  514FE0     SUB.B W2, #0x0, [W15]
00127C  320001     BRA Z, 0x1280
1534:                  	    MSDErrorCase = MSD_ERROR_CASE_5;
00127E  B3C028     MOV #0x2, W8
1535:                      //Check for Hi < Di  (Case 7)
1536:                  	else //if(gblCBW.dCBWDataTransferLength < DeviceBytes)
1537:                  	    MSDErrorCase = MSD_ERROR_CASE_7;
001278  B3C038     MOV #0x3, W8
1538:                  }        
1539:                  //Now call the MSDErrorHandler(), based on the error that was detected.
1540:                  MSDErrorHandler(MSDErrorCase);
001280  784008     MOV.B W8, W0
001282  07FF54     RCALL MSDErrorHandler
1541:                  return MSDErrorCase;
1542:              }    
001284  784008     MOV.B W8, W0
001286  78044F     MOV [--W15], W8
001288  060000     RETURN
1543:              
1544:              
1545:              /******************************************************************************
1546:               	Function:
1547:               		void MSDErrorHandler(uint8_t ErrorCase)
1548:               		
1549:               	Description:
1550:               	    Once an error condition has been detected, this function can be called
1551:               	    to set the proper states and perform the proper tasks needed to let the
1552:               	    host know about the error.
1553:               	PreCondition:
1554:               		Firmware should have already determined an error occurred, and it should
1555:               		know what the error code was before calling this handler.
1556:               		
1557:               	Parameters:
1558:               		uint8_t ErrorCase - Input: This is the error code that the firmware 
1559:               		                    detected.  This error code will determine how the
1560:               		                    handler will behave (ex: what status to send to host,
1561:               		                    what endpoint(s) should be stalled, etc.).
1562:               		                    The implemented error case possibilities are (suffix
1563:               		                    numbers correspond to the "Thirteen cases" numbers 
1564:               		                    described in the MSD BOT specs v1.0):
1565:               		                    
1566:                                          MSD_ERROR_CASE_2 	            
1567:                                          MSD_ERROR_CASE_3 	            
1568:                                          MSD_ERROR_CASE_4 	            
1569:                                          MSD_ERROR_CASE_5 	            
1570:                                          MSD_ERROR_CASE_7 	            
1571:                                          MSD_ERROR_CASE_8 	            
1572:                                          MSD_ERROR_CASE_9 	            
1573:                                          MSD_ERROR_CASE_11               
1574:                                          MSD_ERROR_CASE_10               
1575:                                          MSD_ERROR_CASE_13               
1576:                                          MSD_ERROR_UNSUPPORTED_COMMAND   
1577:              
1578:               	Return Values:
1579:               		None
1580:               		
1581:               	Remarks:
1582:               		None
1583:               			
1584:                *****************************************************************************/
1585:              void MSDErrorHandler(uint8_t ErrorCase)
1586:              {
00112C  781F88     MOV W8, [W15++]
00112E  784300     MOV.B W0, W6
1587:                  uint8_t OldMSD_State;
1588:                  
1589:                  //Both MSD bulk IN and OUT endpoints should not be busy when these error cases are detected
1590:                  //If for some reason this isn't true, then we should preserve the state machines states for now.
1591:                  if((USBHandleBusy(USBMSDInHandle)) || (USBHandleBusy(USBMSDOutHandle)))
001130  805394     MOV USBMSDInHandle, W4
001132  520FE0     SUB W4, #0x0, [W15]
001134  320003     BRA Z, 0x113C
001136  EB0000     CLR W0
001138  100F94     SUBR W0, [W4], [W15]
00113A  350050     BRA LT, 0x11DC
00113C  805384     MOV USBMSDOutHandle, W4
00113E  520FE0     SUB W4, #0x0, [W15]
001140  320003     BRA Z, 0x1148
001142  EB0280     CLR W5
001144  128F94     SUBR W5, [W4], [W15]
001146  35004A     BRA LT, 0x11DC
1592:                  {
1593:                  	return;	
1594:                  }
1595:              
1596:                  //Save the old state before we change it.  The old state is needed to determine
1597:                  //the proper handling behavior in the case of receiving unsupported commands.
1598:                  OldMSD_State = MSD_State;
001148  20A768     MOV #0xA76, W8
00114A  784418     MOV.B [W8], W8
1599:              
1600:                  //Reset main state machines back to idle values.
1601:                  MSDCommandState = MSD_COMMAND_WAIT;
00114C  EFEA77     SETM.B MSDCommandState
1602:                  MSDReadState = MSD_READ10_WAIT;
00114E  B3C000     MOV #0x0, W0
001150  B7EA78     MOV.B WREG, MSDReadState
001152  B7EA79     MOV.B WREG, MSDWriteState
1603:                  MSDWriteState = MSD_WRITE10_WAIT;
1604:                  //After the conventional 13 test cases failures, the host still expects a valid CSW packet
1605:                  msd_csw.dCSWDataResidue = gblCBW.dCBWDataTransferLength; //Indicate the unconsumed/unsent data
001154  805424     MOV 0xA84, W4
001156  805435     MOV 0xA86, W5
001158  884234     MOV W4, 0x846
00115A  884245     MOV W5, 0x848
1606:                  msd_csw.bCSWStatus = MSD_CSW_COMMAND_FAILED;    //Gets changed later to phase error for errors that user phase error
00115C  B3C010     MOV #0x1, W0
00115E  B7E84A     MOV.B WREG, 0x84A
1607:                  MSD_State = MSD_SEND_CSW;
001160  B3C030     MOV #0x3, W0
001162  B7EA76     MOV.B WREG, MSD_State
1608:              
1609:                  //Now do other error related handling tasks, which depend on the specific 
1610:                  //error	type that was detected.
1611:                  switch(ErrorCase)
001164  534F80     SUB.B W6, W0, [W15]
001166  320014     BRA Z, 0x1190
001168  3E0005     BRA GTU, 0x1174
00116A  534FE1     SUB.B W6, #0x1, [W15]
00116C  32000A     BRA Z, 0x1182
00116E  534FE2     SUB.B W6, #0x2, [W15]
001170  3A0035     BRA NZ, 0x11DC
001172  37000A     BRA 0x1188
001174  534FE5     SUB.B W6, #0x5, [W15]
001176  320016     BRA Z, 0x11A4
001178  390011     BRA NC, 0x119C
00117A  B3C7F4     MOV #0x7F, W4
00117C  534F84     SUB.B W6, W4, [W15]
00117E  3A002E     BRA NZ, 0x11DC
001180  370017     BRA 0x11B0
1612:                  {
1613:                      case MSD_ERROR_CASE_2://Also CASE_3
1614:                          msd_csw.bCSWStatus = MSD_CSW_PHASE_ERROR;
001182  B3C020     MOV #0x2, W0
001184  B7E84A     MOV.B WREG, 0x84A
1615:                          break;
001186  37002A     BRA 0x11DC
1616:              
1617:                      case MSD_ERROR_CASE_4://Also CASE_5
1618:                          USBStallEndpoint(MSD_DATA_IN_EP, IN_TO_HOST);	//STALL the bulk IN MSD endpoint
001188  B3C011     MOV #0x1, W1
00118A  784001     MOV.B W1, W0
00118C  07FC6F     RCALL USBStallEndpoint
1619:                          break;
00118E  370026     BRA 0x11DC
1620:              
1621:                      case MSD_ERROR_CASE_7://Also CASE_8
1622:                          msd_csw.bCSWStatus = MSD_CSW_PHASE_ERROR;
001190  B3C020     MOV #0x2, W0
001192  B7E84A     MOV.B WREG, 0x84A
1623:                          USBStallEndpoint(MSD_DATA_IN_EP, IN_TO_HOST);	//STALL the bulk IN MSD endpoint
001194  B3C011     MOV #0x1, W1
001196  784001     MOV.B W1, W0
001198  07FC69     RCALL USBStallEndpoint
1624:                          break;
00119A  370020     BRA 0x11DC
1625:              
1626:                      case MSD_ERROR_CASE_9://Also CASE_11
1627:                          USBStallEndpoint(MSD_DATA_OUT_EP, OUT_FROM_HOST); //Stall the bulk OUT endpoint
00119C  EB4080     CLR.B W1
00119E  B3C010     MOV #0x1, W0
0011A0  07FC65     RCALL USBStallEndpoint
1628:                          break;
0011A2  37001C     BRA 0x11DC
1629:              
1630:                      case MSD_ERROR_CASE_10://Also CASE_13
1631:                          msd_csw.bCSWStatus = MSD_CSW_PHASE_ERROR;
0011A4  B3C020     MOV #0x2, W0
0011A6  B7E84A     MOV.B WREG, 0x84A
1632:                          USBStallEndpoint(MSD_DATA_OUT_EP, OUT_FROM_HOST);
0011A8  EB4080     CLR.B W1
0011AA  B3C010     MOV #0x1, W0
0011AC  07FC5F     RCALL USBStallEndpoint
1633:                          break;
0011AE  370016     BRA 0x11DC
1634:              
1635:                      case MSD_ERROR_UNSUPPORTED_COMMAND:
1636:                          ResetSenseData();
0011B0  07FF67     RCALL ResetSenseData
1637:                          gblSenseData[LUN_INDEX].SenseKey=S_ILLEGAL_REQUEST;
0011B2  A80A9F     BSET 0xA9F, #0
0011B4  A92A9F     BCLR 0xA9F, #1
0011B6  A84A9F     BSET 0xA9F, #2
0011B8  A96A9F     BCLR 0xA9F, #3
1638:                          gblSenseData[LUN_INDEX].ASC=ASC_INVALID_COMMAND_OPCODE;
0011BA  B3C200     MOV #0x20, W0
0011BC  B7EAA9     MOV.B WREG, 0xAA9
1639:                          gblSenseData[LUN_INDEX].ASCQ=ASCQ_INVALID_COMMAND_OPCODE;
0011BE  EF6AAA     CLR.B 0xAAA
1640:                          
1641:                          if((OldMSD_State == MSD_DATA_OUT) && (gblCBW.dCBWDataTransferLength != 0))
0011C0  544FE2     SUB.B W8, #0x2, [W15]
0011C2  3A0009     BRA NZ, 0x11D6
0011C4  805424     MOV 0xA84, W4
0011C6  805435     MOV 0xA86, W5
0011C8  520FE0     SUB W4, #0x0, [W15]
0011CA  5A8FE0     SUBB W5, #0x0, [W15]
0011CC  320004     BRA Z, 0x11D6
1642:                          {
1643:                              USBStallEndpoint(MSD_DATA_OUT_EP, OUT_FROM_HOST);
0011CE  EB4080     CLR.B W1
0011D0  B3C010     MOV #0x1, W0
0011D2  07FC4C     RCALL USBStallEndpoint
0011D4  370003     BRA 0x11DC
1644:                          }
1645:                          else
1646:                          {
1647:                              USBStallEndpoint(MSD_DATA_IN_EP, IN_TO_HOST);
0011D6  B3C011     MOV #0x1, W1
0011D8  784001     MOV.B W1, W0
0011DA  07FC48     RCALL USBStallEndpoint
1648:                          }
1649:                          break;
1650:                      default:	//Shouldn't get hit, don't call MSDErrorHandler() if there is no error
1651:                          break;
1652:                  }//switch(ErrorCase)
1653:              }	
0011DC  78044F     MOV [--W15], W8
0011DE  060000     RETURN
1654:              
1655:              
1656:              
1657:              //-----------------------------------------------------------------------------------------
1658:              #endif //end of #ifdef USB_USE_MSD
1659:              //End of file usb_device_msd.c
---  F:/microchip/mla/v2013_12_20/framework/usb/src/usb_device.c  ---------------------------------------
1:                 /*******************************************************************************
2:                   USB Device Layer
3:                 
4:                   Company:
5:                     Microchip Technology Inc.
6:                 
7:                   File Name:
8:                     usb_device.c
9:                 
10:                  Summary:
11:                   Provides basic USB device functionality, including enumeration and USB
12:                   chapter 9 required behavior.
13:                
14:                  Description:
15:                   Provides basic USB device functionality, including enumeration and USB
16:                   chapter 9 required behavior.
17:                *******************************************************************************/
18:                
19:                // DOM-IGNORE-BEGIN
20:                /*******************************************************************************
21:                Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
22:                
23:                Microchip licenses to you the right to use, modify, copy and distribute
24:                Software only when embedded on a Microchip microcontroller or digital signal
25:                controller that is integrated into your product or third party product
26:                (pursuant to the sublicense terms in the accompanying license agreement).
27:                
28:                You should refer to the license agreement accompanying this Software for
29:                additional information regarding your rights and obligations.
30:                
31:                SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
32:                EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
33:                MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
34:                IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
35:                CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
36:                OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
37:                INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
38:                CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
39:                SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
40:                (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
41:                *******************************************************************************/
42:                // DOM-IGNORE-END
43:                
44:                
45:                // *****************************************************************************
46:                // *****************************************************************************
47:                // Section: Included Files
48:                // *****************************************************************************
49:                // *****************************************************************************
50:                #include <stdint.h>
51:                #include <stddef.h>
52:                
53:                #include "system.h"
54:                #include "system_config.h"
55:                
56:                #include <usb/usb.h>
57:                #include <usb/usb_ch9.h>
58:                #include <usb/usb_device.h>
59:                #include <usb/src/usb_device_local.h>
60:                
61:                #if defined(USB_USE_MSD)
62:                    #include "usb/usb_device_msd.h"
63:                #endif
64:                
65:                // *****************************************************************************
66:                // *****************************************************************************
67:                // Section: File Scope or Global Constants
68:                // *****************************************************************************
69:                // *****************************************************************************
70:                #if !defined(USE_USB_BUS_SENSE_IO)
71:                    //Assume the +5V VBUS is always present (like it would be in a bus powered
72:                    //only application), unless USE_USB_BUS_SENSE_IO and USB_BUS_SENSE have
73:                    //been properly defined elsewhere in the project.
74:                    #undef USB_BUS_SENSE
75:                    #define USB_BUS_SENSE 1
76:                #endif
77:                
78:                #if defined(USB_DEVICE_DISABLE_DTS_CHECKING)
79:                    #define _DTS_CHECKING_ENABLED 0
80:                #else
81:                    #define _DTS_CHECKING_ENABLED _DTSEN
82:                #endif
83:                
84:                #if !defined(self_power)
85:                    //Assume the application is always bus powered, unless self_power has been
86:                    //defined elsewhere in the project
87:                    #define self_power 0    //0 = bus powered
88:                #endif
89:                
90:                #if !defined(USB_MAX_NUM_CONFIG_DSC)
91:                    //Assume the application only implements one configuration descriptor,
92:                    //unless otherwise specified elsewhere in the project
93:                    #define USB_MAX_NUM_CONFIG_DSC      1
94:                #endif
95:                
96:                #if defined(__XC8)
97:                    //Suppress expected/harmless compiler warning message about unused RAM variables.
98:                    //Certain variables are not used if you don't use all of the USB stack APIs.
99:                    //These variables should not be removed (since they are still used/needed in
100:                   //some applications).
101:                   #pragma warning disable 1090
102:               #endif
103:               
104:               // *****************************************************************************
105:               // *****************************************************************************
106:               // Section: File Scope Data Types
107:               // *****************************************************************************
108:               // *****************************************************************************
109:               typedef union
110:               {
111:                   uint8_t Val;
112:                   struct __PACKED
113:                   {
114:                       unsigned b0:1;
115:                       unsigned b1:1;
116:                       unsigned b2:1;
117:                       unsigned b3:1;
118:                       unsigned b4:1;
119:                       unsigned b5:1;
120:                       unsigned b6:1;
121:                       unsigned b7:1;
122:                   } bits;
123:               } uint8_t_VAL, uint8_t_BITS;
124:               
125:               // *****************************************************************************
126:               // *****************************************************************************
127:               // Section: Variables
128:               // *****************************************************************************
129:               // *****************************************************************************
130:               USB_VOLATILE USB_DEVICE_STATE USBDeviceState;
131:               USB_VOLATILE uint8_t USBActiveConfiguration;
132:               USB_VOLATILE uint8_t USBAlternateInterface[USB_MAX_NUM_INT];
133:               volatile BDT_ENTRY *pBDTEntryEP0OutCurrent;
134:               volatile BDT_ENTRY *pBDTEntryEP0OutNext;
135:               volatile BDT_ENTRY *pBDTEntryOut[USB_MAX_EP_NUMBER+1];
136:               volatile BDT_ENTRY *pBDTEntryIn[USB_MAX_EP_NUMBER+1];
137:               USB_VOLATILE uint8_t shortPacketStatus;
138:               USB_VOLATILE uint8_t controlTransferState;
139:               USB_VOLATILE IN_PIPE inPipes[1];
140:               USB_VOLATILE OUT_PIPE outPipes[1];
141:               USB_VOLATILE uint8_t *pDst;
142:               USB_VOLATILE bool RemoteWakeup;
143:               USB_VOLATILE bool USBBusIsSuspended;
144:               USB_VOLATILE USTAT_FIELDS USTATcopy;
145:               USB_VOLATILE uint8_t endpoint_number;
146:               USB_VOLATILE bool BothEP0OutUOWNsSet;
147:               USB_VOLATILE EP_STATUS ep_data_in[USB_MAX_EP_NUMBER+1];
148:               USB_VOLATILE EP_STATUS ep_data_out[USB_MAX_EP_NUMBER+1];
149:               USB_VOLATILE uint8_t USBStatusStageTimeoutCounter;
150:               volatile bool USBDeferStatusStagePacket;
151:               volatile bool USBStatusStageEnabledFlag1;
152:               volatile bool USBStatusStageEnabledFlag2;
153:               volatile bool USBDeferINDataStagePackets;
154:               volatile bool USBDeferOUTDataStagePackets;
155:               
156:               /** USB FIXED LOCATION VARIABLES ***********************************/
157:               #if defined(COMPILER_MPLAB_C18)
158:                   #pragma udata USB_BDT=USB_BDT_ADDRESS
159:               #endif
160:               
161:               volatile BDT_ENTRY BDT[BDT_NUM_ENTRIES] BDT_BASE_ADDR_TAG;
162:               
163:               /********************************************************************
164:                * EP0 Buffer Space
165:                *******************************************************************/
166:               volatile CTRL_TRF_SETUP SetupPkt CTRL_TRF_SETUP_ADDR_TAG;
167:               volatile uint8_t CtrlTrfData[USB_EP0_BUFF_SIZE] CTRL_TRF_DATA_ADDR_TAG;
168:               
169:               /********************************************************************
170:                * non-EP0 Buffer Space
171:                *******************************************************************/
172:               #if defined(USB_USE_MSD)
173:                   //Check if the MSD application specific USB endpoint buffer placement address 
174:                   //macros have already been defined or not (ex: in a processor specific header)
175:                   //The msd_cbw and msd_csw buffers must be USB module accessible (and therefore
176:                   //must be at a certain address range on certain microcontrollers).
177:                   #if !defined(MSD_CBW_ADDR_TAG)
178:                       //Not previously defined.  Assume in this case all microcontroller RAM is
179:                       //USB module accessible, and therefore, no specific address tag value is needed.
180:                       #define MSD_CBW_ADDR_TAG
181:                       #define MSD_CSW_ADDR_TAG
182:                   #endif
183:               	volatile USB_MSD_CBW msd_cbw MSD_CBW_ADDR_TAG;  //Must be located in USB module accessible RAM
184:               	volatile USB_MSD_CSW msd_csw MSD_CSW_ADDR_TAG;  //Must be located in USB module accessible RAM
185:               
186:                   #if defined(__18CXX) || defined(__XC8)
187:                       volatile char msd_buffer[512] @ MSD_BUFFER_ADDRESS;
188:                   #else
189:                       volatile char msd_buffer[512];
190:               	#endif
191:               #endif
192:               
193:               //Depricated in v2.2 - will be removed in a future revision
194:               #if !defined(USB_USER_DEVICE_DESCRIPTOR)
195:                   //Device descriptor
196:                   extern const USB_DEVICE_DESCRIPTOR device_dsc;
197:               #else
198:                   USB_USER_DEVICE_DESCRIPTOR_INCLUDE;
199:               #endif
200:               
201:               #if !defined(USB_USER_CONFIG_DESCRIPTOR)
202:                   //Array of configuration descriptors
203:                   extern const uint8_t *const USB_CD_Ptr[];
204:               #else
205:                   USB_USER_CONFIG_DESCRIPTOR_INCLUDE;
206:               #endif
207:               
208:               extern const uint8_t *const USB_SD_Ptr[];
209:               
210:               
211:               // *****************************************************************************
212:               // *****************************************************************************
213:               // Section: Private and External Prototypes
214:               // *****************************************************************************
215:               // *****************************************************************************
216:               extern bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size);
217:               
218:               static void USBCtrlEPService(void);
219:               static void USBCtrlTrfSetupHandler(void);
220:               static void USBCtrlTrfInHandler(void);
221:               static void USBCheckStdRequest(void);
222:               static void USBStdGetDscHandler(void);
223:               static void USBCtrlEPServiceComplete(void);
224:               static void USBCtrlTrfTxService(void);
225:               static void USBCtrlTrfRxService(void);
226:               static void USBStdSetCfgHandler(void);
227:               static void USBStdGetStatusHandler(void);
228:               static void USBStdFeatureReqHandler(void);
229:               static void USBCtrlTrfOutHandler(void);
230:               static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction);
231:               static void USBWakeFromSuspend(void);
232:               static void USBSuspend(void);
233:               static void USBStallHandler(void);
234:               
235:               // *****************************************************************************
236:               // *****************************************************************************
237:               // Section: Macros or Functions
238:               // *****************************************************************************
239:               // *****************************************************************************
240:               
241:               /****************************************************************************
242:                 Function:
243:                   void USBAdvancePingPongBuffer(BDT_ENTRY** buffer)
244:               
245:                 Description:
246:                   This function will advance the passed pointer to the next buffer based on
247:                   the ping pong option setting.  This function should be used for EP1-EP15
248:                   only.  This function is not valid for EP0.
249:               
250:                 Precondition:
251:                   None
252:               
253:                 Parameters:
254:                   BDT_ENTRY** - pointer to the BDT_ENTRY pointer that you want to be advanced
255:                   to the next buffer state
256:               
257:                 Return Values:
258:                   None
259:               
260:                 Remarks:
261:                   None
262:               
263:                 ***************************************************************************/
264:               #define USBAdvancePingPongBuffer(buffer) {((uint8_t_VAL*)buffer)->Val ^= USB_NEXT_PING_PONG;}
265:               #define USBHALPingPongSetToOdd(buffer)   {((uint8_t_VAL*)buffer)->Val |= USB_NEXT_PING_PONG;}
266:               #define USBHALPingPongSetToEven(buffer)  {((uint8_t_VAL*)buffer)->Val &= ~USB_NEXT_PING_PONG;}
267:               
268:               
269:               /**************************************************************************
270:                   Function:
271:                       void USBDeviceInit(void)
272:                   
273:                   Description:
274:                       This function initializes the device stack it in the default state. The
275:                       USB module will be completely reset including all of the internal
276:                       variables, registers, and interrupt flags.
277:                               
278:                   Precondition:
279:                       This function must be called before any of the other USB Device
280:                       functions can be called, including USBDeviceTasks().
281:                       
282:                   Parameters:
283:                       None
284:                    
285:                   Return Values:
286:                       None
287:                       
288:                   Remarks:
289:                       None
290:                                                                         
291:                 ***************************************************************************/
292:               void USBDeviceInit(void)
293:               {
294:                   uint8_t i;
295:               
296:                   USBDisableInterrupts();
00093C  A9C09E     BCLR IEC5, #6
297:               
298:                   // Clear all USB error flags
299:                   USBClearInterruptRegister(U1EIR);  
00093E  EB8200     SETM W4
000940  882474     MOV W4, U1EIR
300:                      
301:                   // Clears all USB interrupts          
302:                   USBClearInterruptRegister(U1IR); 
000942  882454     MOV W4, U1IR
303:               
304:                   //Clear all of the endpoint control registers
305:                   U1EP0 = 0;
000944  EB0300     CLR W6
000946  882556     MOV W6, U1EP0
306:                   
307:                   DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
000948  882566     MOV W6, U1EP1
308:               
309:                   SetConfigurationOptions();
00094A  200024     MOV #0x2, W4
00094C  882534     MOV W4, U1CNFG1
00094E  882546     MOV W6, U1CNFG2
000950  A94486     BCLR U1OTGCON, #2
000952  2009F4     MOV #0x9F, W4
000954  882484     MOV W4, U1EIE
000956  882464     MOV W4, U1IE
310:               
311:                   //power up the module (if not already powered)
312:                   USBPowerModule();
000958  A80488     BSET U1PWRC, #0
313:               
314:                   //set the address of the BDT (if applicable)
315:                   USBSetBDTAddress(BDT);
00095A  20C004     MOV #0xC00, W4
00095C  DE2248     LSR W4, #8, W4
00095E  8824C4     MOV W4, U1BDTP1
316:               
317:                   //Clear all of the BDT entries
318:                   for(i=0;i<(sizeof(BDT)/sizeof(BDT_ENTRY));i++)
319:                   {
320:                       BDT[i].Val = 0x00;
000960  B82260     MUL.UU W4, #0, W4
000962  886004     MOV W4, BDT
000964  886015     MOV W5, 0xC02
000966  886024     MOV W4, 0xC04
000968  886035     MOV W5, 0xC06
00096A  886044     MOV W4, 0xC08
00096C  886055     MOV W5, 0xC0A
00096E  886064     MOV W4, 0xC0C
000970  886075     MOV W5, 0xC0E
000972  886084     MOV W4, 0xC10
000974  886095     MOV W5, 0xC12
000976  8860A4     MOV W4, 0xC14
000978  8860B5     MOV W5, 0xC16
00097A  8860C4     MOV W4, 0xC18
00097C  8860D5     MOV W5, 0xC1A
00097E  8860E4     MOV W4, 0xC1C
000980  8860F5     MOV W5, 0xC1E
321:                   }
322:               
323:                   // Assert reset request to all of the Ping Pong buffer pointers
324:                   USBPingPongBufferReset = 1;                    
000982  A82494     BSET U1CON, #1
325:               
326:                   // Reset to default address
327:                   U1ADDR = 0x00;                   
000984  8824B6     MOV W6, U1ADDR
328:               
329:                   // Make sure packet processing is enabled
330:                   USBPacketDisable = 0;           
000986  A9A494     BCLR U1CON, #5
331:               
332:                   //Stop trying to reset ping pong buffer pointers
333:                   USBPingPongBufferReset = 0;
000988  A92494     BCLR U1CON, #1
334:               
335:                   // Flush any pending transactions
336:                   while(USBTransactionCompleteIF == 1)      
00098A  802454     MOV U1IR, W4
00098C  620268     AND W4, #0x8, W4
00098E  520F86     SUB W4, W6, [W15]
000990  32000E     BRA Z, 0x9AE
0009AA  AB648A     BTST U1IR, #3
0009AC  3AFFF4     BRA NZ, 0x996
337:                   {
338:                       USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
000992  200086     MOV #0x8, W6
000996  882456     MOV W6, U1IR
339:                       //Initialize USB stack software state variables
340:                       inPipes[0].info.Val = 0;
000994  EB4200     CLR.B W4
000998  784004     MOV.B W4, W0
00099A  B7E806     MOV.B WREG, 0x806
00099C  B7E811     MOV.B WREG, 0x811
341:                       outPipes[0].info.Val = 0;
342:                       outPipes[0].wCount.Val = 0;
00099E  208125     MOV #0x812, W5
0009A0  784295     MOV.B [W5], W5
0009A2  B7E812     MOV.B WREG, 0x812
0009A4  208135     MOV #0x813, W5
0009A6  784295     MOV.B [W5], W5
0009A8  B7E813     MOV.B WREG, 0x813
343:                   }
344:               
345:                   //Set flags to true, so the USBCtrlEPAllowStatusStage() function knows not to
346:                   //try and arm a status stage, even before the first control transfer starts.
347:                   USBStatusStageEnabledFlag1 = true;
0009AE  B3C010     MOV #0x1, W0
0009B0  B7EA6E     MOV.B WREG, USBStatusStageEnabledFlag1
0009B2  B7EA6F     MOV.B WREG, USBStatusStageEnabledFlag2
348:                   USBStatusStageEnabledFlag2 = true;
349:                   //Initialize other flags
350:                   USBDeferINDataStagePackets = false;
0009B4  EB4200     CLR.B W4
0009B6  784004     MOV.B W4, W0
0009B8  B7E802     MOV.B WREG, USBDeferINDataStagePackets
0009BA  B7E800     MOV.B WREG, USBDeferOUTDataStagePackets
0009BC  B7E80B     MOV.B WREG, USBBusIsSuspended
351:                   USBDeferOUTDataStagePackets = false;
352:                   USBBusIsSuspended = false;
353:               
354:                   //Initialize all pBDTEntryIn[] and pBDTEntryOut[]
355:                   //pointers to NULL, so they don't get used inadvertently.
356:                   for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
357:                   {
358:                       pBDTEntryIn[i] = 0u;
0009C6  8840E5     MOV W5, 0x81C
359:                       pBDTEntryOut[i] = 0u;
0009BE  EB0280     CLR W5
0009C0  8840B5     MOV W5, pBDTEntryOut
0009C8  8840C5     MOV W5, 0x818
360:                       ep_data_in[i].Val = 0u;
0009C2  B7EA69     MOV.B WREG, ep_data_in
0009C4  B7EA6B     MOV.B WREG, ep_data_out
0009CA  B7EA6A     MOV.B WREG, 0xA6A
0009CC  B7EA6C     MOV.B WREG, 0xA6C
361:                       ep_data_out[i].Val = 0u;
362:                   }
363:               
364:                   //Get ready for the first packet
365:                   pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
0009CE  20C086     MOV #0xC08, W6
0009D0  8840D6     MOV W6, pBDTEntryIn
366:                   // Initialize EP0 as a Ctrl EP
367:                   U1EP0 = EP_CTRL|USB_HANDSHAKE_ENABLED;        
0009D2  2000D6     MOV #0xD, W6
0009D4  882556     MOV W6, U1EP0
368:               	//Prepare for the first SETUP on EP0 OUT
369:                   BDT[EP0_OUT_EVEN].ADR = ConvertToPhysicalAddress(&SetupPkt);
0009D6  20A4C6     MOV #0xA4C, W6
0009D8  886016     MOV W6, 0xC02
370:                   BDT[EP0_OUT_EVEN].CNT = USB_EP0_BUFF_SIZE;
0009DA  B3C080     MOV #0x8, W0
0009DC  B7EC00     MOV.B WREG, BDT
371:                   BDT[EP0_OUT_EVEN].STAT.Val = _DAT0|_BSTALL;
0009DE  B3C040     MOV #0x4, W0
0009E0  B7EC01     MOV.B WREG, 0xC01
372:                   BDT[EP0_OUT_EVEN].STAT.Val |= _USIE;
0009E2  A8EC01     BSET 0xC01, #7
373:               
374:                   // Clear active configuration
375:                   USBActiveConfiguration = 0;     
0009E4  784004     MOV.B W4, W0
0009E6  B7E80E     MOV.B WREG, USBActiveConfiguration
376:               
377:                   //Indicate that we are now in the detached state        
378:                   USBDeviceState = DETACHED_STATE;
0009E8  884065     MOV W5, USBDeviceState
379:               }
0009EA  060000     RETURN
380:               
381:               /**************************************************************************
382:                 Function:
383:                       void USBDeviceTasks(void)
384:                   
385:                 Summary:
386:                   This function is the main state machine/transaction handler of the USB 
387:                   device side stack.  When the USB stack is operated in "USB_POLLING" mode 
388:                   (usb_config.h user option) the USBDeviceTasks() function should be called 
389:                   periodically to receive and transmit packets through the stack. This 
390:                   function also takes care of control transfers associated with the USB 
391:                   enumeration process, and detecting various USB events (such as suspend).  
392:                   This function should be called at least once every 1.8ms during the USB 
393:                   enumeration process. After the enumeration process is complete (which can 
394:                   be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
395:                   USBDeviceTasks() handler may be called the faster of: either once 
396:                   every 9.8ms, or as often as needed to make sure that the hardware USTAT 
397:                   FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
398:                   a minimum rate of either the frequency that USBTransferOnePacket() gets 
399:                   called, or, once/1.8ms, whichever is faster.  See the inline code comments 
400:                   near the top of usb_device.c for more details about minimum timing 
401:                   requirements when calling USBDeviceTasks().
402:                   
403:                   When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
404:                   to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
405:                   mode, the USBDeviceTasks() handler only needs to execute when a USB 
406:                   interrupt occurs, and therefore only needs to be called from the interrupt 
407:                   context.
408:               
409:                 Description:
410:                   This function is the main state machine/transaction handler of the USB 
411:                   device side stack.  When the USB stack is operated in "USB_POLLING" mode 
412:                   (usb_config.h user option) the USBDeviceTasks() function should be called 
413:                   periodically to receive and transmit packets through the stack. This 
414:                   function also takes care of control transfers associated with the USB 
415:                   enumeration process, and detecting various USB events (such as suspend).  
416:                   This function should be called at least once every 1.8ms during the USB 
417:                   enumeration process. After the enumeration process is complete (which can 
418:                   be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
419:                   USBDeviceTasks() handler may be called the faster of: either once 
420:                   every 9.8ms, or as often as needed to make sure that the hardware USTAT 
421:                   FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
422:                   a minimum rate of either the frequency that USBTransferOnePacket() gets 
423:                   called, or, once/1.8ms, whichever is faster.  See the inline code comments 
424:                   near the top of usb_device.c for more details about minimum timing 
425:                   requirements when calling USBDeviceTasks().
426:                   
427:                   When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
428:                   to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
429:                   mode, the USBDeviceTasks() handler only needs to execute when a USB 
430:                   interrupt occurs, and therefore only needs to be called from the interrupt 
431:                   context.
432:               
433:                   Typical usage:
434:                   <code>
435:                   void main(void)
436:                   {
437:                       USBDeviceInit();
438:                       while(1)
439:                       {
440:                           USBDeviceTasks(); //Takes care of enumeration and other USB events
441:                           if((USBGetDeviceState() \< CONFIGURED_STATE) ||
442:                              (USBIsDeviceSuspended() == true))
443:                           {
444:                               //Either the device is not configured or we are suspended,
445:                               // so we don't want to execute any USB related application code
446:                               continue;   //go back to the top of the while loop
447:                           }
448:                           else
449:                           {
450:                               //Otherwise we are free to run USB and non-USB related user 
451:                               //application code.
452:                               UserApplication();
453:                           }
454:                       }
455:                   }
456:                   </code>
457:               
458:                 Precondition:
459:                   Make sure the USBDeviceInit() function has been called prior to calling
460:                   USBDeviceTasks() for the first time.
461:                 Remarks:
462:                   USBDeviceTasks() does not need to be called while in the USB suspend mode, 
463:                   if the user application firmware in the USBCBSuspend() callback function
464:                   enables the ACTVIF USB interrupt source and put the microcontroller into 
465:                   sleep mode.  If the application firmware decides not to sleep the 
466:                   microcontroller core during USB suspend (ex: continues running at full 
467:                   frequency, or clock switches to a lower frequency), then the USBDeviceTasks()
468:                   function must still be called periodically, at a rate frequent enough to 
469:                   ensure the 10ms resume recovery interval USB specification is met.  Assuming
470:                   a worst case primary oscillator and PLL start up time of less than 5ms, then
471:                   USBDeviceTasks() should be called once every 5ms in this scenario.
472:                  
473:                   When the USB cable is detached, or the USB host is not actively powering 
474:                   the VBUS line to +5V nominal, the application firmware does not always have 
475:                   to call USBDeviceTasks() frequently, as no USB activity will be taking 
476:                   place.  However, if USBDeviceTasks() is not called regularly, some 
477:                   alternative means of promptly detecting when VBUS is powered (indicating 
478:                   host attachment), or not powered (host powered down or USB cable unplugged)
479:                   is still needed.  For self or dual self/bus powered USB applications, see 
480:                   the USBDeviceAttach() and USBDeviceDetach() API documentation for additional 
481:                   considerations.
482:                   ***************************************************************************/
483:               void USBDeviceTasks(void)
484:               {
000E88  BE9F88     MOV.D W8, [W15++]
000E8A  781F8A     MOV W10, [W15++]
485:                   uint8_t i;
486:               
487:               #ifdef USB_SUPPORT_OTG
488:               
489:                   //SRP Time Out Check
490:                   if (USBOTGSRPIsReady())
491:                   {
492:                       if (USBT1MSECIF && USBT1MSECIE)
493:                       {
494:                           if (USBOTGGetSRPTimeOutFlag())
495:                           {
496:                               if (USBOTGIsSRPTimeOutExpired())
497:                               {
498:                                   USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
499:                               }       
500:                           }
501:               
502:                           //Clear Interrupt Flag
503:                           USBClearInterruptFlag(USBT1MSECIFReg,USBT1MSECIFBitNum);
504:                       }
505:                   }
506:               #endif
507:               
508:                   #if defined(USB_POLLING)
509:                   //If the interrupt option is selected then the customer is required
510:                   //  to notify the stack when the device is attached or removed from the
511:                   //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
512:                   if (USB_BUS_SENSE != 1)
513:                   {
514:                        // Disable module & detach from bus
515:                        U1CON = 0;             
516:               
517:                        // Mask all USB interrupts              
518:                        U1IE = 0;          
519:               
520:                        //Move to the detached state                  
521:                        USBDeviceState = DETACHED_STATE;
522:               
523:                        #ifdef  USB_SUPPORT_OTG    
524:                            //Disable D+ Pullup
525:                            U1OTGCONbits.DPPULUP = 0;
526:               
527:                            //Disable HNP
528:                            USBOTGDisableHnp();
529:               
530:                            //Deactivate HNP
531:                            USBOTGDeactivateHnp();
532:                            
533:                            //If ID Pin Changed State
534:                            if (USBIDIF && USBIDIE)
535:                            {  
536:                                //Re-detect & Initialize
537:                                 USBOTGInitialize();
538:               
539:                                 //Clear ID Interrupt Flag
540:                                 USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
541:                            }
542:                        #endif
543:               
544:                        #if defined __C30__ || defined __XC16__
545:                            //USBClearInterruptFlag(U1OTGIR, 3); 
546:                        #endif
547:                           //return so that we don't go through the rest of 
548:                           //the state machine
549:                        USBClearUSBInterrupt();
550:                        return;
551:                   }
552:               
553:               	#ifdef USB_SUPPORT_OTG
554:                   //If Session Is Started Then
555:                   else
556:               	{
557:                       //If SRP Is Ready
558:                       if (USBOTGSRPIsReady())
559:                       {   
560:                           //Clear SRPReady
561:                           USBOTGClearSRPReady();
562:               
563:                           //Clear SRP Timeout Flag
564:                           USBOTGClearSRPTimeOutFlag();
565:               
566:                           //Indicate Session Started
567:                           UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
568:                       }
569:                   }
570:               	#endif	//#ifdef USB_SUPPORT_OTG
571:               
572:                   //if we are in the detached state
573:                   if(USBDeviceState == DETACHED_STATE)
574:                   {
575:               	    //Initialize register to known value
576:                       U1CON = 0;                          
577:               
578:                       // Mask all USB interrupts
579:                       U1IE = 0;                                
580:               
581:                       //Enable/set things like: pull ups, full/low-speed mode, 
582:                       //set the ping pong mode, and set internal transceiver
583:                       SetConfigurationOptions();
584:               
585:                       // Enable module & attach to bus
586:                       while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
587:               
588:                       //moved to the attached state
589:                       USBDeviceState = ATTACHED_STATE;
590:               
591:                       #ifdef  USB_SUPPORT_OTG
592:                           U1OTGCON |= USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
593:                       #endif
594:                   }
595:               	#endif  //#if defined(USB_POLLING)
596:               
597:                   if(USBDeviceState == ATTACHED_STATE)
000E8C  804064     MOV USBDeviceState, W4
000E8E  520FE1     SUB W4, #0x1, [W15]
000E90  3A000A     BRA NZ, 0xEA6
598:                   {
599:                       /*
600:                        * After enabling the USB module, it takes some time for the
601:                        * voltage on the D+ or D- line to rise high enough to get out
602:                        * of the SE0 condition. The USB Reset interrupt should not be
603:                        * unmasked until the SE0 condition is cleared. This helps
604:                        * prevent the firmware from misinterpreting this unique event
605:                        * as a USB bus reset from the USB host.
606:                        */
607:               
608:                       if(!USBSE0Event)
000E92  200404     MOV #0x40, W4
000E94  8024A0     MOV U1CON, W0
000E96  620200     AND W4, W0, W4
000E98  520FE0     SUB W4, #0x0, [W15]
000E9A  3A0005     BRA NZ, 0xEA6
609:                       {
610:                           USBClearInterruptRegister(U1IR);// Clear all USB interrupts
000E9C  EFA48A     SETM U1IR
611:                           #if defined(USB_POLLING)
612:                               U1IE=0;                        // Mask all USB interrupts
613:                           #endif
614:                           USBResetIE = 1;             // Unmask RESET interrupt
000E9E  A8048C     BSET U1IE, #0
615:                           USBIdleIE = 1;             // Unmask IDLE interrupt
000EA0  A8848C     BSET U1IE, #4
616:                           USBDeviceState = POWERED_STATE;
000EA2  200024     MOV #0x2, W4
000EA4  884064     MOV W4, USBDeviceState
617:                       }
618:                   }
619:               
620:                   #ifdef  USB_SUPPORT_OTG
621:                       //If ID Pin Changed State
622:                       if (USBIDIF && USBIDIE)
623:                       {  
624:                           //Re-detect & Initialize
625:                           USBOTGInitialize();
626:               
627:                           USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
628:                       }
629:                   #endif
630:               
631:                   /*
632:                    * Task A: Service USB Activity Interrupt
633:                    */
634:                   if(USBActivityIF && USBActivityIE)
000EA6  AB8480     BTST U1OTGIR, #4
000EA8  320005     BRA Z, 0xEB4
000EAA  AB8482     BTST U1OTGIE, #4
000EAC  320003     BRA Z, 0xEB4
635:                   {
636:                       USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
000EAE  200104     MOV #0x10, W4
000EB0  882404     MOV W4, U1OTGIR
637:                       #if defined(USB_SUPPORT_OTG)
638:                           U1OTGIR = 0x10;        
639:                       #else
640:                           USBWakeFromSuspend();
000EB2  07FC00     RCALL _USBWakeFromSuspend
641:                       #endif
642:                   }
643:               
644:                   /*
645:                    * Pointless to continue servicing if the device is in suspend mode.
646:                    */
647:                   if(USBSuspendControl==1)
000EB4  AB2488     BTST U1PWRC, #1
000EB6  320002     BRA Z, 0xEBC
648:                   {
649:                       USBClearUSBInterrupt();
000EB8  A9C08E     BCLR IFS5, #6
650:                       return;
000EBA  37007D     BRA 0xFB6
651:                   }
652:               
653:                   /*
654:                    * Task B: Service USB Bus Reset Interrupt.
655:                    * When bus reset is received during suspend, ACTVIF will be set first,
656:                    * once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
657:                    * This is why URSTIF is checked after ACTVIF.
658:                    *
659:                    * The USB reset flag is masked when the USB state is in
660:                    * DETACHED_STATE or ATTACHED_STATE, and therefore cannot
661:                    * cause a USB reset event during these two states.
662:                    */
663:                   if(USBResetIF && USBResetIE)
000EBC  AB048A     BTST U1IR, #0
000EBE  320008     BRA Z, 0xED0
000EC0  AB048C     BTST U1IE, #0
000EC2  320006     BRA Z, 0xED0
664:                   {
665:                       USBDeviceInit();
000EC4  07FD3B     RCALL USBDeviceInit
666:               
667:                       //Re-enable the interrupts since the USBDeviceInit() function will
668:                       //  disable them.  This will do nothing in a polling setup
669:                       USBUnmaskInterrupts();
000EC6  A8C09E     BSET IEC5, #6
670:               
671:                       USBDeviceState = DEFAULT_STATE;
000EC8  200044     MOV #0x4, W4
000ECA  884064     MOV W4, USBDeviceState
672:               
673:                       #ifdef USB_SUPPORT_OTG
674:                            //Disable HNP
675:                            USBOTGDisableHnp();
676:               
677:                            //Deactivate HNP
678:                            USBOTGDeactivateHnp();
679:                       #endif
680:               
681:                       USBClearInterruptFlag(USBResetIFReg,USBResetIFBitNum);
000ECC  200014     MOV #0x1, W4
000ECE  882454     MOV W4, U1IR
682:                   }
683:               
684:                   /*
685:                    * Task C: Service other USB interrupts
686:                    */
687:                   if(USBIdleIF && USBIdleIE)
000ED0  AB848A     BTST U1IR, #4
000ED2  320005     BRA Z, 0xEDE
000ED4  AB848C     BTST U1IE, #4
000ED6  320003     BRA Z, 0xEDE
688:                   { 
689:                       #ifdef  USB_SUPPORT_OTG 
690:                           //If Suspended, Try to switch to Host
691:                           USBOTGSelectRole(ROLE_HOST);
692:                       #else
693:                           USBSuspend();
000ED8  07FBF6     RCALL _USBSuspend
694:                       #endif
695:                       
696:                       USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
000EDA  200104     MOV #0x10, W4
000EDC  882454     MOV W4, U1IR
697:                   }
698:               
699:                   if(USBSOFIF)
000EDE  AB448A     BTST U1IR, #2
000EE0  320012     BRA Z, 0xF06
700:                   {
701:                       if(USBSOFIE)
000EE2  AB448C     BTST U1IE, #2
000EE4  320004     BRA Z, 0xEEE
702:                       {
703:                           USB_SOF_HANDLER(EVENT_SOF,0,1);
000EE6  200012     MOV #0x1, W2
000EE8  EB0080     CLR W1
000EEA  200730     MOV #0x73, W0
000EEC  07FA22     RCALL USER_USB_CALLBACK_EVENT_HANDLER
704:                       }    
705:                       USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
000EEE  200044     MOV #0x4, W4
000EF0  882454     MOV W4, U1IR
706:                       
707:                       #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
708:                           //Supporting this feature requires a 1ms timebase for keeping track of the timeout interval.
709:                           #if(USB_SPEED_OPTION == USB_LOW_SPEED)
710:                               #warning "Double click this message.  See inline code comments."
711:                               //The "USB_ENABLE_STATUS_STAGE_TIMEOUTS" feature is optional and is
712:                               //not strictly needed in all applications (ex: those that never call 
713:                               //USBDeferStatusStage() and don't use host to device (OUT) control
714:                               //transfers with data stage).  
715:                               //However, if this feature is enabled and used, it requires a timer 
716:                               //(preferrably 1ms) to decrement the USBStatusStageTimeoutCounter.  
717:                               //In USB Full Speed applications, the host sends Start-of-Frame (SOF) 
718:                               //packets at a 1ms rate, which generates SOFIF interrupts.
719:                               //These interrupts can be used to decrement USBStatusStageTimeoutCounter as shown 
720:                               //below.  However, the host does not send SOF packets to Low Speed devices.  
721:                               //Therefore, some other method  (ex: using a general purpose microcontroller 
722:                               //timer, such as Timer0) needs to be implemented to call and execute the below code
723:                               //at a once/1ms rate, in a low speed USB application.
724:                               //Note: Pre-condition to executing the below code: USBDeviceInit() should have
725:                               //been called at least once (since the last microcontroller reset/power up), 
726:                               //prior to executing the below code.
727:                           #endif
728:                           
729:                           //Decrement our status stage counter.
730:                           if(USBStatusStageTimeoutCounter != 0u)
000EF2  20A6D4     MOV #0xA6D, W4
000EF4  784214     MOV.B [W4], W4
000EF6  524FE0     SUB.B W4, #0x0, [W15]
000EF8  320001     BRA Z, 0xEFC
731:                           {
732:                               USBStatusStageTimeoutCounter--;
000EFA  ED6A6D     DEC.B USBStatusStageTimeoutCounter
733:                           }
734:                           //Check if too much time has elapsed since progress was made in 
735:                           //processing the control transfer, without arming the status stage.  
736:                           //If so, auto-arm the status stage to ensure that the control 
737:                           //transfer can [eventually] complete, within the timing limits
738:                           //dictated by section 9.2.6 of the official USB 2.0 specifications.
739:                           if(USBStatusStageTimeoutCounter == 0)
000EFC  20A6D4     MOV #0xA6D, W4
000EFE  784214     MOV.B [W4], W4
000F00  524FE0     SUB.B W4, #0x0, [W15]
000F02  3A0001     BRA NZ, 0xF06
740:                           {
741:                               USBCtrlEPAllowStatusStage();    //Does nothing if the status stage was already armed.
000F04  07FE13     RCALL USBCtrlEPAllowStatusStage
742:                           } 
743:                       #endif
744:                   }
745:               
746:                   if(USBStallIF && USBStallIE)
000F06  200804     MOV #0x80, W4
000F08  802455     MOV U1IR, W5
000F0A  620205     AND W4, W5, W4
000F0C  520FE0     SUB W4, #0x0, [W15]
000F0E  320006     BRA Z, 0xF1C
000F10  200804     MOV #0x80, W4
000F12  802460     MOV U1IE, W0
000F14  620200     AND W4, W0, W4
000F16  520FE0     SUB W4, #0x0, [W15]
000F18  320001     BRA Z, 0xF1C
747:                   {
748:                       USBStallHandler();
000F1A  07FB63     RCALL _USBStallHandler
749:                   }
750:               
751:                   if(USBErrorIF && USBErrorIE)
000F1C  AB248A     BTST U1IR, #1
000F1E  320009     BRA Z, 0xF32
000F20  AB248C     BTST U1IE, #1
000F22  320007     BRA Z, 0xF32
752:                   {
753:                       USB_ERROR_HANDLER(EVENT_BUS_ERROR,0,1);
000F24  200012     MOV #0x1, W2
000F26  EB0080     CLR W1
000F28  27FFF0     MOV #0x7FFF, W0
000F2A  07FA03     RCALL USER_USB_CALLBACK_EVENT_HANDLER
754:                       USBClearInterruptRegister(U1EIR);               // This clears UERRIF
000F2C  EFA48E     SETM U1EIR
755:               
756:                       //On PIC18, clearing the source of the error will automatically clear
757:                       //  the interrupt flag.  On other devices the interrupt flag must be 
758:                       //  manually cleared. 
759:                       #if defined(__C32__) || defined(__C30__) || defined __XC16__
760:                           USBClearInterruptFlag( USBErrorIFReg, USBErrorIFBitNum );
000F2E  200024     MOV #0x2, W4
000F30  882454     MOV W4, U1IR
761:                       #endif
762:                   }
763:               
764:                   /*
765:                    * Pointless to continue servicing if the host has not sent a bus reset.
766:                    * Once bus reset is received, the device transitions into the DEFAULT
767:                    * state and is ready for communication.
768:                    */
769:                   if(USBDeviceState < DEFAULT_STATE)
000F32  804064     MOV USBDeviceState, W4
000F34  520FE3     SUB W4, #0x3, [W15]
000F36  3E0002     BRA GTU, 0xF3C
770:                   {
771:                       USBClearUSBInterrupt();
000F38  A9C08E     BCLR IFS5, #6
772:                       return;
000F3A  37003D     BRA 0xFB6
773:                   }  
774:               
775:                   /*
776:                    * Task D: Servicing USB Transaction Complete Interrupt
777:                    */
778:                   if(USBTransactionCompleteIE)
000F3C  AB648C     BTST U1IE, #3
000F3E  32003A     BRA Z, 0xFB4
779:                   {
780:                       for(i = 0; i < 4u; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth
000FB2  3AFFCD     BRA NZ, 0xF4E
781:                       {						//utilization can be compromised, and the device won't be able to receive SETUP packets.
782:                           if(USBTransactionCompleteIF)
000F40  802454     MOV U1IR, W4
000F42  620268     AND W4, #0x8, W4
000F44  B3C048     MOV #0x4, W8
000F4A  3A0003     BRA NZ, 0xF52
000F4C  370033     BRA 0xFB4
000F4E  AB648A     BTST U1IR, #3
000F50  320031     BRA Z, 0xFB4
783:                           {
784:                               //Save and extract USTAT register info.  Will use this info later.
785:                               USTATcopy.Val = U1STAT;
000F52  802494     MOV U1STAT, W4
000F54  784004     MOV.B W4, W0
000F56  B7EA66     MOV.B WREG, USTATcopy
786:                               endpoint_number = USBHALGetLastEndpoint(USTATcopy);
000F58  20A664     MOV #0xA66, W4
000F5A  784214     MOV.B [W4], W4
000F5C  FB8204     ZE W4, W4
000F5E  DE2244     LSR W4, #4, W4
000F60  784004     MOV.B W4, W0
000F62  B7EA67     MOV.B WREG, endpoint_number
787:               
788:                               USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
000F46  20008A     MOV #0x8, W10
000F64  88245A     MOV W10, U1IR
789:               
790:                               //Keep track of the hardware ping pong state for endpoints other
791:                               //than EP0, if ping pong buffering is enabled.
792:                               #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
793:                               if(USBHALGetLastDirection(USTATcopy) == OUT_FROM_HOST)
000F66  20A664     MOV #0xA66, W4
000F68  784214     MOV.B [W4], W4
000F6A  624268     AND.B W4, #0x8, W4
000F6C  3A000C     BRA NZ, 0xF86
794:                               {
795:                                   ep_data_out[endpoint_number].bits.ping_pong_state ^= 1;
000F48  B3CFE9     MOV #0xFE, W9
000F6E  20A674     MOV #0xA67, W4
000F70  784214     MOV.B [W4], W4
000F72  FB8204     ZE W4, W4
000F74  20A6B5     MOV #0xA6B, W5
000F76  7A4365     MOV.B [W5+W4], W6
000F78  634361     AND.B W6, #0x1, W6
000F7A  A20406     BTG.B W6, #0
000F7C  7A43E5     MOV.B [W5+W4], W7
000F7E  63C389     AND.B W7, W9, W7
000F80  73C306     IOR.B W7, W6, W6
000F82  7A7286     MOV.B W6, [W5+W4]
000F84  37000B     BRA 0xF9C
796:                               }
797:                               else
798:                               {
799:                                   ep_data_in[endpoint_number].bits.ping_pong_state ^= 1;
000F86  20A674     MOV #0xA67, W4
000F88  784214     MOV.B [W4], W4
000F8A  FB8204     ZE W4, W4
000F8C  20A695     MOV #0xA69, W5
000F8E  7A4365     MOV.B [W5+W4], W6
000F90  634361     AND.B W6, #0x1, W6
000F92  A20406     BTG.B W6, #0
000F94  7A43E5     MOV.B [W5+W4], W7
000F96  63C389     AND.B W7, W9, W7
000F98  73C306     IOR.B W7, W6, W6
000F9A  7A7286     MOV.B W6, [W5+W4]
800:                               }
801:                               #endif
802:               
803:                               //USBCtrlEPService only services transactions over EP0.
804:                               //It ignores all other EP transactions.
805:                               if(endpoint_number == 0)
000F9C  20A674     MOV #0xA67, W4
000F9E  784214     MOV.B [W4], W4
000FA0  524FE0     SUB.B W4, #0x0, [W15]
000FA2  3A0002     BRA NZ, 0xFA8
806:                               {
807:                                   USBCtrlEPService();
000FA4  07FF3D     RCALL _USBCtrlEPService
000FA6  370004     BRA 0xFB0
808:                               }
809:                               else
810:                               {
811:                                   USB_TRANSFER_COMPLETE_HANDLER(EVENT_TRANSFER, (uint8_t*)&USTATcopy.Val, 0);
000FA8  EB0100     CLR W2
000FAA  20A661     MOV #0xA66, W1
000FAC  200720     MOV #0x72, W0
000FAE  07F9C1     RCALL USER_USB_CALLBACK_EVENT_HANDLER
000FB0  E94408     DEC.B W8, W8
812:                               }
813:                           }//end if(USBTransactionCompleteIF)
814:                           else
815:                           {
816:                               break;	//USTAT FIFO must be empty.
817:                           }
818:                       }//end for()
819:                   }//end if(USBTransactionCompleteIE)
820:               
821:                   USBClearUSBInterrupt();
000FB4  A9C08E     BCLR IFS5, #6
822:               }//end of USBDeviceTasks()
000FB6  78054F     MOV [--W15], W10
000FB8  BE044F     MOV.D [--W15], W8
000FBA  060000     RETURN
823:               
824:               /*******************************************************************************
825:                 Function:
826:                       void USBEnableEndpoint(uint8_t ep, uint8_t options)
827:                   
828:                 Summary:
829:                   This function will enable the specified endpoint with the specified
830:                   options
831:                 Description:
832:                   This function will enable the specified endpoint with the specified
833:                   options.
834:                   
835:                   Typical Usage:
836:                   <code>
837:                   void USBCBInitEP(void)
838:                   {
839:                       USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
840:                       USBMSDInit();
841:                   }
842:                   </code>
843:                   
844:                   In the above example endpoint number MSD_DATA_IN_EP is being configured
845:                   for both IN and OUT traffic with handshaking enabled. Also since
846:                   MSD_DATA_IN_EP is not endpoint 0 (MSD does not allow this), then we can
847:                   explicitly disable SETUP packets on this endpoint.
848:                 Conditions:
849:                   None
850:                 Input:
851:                   uint8_t ep -       the endpoint to be configured
852:                   uint8_t options -  optional settings for the endpoint. The options should
853:                                   be ORed together to form a single options string. The
854:                                   available optional settings for the endpoint. The
855:                                   options should be ORed together to form a single options
856:                                   string. The available options are the following\:
857:                                   * USB_HANDSHAKE_ENABLED enables USB handshaking (ACK,
858:                                     NAK)
859:                                   * USB_HANDSHAKE_DISABLED disables USB handshaking (ACK,
860:                                     NAK)
861:                                   * USB_OUT_ENABLED enables the out direction
862:                                   * USB_OUT_DISABLED disables the out direction
863:                                   * USB_IN_ENABLED enables the in direction
864:                                   * USB_IN_DISABLED disables the in direction
865:                                   * USB_ALLOW_SETUP enables control transfers
866:                                   * USB_DISALLOW_SETUP disables control transfers
867:                                   * USB_STALL_ENDPOINT STALLs this endpoint
868:                 Return:
869:                   None
870:                 Remarks:
871:                   None                                                                                                          
872:                 *****************************************************************************/
873:               void USBEnableEndpoint(uint8_t ep, uint8_t options)
874:               {
0009EC  BE9F88     MOV.D W8, [W15++]
0009EE  781F8A     MOV W10, [W15++]
0009F0  784480     MOV.B W0, W9
0009F2  784401     MOV.B W1, W8
875:                   unsigned char* p;
876:                       
877:                   //Use USBConfigureEndpoint() to set up the pBDTEntryIn/Out[ep] pointer and 
878:                   //starting DTS state in the BDT entry.
879:                   if(options & USB_OUT_ENABLED)
0009F4  FB8508     ZE W8, W10
0009F6  650268     AND W10, #0x8, W4
0009F8  320003     BRA Z, 0xA00
880:                   {
881:                       USBConfigureEndpoint(ep, OUT_FROM_HOST);
0009FA  EB4080     CLR.B W1
0009FC  784009     MOV.B W9, W0
0009FE  07FD38     RCALL _USBConfigureEndpoint
882:                   }
883:                   if(options & USB_IN_ENABLED)
000A00  650564     AND W10, #0x4, W10
000A02  320003     BRA Z, 0xA0A
884:                   {
885:                       USBConfigureEndpoint(ep, IN_TO_HOST);
000A04  B3C011     MOV #0x1, W1
000A06  784009     MOV.B W9, W0
000A08  07FD33     RCALL _USBConfigureEndpoint
886:                   }
887:               
888:                   //Update the relevant UEPx register to actually enable the endpoint with
889:                   //the specified options (ex: handshaking enabled, control transfers allowed,
890:                   //etc.)
891:                   #if defined(__C32__)
892:                       p = (unsigned char*)(&U1EP0+(4*ep));
893:                   #else
894:                       p = (unsigned char*)(&U1EP0+ep);
000A0A  FB8489     ZE W9, W9
895:                   #endif
896:                   *p = options;
000A0C  448489     ADD W9, W9, W9
000A0E  204AA4     MOV #0x4AA, W4
000A10  7CF208     MOV.B W8, [W4+W9]
897:               }
000A12  78054F     MOV [--W15], W10
000A14  BE044F     MOV.D [--W15], W8
000A16  060000     RETURN
898:               
899:               
900:               /*************************************************************************
901:                 Function:
902:                   USB_HANDLE USBTransferOnePacket(uint8_t ep, uint8_t dir, uint8_t* data, uint8_t len)
903:                   
904:                 Summary:
905:                   Transfers a single packet (one transaction) of data on the USB bus.
906:               
907:                 Description:
908:                   The USBTransferOnePacket() function prepares a USB endpoint
909:                   so that it may send data to the host (an IN transaction), or 
910:                   receive data from the host (an OUT transaction).  The 
911:                   USBTransferOnePacket() function can be used both to receive	and 
912:                   send data to the host.  This function is the primary API function 
913:                   provided by the USB stack firmware for sending or receiving application 
914:                   data over the USB port.  
915:               
916:                   The USBTransferOnePacket() is intended for use with all application 
917:                   endpoints.  It is not used for sending or receiving applicaiton data 
918:                   through endpoint 0 by using control transfers.  Separate API 
919:                   functions, such as USBEP0Receive(), USBEP0SendRAMPtr(), and
920:                   USBEP0SendROMPtr() are provided for this purpose.
921:               
922:                   The	USBTransferOnePacket() writes to the Buffer Descriptor Table (BDT)
923:                   entry associated with an endpoint buffer, and sets the UOWN bit, which 
924:                   prepares the USB hardware to allow the transaction to complete.  The 
925:                   application firmware can use the USBHandleBusy() macro to check the 
926:                   status of the transaction, to see if the data has been successfully 
927:                   transmitted yet.
928:               
929:               
930:                   Typical Usage
931:                   <code>
932:                   //make sure that the we are in the configured state
933:                   if(USBGetDeviceState() == CONFIGURED_STATE)
934:                   {
935:                       //make sure that the last transaction isn't busy by checking the handle
936:                       if(!USBHandleBusy(USBInHandle))
937:                       {
938:               	        //Write the new data that we wish to send to the host to the INPacket[] array
939:               	        INPacket[0] = USEFUL_APPLICATION_VALUE1;
940:               	        INPacket[1] = USEFUL_APPLICATION_VALUE2;
941:               	        //INPacket[2] = ... (fill in the rest of the packet data)
942:               	      
943:                           //Send the data contained in the INPacket[] array through endpoint "EP_NUM"
944:                           USBInHandle = USBTransferOnePacket(EP_NUM,IN_TO_HOST,(uint8_t*)&INPacket[0],sizeof(INPacket));
945:                       }
946:                   }
947:                   </code>
948:               
949:                 Conditions:
950:                   Before calling USBTransferOnePacket(), the following should be true.
951:                   1.  The USB stack has already been initialized (USBDeviceInit() was called).
952:                   2.  A transaction is not already pending on the specified endpoint.  This
953:                       is done by checking the previous request using the USBHandleBusy() 
954:                       macro (see the typical usage example).
955:                   3.  The host has already sent a set configuration request and the 
956:                       enumeration process is complete.
957:                       This can be checked by verifying that the USBGetDeviceState() 
958:                       macro returns "CONFIGURED_STATE", prior to calling 
959:                       USBTransferOnePacket().
960:                					
961:                 Input:
962:                   uint8_t ep - The endpoint number that the data will be transmitted or
963:               	          received on
964:                   uint8_t dir - The direction of the transfer
965:                              This value is either OUT_FROM_HOST or IN_TO_HOST
966:                   uint8_t* data - For IN transactions: pointer to the RAM buffer containing
967:                                the data to be sent to the host.  For OUT transactions: pointer
968:                                to the RAM buffer that the received data should get written to.
969:                  uint8_t len - Length of the data needing to be sent (for IN transactions).
970:                             For OUT transactions, the len parameter should normally be set
971:                             to the endpoint size specified in the endpoint descriptor.    
972:               
973:                 Return Values:
974:                   USB_HANDLE - handle to the transfer.  The handle is a pointer to 
975:                                the BDT entry associated with this transaction.  The
976:                                status of the transaction (ex: if it is complete or still
977:                                pending) can be checked using the USBHandleBusy() macro
978:                                and supplying the USB_HANDLE provided by
979:                                USBTransferOnePacket().
980:               
981:                 Remarks:
982:                   If calling the USBTransferOnePacket() function from within the USBCBInitEP()
983:                   callback function, the set configuration is still being processed and the
984:                   USBDeviceState may not be == CONFIGURED_STATE yet.  In this	special case, 
985:                   the USBTransferOnePacket() may still be called, but make sure that the 
986:                   endpoint has been enabled and initialized by the USBEnableEndpoint() 
987:                   function first.  
988:                   
989:                 *************************************************************************/
990:               USB_HANDLE USBTransferOnePacket(uint8_t ep,uint8_t dir,uint8_t* data,uint8_t len)
991:               {
992:                   volatile BDT_ENTRY* handle;
993:               
994:                   //If the direction is IN
995:                   if(dir != 0)
000A18  50CFE0     SUB.B W1, #0x0, [W15]
000A1A  320005     BRA Z, 0xA26
996:                   {
997:                       //point to the IN BDT of the specified endpoint
998:                       handle = pBDTEntryIn[ep];
000A1C  FB8200     ZE W0, W4
000A1E  420204     ADD W4, W4, W4
000A20  2081A5     MOV #0x81A, W5
000A22  7A0265     MOV [W5+W4], W4
000A24  370004     BRA 0xA2E
999:                   }
1000:                  else
1001:                  {
1002:                      //else point to the OUT BDT of the specified endpoint
1003:                      handle = pBDTEntryOut[ep];
000A26  FB8200     ZE W0, W4
000A28  420204     ADD W4, W4, W4
000A2A  208165     MOV #0x816, W5
000A2C  7A0265     MOV [W5+W4], W4
1004:                  }
1005:                  
1006:                  //Error checking code.  Make sure the handle (pBDTEntryIn[ep] or
1007:                  //pBDTEntryOut[ep]) is initialized before using it.
1008:                  if(handle == 0)
000A30  520F85     SUB W4, W5, [W15]
000A32  32001A     BRA Z, 0xA68
1009:                  {
1010:                      return 0;
000A2E  EB0280     CLR W5
1011:                  }
1012:              
1013:                  //Toggle the DTS bit if required
1014:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1015:                      handle->STAT.Val ^= _DTSMASK;
1016:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1017:                      if(ep != 0)
1018:                      {
1019:                          handle->STAT.Val ^= _DTSMASK;
1020:                      }
1021:                  #endif
1022:              
1023:                  //Set the data pointer, data length, and enable the endpoint
1024:                  handle->ADR = ConvertToPhysicalAddress(data);
000A34  980212     MOV W2, [W4+2]
1025:                  handle->CNT = len;
000A36  784A03     MOV.B W3, [W4]
1026:                  handle->STAT.Val &= _DTSMASK;
000A38  904294     MOV.B [W4+1], W5
000A3A  B24405     AND.B #0x40, W5
000A3C  984215     MOV.B W5, [W4+1]
1027:                  handle->STAT.Val |= (_DTSEN & _DTS_CHECKING_ENABLED);
000A3E  904294     MOV.B [W4+1], W5
000A40  A03405     BSET.B W5, #3
000A42  984215     MOV.B W5, [W4+1]
1028:                  handle->STAT.Val |= _USIE;
000A44  904294     MOV.B [W4+1], W5
000A46  A07405     BSET.B W5, #7
000A48  984215     MOV.B W5, [W4+1]
1029:              
1030:                  //Point to the next buffer for ping pong purposes.
1031:                  if(dir != OUT_FROM_HOST)
000A4A  50CFE0     SUB.B W1, #0x0, [W15]
000A4C  320007     BRA Z, 0xA5C
1032:                  {
1033:                      //toggle over the to the next buffer for an IN endpoint
1034:                      USBAdvancePingPongBuffer(&pBDTEntryIn[ep]);      
000A4E  FB8000     ZE W0, W0
000A50  400000     ADD W0, W0, W0
000A52  2081A5     MOV #0x81A, W5
000A54  400005     ADD W0, W5, W0
000A56  A22410     BTG.B [W0], #2
1035:                  }
1036:                  else
1037:                  {
1038:                      //toggle over the to the next buffer for an OUT endpoint
1039:                      USBAdvancePingPongBuffer(&pBDTEntryOut[ep]);     
000A5C  FB8000     ZE W0, W0
000A5E  400000     ADD W0, W0, W0
000A60  208165     MOV #0x816, W5
000A62  400005     ADD W0, W5, W0
000A64  A22410     BTG.B [W0], #2
1040:                  }
1041:                  return (USB_HANDLE)handle;
000A58  780284     MOV W4, W5
000A5A  370006     BRA 0xA68
000A66  780284     MOV W4, W5
1042:              }
000A68  780005     MOV W5, W0
000A6A  060000     RETURN
1043:              
1044:              
1045:              /********************************************************************
1046:                  Function:
1047:                      void USBStallEndpoint(uint8_t ep, uint8_t dir)
1048:                      
1049:                  Summary:
1050:                       Configures the specified endpoint to send STALL to the host, the next
1051:                       time the host tries to access the endpoint.
1052:                  
1053:                  PreCondition:
1054:                      None
1055:                      
1056:                  Parameters:
1057:                      uint8_t ep - The endpoint number that should be configured to send STALL.
1058:                      uint8_t dir - The direction of the endpoint to STALL, either
1059:                                 IN_TO_HOST or OUT_FROM_HOST.
1060:                      
1061:                  Return Values:
1062:                      None
1063:                      
1064:                  Remarks:
1065:                      None
1066:              
1067:               *******************************************************************/
1068:              void USBStallEndpoint(uint8_t ep, uint8_t dir)
1069:              {
1070:                  BDT_ENTRY *p;
1071:              
1072:                  if(ep == 0)
000A6C  504FE0     SUB.B W0, #0x0, [W15]
000A6E  3A0015     BRA NZ, 0xA9A
1073:                  {
1074:                      //For control endpoints (ex: EP0), we need to STALL both IN and OUT
1075:                      //endpoints.  EP0 OUT must also be prepared to receive the next SETUP 
1076:                      //packet that will arrrive.
1077:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000A70  B3C085     MOV #0x8, W5
000A72  805304     MOV pBDTEntryEP0OutNext, W4
000A74  784A05     MOV.B W5, [W4]
1078:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
000A76  805304     MOV pBDTEntryEP0OutNext, W4
000A78  20A4C5     MOV #0xA4C, W5
000A7A  980215     MOV W5, [W4+2]
1079:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
000A7C  B3C0C5     MOV #0xC, W5
000A7E  984215     MOV.B W5, [W4+1]
1080:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
000A80  805304     MOV pBDTEntryEP0OutNext, W4
000A82  904314     MOV.B [W4+1], W6
000A84  B3C805     MOV #0x80, W5
000A86  734305     IOR.B W6, W5, W6
000A88  984216     MOV.B W6, [W4+1]
1081:                      pBDTEntryIn[0]->STAT.Val = _BSTALL; 
000A8A  B3C046     MOV #0x4, W6
000A8C  8040D4     MOV pBDTEntryIn, W4
000A8E  984216     MOV.B W6, [W4+1]
1082:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
000A90  8040D4     MOV pBDTEntryIn, W4
000A92  904314     MOV.B [W4+1], W6
000A94  734285     IOR.B W6, W5, W5
000A96  984215     MOV.B W5, [W4+1]
000A98  370010     BRA 0xABA
1083:                             
1084:                  }
1085:                  else
1086:                  {
1087:                      p = (BDT_ENTRY*)(&BDT[EP(ep,dir,0)]);
000A9A  FB8201     ZE W1, W4
000A9C  FB8000     ZE W0, W0
000A9E  400000     ADD W0, W0, W0
000AA0  420200     ADD W4, W0, W4
000AA2  DD2243     SL W4, #3, W4
000AA4  20C006     MOV #0xC00, W6
000AA6  420386     ADD W4, W6, W7
1088:                      p->STAT.Val |= _BSTALL;
1089:                      p->STAT.Val |= _USIE;
000AA8  904017     MOV.B [W7+1], W0
000AAA  B3C845     MOV #0x84, W5
000AAC  704005     IOR.B W0, W5, W0
000AAE  984390     MOV.B W0, [W7+1]
1090:                  
1091:                      //If the device is in FULL or ALL_BUT_EP0 ping pong modes
1092:                      //then stall that entry as well
1093:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1094:                      p = (BDT_ENTRY*)(&BDT[EP(ep,dir,1)]);
000AB0  420264     ADD W4, #0x4, W4
000AB2  420206     ADD W4, W6, W4
1095:                      p->STAT.Val |= _BSTALL;
1096:                      p->STAT.Val |= _USIE;
000AB4  904314     MOV.B [W4+1], W6
000AB6  734285     IOR.B W6, W5, W5
000AB8  984215     MOV.B W5, [W4+1]
1097:                      #endif
1098:                  }
1099:              }
000ABA  060000     RETURN
1100:              
1101:              /**************************************************************************
1102:                  Function:
1103:                      void USBCancelIO(uint8_t endpoint)
1104:                  
1105:                  Description:
1106:                      This function cancels the transfers pending on the specified endpoint.
1107:                      This function can only be used after a SETUP packet is received and 
1108:                      before that setup packet is handled.  This is the time period in which
1109:                      the EVENT_EP0_REQUEST is thrown, before the event handler function
1110:                      returns to the stack.
1111:              
1112:                  Precondition:
1113:                
1114:                  Parameters:
1115:                      uint8_t endpoint - the endpoint number you wish to cancel the transfers for
1116:                   
1117:                  Return Values:
1118:                      None
1119:                      
1120:                  Remarks:
1121:                      None
1122:                                                                        
1123:                **************************************************************************/
1124:              void USBCancelIO(uint8_t endpoint)
1125:              {
1126:                  if(USBPacketDisable == 1)
000ABC  200205     MOV #0x20, W5
000ABE  8024A4     MOV U1CON, W4
000AC0  628284     AND W5, W4, W5
000AC2  528FE0     SUB W5, #0x0, [W15]
000AC4  320018     BRA Z, 0xAF6
1127:                  {
1128:                  	//The PKTDIS bit is currently set right now.  It is therefore "safe"
1129:                  	//to mess with the BDT right now.
1130:                  	pBDTEntryIn[endpoint]->Val &= _DTSMASK;	//Makes UOWN = 0 (_UCPU mode).  Deactivates endpoint.  Only sends NAKs.
000AC6  FB8200     ZE W0, W4
000AC8  420204     ADD W4, W4, W4
000ACA  2081A5     MOV #0x81A, W5
000ACC  428204     ADD W5, W4, W4
000ACE  780314     MOV [W4], W6
000AD0  BE0116     MOV.D [W6], W2
000AD2  200400     MOV #0x40, W0
000AD4  200001     MOV #0x0, W1
000AD6  600102     AND W0, W2, W2
000AD8  200003     MOV #0x0, W3
000ADA  BE8B02     MOV.D W2, [W6]
1131:                  	pBDTEntryIn[endpoint]->Val ^= _DTSMASK;	//Toggle the DTS bit.  This packet didn't get sent yet, and the next call to USBTransferOnePacket() will re-toggle the DTS bit back to the original (correct) value.
000ADC  780314     MOV [W4], W6
000ADE  BE0116     MOV.D [W6], W2
000AE0  691B00     XOR W2, W0, [W6++]
000AE2  699301     XOR W3, W1, [W6--]
1132:                  	
1133:                  	//Need to do additional handling if ping-pong buffering is being used
1134:                      #if ((USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0))
1135:                      //Point to the next buffer for ping pong purposes.  UOWN getting cleared
1136:                      //(either due to SIE clearing it after a transaction, or the firmware
1137:                      //clearing it) makes hardware ping pong pointer advance.
1138:                      USBAdvancePingPongBuffer(&pBDTEntryIn[endpoint]);       
000AE4  A22414     BTG.B [W4], #2
1139:                  
1140:                  	pBDTEntryIn[endpoint]->STAT.Val &= _DTSMASK;
000AE6  780314     MOV [W4], W6
000AE8  904396     MOV.B [W6+1], W7
000AEA  B24407     AND.B #0x40, W7
000AEC  984317     MOV.B W7, [W6+1]
1141:                  	pBDTEntryIn[endpoint]->STAT.Val ^= _DTSMASK;
000AEE  780214     MOV [W4], W4
000AF0  904314     MOV.B [W4+1], W6
000AF2  6B4280     XOR.B W6, W0, W5
000AF4  984215     MOV.B W5, [W4+1]
1142:                      #endif
1143:                  }
1144:              }
000AF6  060000     RETURN
1145:              
1146:              /**************************************************************************
1147:                  Function:
1148:                      void USBDeviceDetach(void)
1149:                 
1150:                  Summary:
1151:                      This function configures the USB module to "soft detach" itself from
1152:                      the USB host.
1153:                      
1154:                  Description:
1155:                      This function configures the USB module to perform a "soft detach"
1156:                      operation, by disabling the D+ (or D-) ~1.5k pull up resistor, which
1157:                      lets the host know the device is present and attached.  This will make
1158:                      the host think that the device has been unplugged.  This is potentially
1159:                      useful, as it allows the USB device to force the host to re-enumerate
1160:                      the device (on the firmware has re-enabled the USB module/pull up, by
1161:                      calling USBDeviceAttach(), to "soft re-attach" to the host).
1162:                      
1163:                  Precondition:
1164:                      Should only be called when USB_INTERRUPT is defined.  See remarks
1165:                      section if USB_POLLING mode option is being used (usb_config.h option).
1166:              
1167:                      Additionally, this function should only be called from the main() loop 
1168:                      context.  Do not call this function from within an interrupt handler, as 
1169:                      this function may modify global interrupt enable bits and settings.
1170:                      
1171:                  Parameters:
1172:                      None
1173:                   
1174:                  Return Values:
1175:                      None
1176:                      
1177:                  Remarks:
1178:                      If the application firmware calls USBDeviceDetach(), it is strongly
1179:                      recommended that the firmware wait at least >= 80ms before calling
1180:                      USBDeviceAttach().  If the firmeware performs a soft detach, and then
1181:                      re-attaches too soon (ex: after a few micro seconds for instance), some
1182:                      hosts may interpret this as an unexpected "glitch" rather than as a
1183:                      physical removal/re-attachment of the USB device.  In this case the host
1184:                      may simply ignore the event without re-enumerating the device.  To 
1185:                      ensure that the host properly detects and processes the device soft
1186:                      detach/re-attach, it is recommended to make sure the device remains 
1187:                      detached long enough to mimic a real human controlled USB 
1188:                      unplug/re-attach event (ex: after calling USBDeviceDetach(), do not
1189:                      call USBDeviceAttach() for at least 80+ms, preferrably longer.
1190:                      
1191:                      Neither the USBDeviceDetach() or USBDeviceAttach() functions are blocking
1192:                      or take long to execute.  It is the application firmware's 
1193:                      responsibility for adding the 80+ms delay, when using these API 
1194:                      functions.
1195:                      
1196:                      Note: The Windows plug and play event handler processing is fairly 
1197:                      slow, especially in certain versions of Windows, and for certain USB
1198:                      device classes.  It has been observed that some device classes need to
1199:                      provide even more USB detach dwell interval (before calling 
1200:                      USBDeviceAttach()), in order to work correctly after re-enumeration.
1201:                      If the USB device is a CDC class device, it is recommended to wait
1202:                      at least 1.5 seconds or longer, before soft re-attaching to the host,
1203:                      to provide the plug and play event handler enough time to finish 
1204:                      processing the removal event, before the re-attach occurs.
1205:                      
1206:                      If the application is using the USB_POLLING mode option, then the 
1207:                      USBDeviceDetach() and USBDeviceAttach() functions are not available.  
1208:                      In this mode, the USB stack relies on the "#define USE_USB_BUS_SENSE_IO" 
1209:                      and "#define USB_BUS_SENSE" options in the 
1210:                      HardwareProfile ?? [platform name].h file. 
1211:              
1212:                      When using the USB_POLLING mode option, and the 
1213:                      "#define USE_USB_BUS_SENSE_IO" definition has been commented out, then 
1214:                      the USB stack assumes that it should always enable the USB module at 
1215:                      pretty much all times.  Basically, anytime the application firmware 
1216:                      calls USBDeviceTasks(), the firmware will automatically enable the USB 
1217:                      module.  This mode would typically be selected if the application was 
1218:                      designed to be a purely bus powered device.  In this case, the 
1219:                      application is powered from the +5V VBUS supply from the USB port, so 
1220:                      it is correct and sensible in this type of application to power up and 
1221:                      turn on the USB module, at anytime that the microcontroller is 
1222:                      powered (which implies the USB cable is attached and the host is also 
1223:                      powered).
1224:              
1225:                      In a self powered application, the USB stack is designed with the 
1226:                      intention that the user will enable the "#define USE_USB_BUS_SENSE_IO" 
1227:                      option in the HardwareProfile ?? [platform name].h file.  When this 
1228:                      option is defined, then the USBDeviceTasks() function will automatically 
1229:                      check the I/O pin port value of the designated pin (based on the 
1230:                      #define USB_BUS_SENSE option in the HardwareProfile ?? [platform name].h 
1231:                      file), every time the application calls USBDeviceTasks().  If the 
1232:                      USBDeviceTasks() function is executed and finds that the pin defined by 
1233:                      the #define USB_BUS_SENSE is in a logic low state, then it will 
1234:                      automatically disable the USB module and tri-state the D+ and D- pins.  
1235:                      If however the USBDeviceTasks() function is executed and finds the pin 
1236:                      defined by the #define USB_BUS_SENSE is in a logic high state, then it 
1237:                      will automatically enable the USB module, if it has not already been 
1238:                      enabled.        
1239:                                                                        
1240:                **************************************************************************/
1241:              #if defined(USB_INTERRUPT)
1242:              void USBDeviceDetach(void)
1243:              {
1244:                  //If the interrupt option is selected then the customer is required
1245:                  //  to notify the stack when the device is attached or removed from the
1246:                  //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
1247:              #ifdef USB_SUPPORT_OTG
1248:                  if (USB_BUS_SENSE != 1)
1249:              #endif
1250:                  {
1251:                       // Disable module & detach from bus
1252:                       U1CON = 0;             
000AF8  EB0200     CLR W4
000AFA  8824A4     MOV W4, U1CON
1253:              
1254:                       // Mask all USB interrupts              
1255:                       U1IE = 0;          
000AFC  882464     MOV W4, U1IE
1256:              
1257:                       //Move to the detached state                  
1258:                       USBDeviceState = DETACHED_STATE;
000AFE  884064     MOV W4, USBDeviceState
1259:              
1260:                       #ifdef  USB_SUPPORT_OTG    
1261:                           //Disable D+ Pullup
1262:                           U1OTGCONbits.DPPULUP = 0;
1263:              
1264:                           //Disable HNP
1265:                           USBOTGDisableHnp();
1266:              
1267:                           //Deactivate HNP
1268:                           USBOTGDeactivateHnp();
1269:                           
1270:                           //If ID Pin Changed State
1271:                           if (USBIDIF && USBIDIE)
1272:                           {  
1273:                               //Re-detect & Initialize
1274:                                USBOTGInitialize();
1275:              
1276:                                //Clear ID Interrupt Flag
1277:                                USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
1278:                           }
1279:                       #endif
1280:              
1281:                       #if defined __C30__ || defined __XC16__
1282:                           //USBClearInterruptFlag(U1OTGIR, 3); 
1283:                       #endif
1284:                          //return so that we don't go through the rest of 
1285:                          //the state machine
1286:                        return;
1287:                  }
1288:              
1289:              #ifdef USB_SUPPORT_OTG
1290:                  //If Session Is Started Then
1291:                 else
1292:                 {
1293:                      //If SRP Is Ready
1294:                      if (USBOTGSRPIsReady())
1295:                      {   
1296:                          //Clear SRPReady
1297:                          USBOTGClearSRPReady();
1298:              
1299:                          //Clear SRP Timeout Flag
1300:                          USBOTGClearSRPTimeOutFlag();
1301:              
1302:                          //Indicate Session Started
1303:                          UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
1304:                      }
1305:                  }
1306:              #endif
1307:              }
000B00  060000     RETURN
1308:              #endif  //#if defined(USB_INTERRUPT)
1309:              /**************************************************************************
1310:                  Function:
1311:                      void USBDeviceAttach(void)
1312:                  
1313:                  Summary:
1314:                      Checks if VBUS is present, and that the USB module is not already 
1315:                      initalized, and if so, enables the USB module so as to signal device 
1316:                      attachment to the USB host.   
1317:              
1318:                  Description:
1319:                      This function indicates to the USB host that the USB device has been
1320:                      attached to the bus.  This function needs to be called in order for the
1321:                      device to start to enumerate on the bus.
1322:                              
1323:                  Precondition:
1324:                      Should only be called when USB_INTERRUPT is defined.  Also, should only 
1325:                      be called from the main() loop context.  Do not call USBDeviceAttach()
1326:                      from within an interrupt handler, as the USBDeviceAttach() function
1327:                      may modify global interrupt enable bits and settings.
1328:              
1329:                      For normal USB devices:
1330:                      Make sure that if the module was previously on, that it has been turned off 
1331:                      for a long time (ex: 100ms+) before calling this function to re-enable the module.
1332:                      If the device turns off the D+ (for full speed) or D- (for low speed) ~1.5k ohm
1333:                      pull up resistor, and then turns it back on very quickly, common hosts will sometimes 
1334:                      reject this event, since no human could ever unplug and reattach a USB device in a 
1335:                      microseconds (or nanoseconds) timescale.  The host could simply treat this as some kind 
1336:                      of glitch and ignore the event altogether.  
1337:                  Parameters:
1338:                      None
1339:                   
1340:                  Return Values:
1341:                      None       
1342:                  
1343:                  Remarks: 
1344:              		See also the USBDeviceDetach() API function documentation.                                                 
1345:              ****************************************************************************/
1346:              #if defined(USB_INTERRUPT)
1347:              void USBDeviceAttach(void)
1348:              {
1349:                  //if we are in the detached state
1350:                  if(USBDeviceState == DETACHED_STATE)
000B02  804064     MOV USBDeviceState, W4
000B04  520FE0     SUB W4, #0x0, [W15]
000B06  3A0011     BRA NZ, 0xB2A
1351:                  {
1352:                      if(USB_BUS_SENSE == 1)
1353:                      {
1354:                  	    //Initialize registers to known states.
1355:                          U1CON = 0;          
000B08  8824A4     MOV W4, U1CON
1356:                  
1357:                          // Mask all USB interrupts
1358:                          U1IE = 0;                                
000B0A  882464     MOV W4, U1IE
1359:                  
1360:                          //Configure things like: pull ups, full/low-speed mode, 
1361:                          //set the ping pong mode, and set internal transceiver
1362:                          SetConfigurationOptions();
000B0C  200025     MOV #0x2, W5
000B0E  882535     MOV W5, U1CNFG1
000B10  882544     MOV W4, U1CNFG2
000B12  A94486     BCLR U1OTGCON, #2
000B14  2009F4     MOV #0x9F, W4
000B16  882484     MOV W4, U1EIE
000B18  882464     MOV W4, U1IE
1363:                  
1364:                          USBEnableInterrupts();  //Modifies global interrupt settings
000B1A  A8C09E     BSET IEC5, #6
1365:                  
1366:                          // Enable module & attach to bus
1367:                          while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
000B1C  AB0494     BTST U1CON, #0
000B1E  3A0003     BRA NZ, 0xB26
000B20  A80494     BSET U1CON, #0
000B22  AB0494     BTST U1CON, #0
000B24  32FFFD     BRA Z, 0xB20
1368:                  
1369:                          //moved to the attached state
1370:                          USBDeviceState = ATTACHED_STATE;
000B26  200014     MOV #0x1, W4
000B28  884064     MOV W4, USBDeviceState
1371:                  
1372:                          #ifdef  USB_SUPPORT_OTG
1373:                              U1OTGCON = USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
1374:                          #endif
1375:                      }
1376:                  }
1377:              }
000B2A  060000     RETURN
1378:              #endif  //#if defined(USB_INTERRUPT)
1379:              
1380:              
1381:              /*******************************************************************************
1382:                Function: void USBCtrlEPAllowStatusStage(void);
1383:              
1384:                Summary: This function prepares the proper endpoint 0 IN or endpoint 0 OUT
1385:                          (based on the controlTransferState) to allow the status stage packet
1386:                          of a control transfer to complete.  This function gets used
1387:                          internally by the USB stack itself, but it may also be called from
1388:                          the application firmware, IF the application firmware called
1389:                          the USBDeferStatusStage() function during the initial processing
1390:                          of the control transfer request.  In this case, the application
1391:                          must call the USBCtrlEPAllowStatusStage() once, after it has fully
1392:                          completed processing and handling the data stage portion of the
1393:                          request.
1394:              
1395:                          If the application firmware has no need for delaying control
1396:                          transfers, and therefore never calls USBDeferStatusStage(), then the
1397:                          application firmware should not call USBCtrlEPAllowStatusStage().
1398:              
1399:                Description:
1400:              
1401:                Conditions:
1402:                  None
1403:              
1404:                Input:
1405:              
1406:                Return:
1407:              
1408:                Remarks:
1409:                  None
1410:                *****************************************************************************/
1411:              void USBCtrlEPAllowStatusStage(void)
1412:              {
1413:                  //Check and set two flags, prior to actually modifying any BDT entries.
1414:                  //This double checking is necessary to make certain that 
1415:                  //USBCtrlEPAllowStatusStage() can be called twice simultaneously (ex: once 
1416:                  //in main loop context, while simultaneously getting an interrupt which 
1417:                  //tries to call USBCtrlEPAllowStatusStage() again, at the same time).
1418:                  if(USBStatusStageEnabledFlag1 == false)
000B2C  20A6E4     MOV #0xA6E, W4
000B2E  784214     MOV.B [W4], W4
000B30  524FE0     SUB.B W4, #0x0, [W15]
000B32  3A002E     BRA NZ, 0xB90
1419:                  {
1420:                      USBStatusStageEnabledFlag1 = true;
000B34  B3C010     MOV #0x1, W0
000B36  B7EA6E     MOV.B WREG, USBStatusStageEnabledFlag1
1421:                      if(USBStatusStageEnabledFlag2 == false)
000B38  20A6F4     MOV #0xA6F, W4
000B3A  784214     MOV.B [W4], W4
000B3C  524FE0     SUB.B W4, #0x0, [W15]
000B3E  3A0028     BRA NZ, 0xB90
1422:                      {
1423:                          USBStatusStageEnabledFlag2 = true;
000B40  B7EA6F     MOV.B WREG, USBStatusStageEnabledFlag2
1424:                      
1425:                          //Determine which endpoints (EP0 IN or OUT needs arming for the status
1426:                          //stage), based on the type of control transfer currently pending.
1427:                          if(controlTransferState == CTRL_TRF_RX)
000B42  20A634     MOV #0xA63, W4
000B44  784214     MOV.B [W4], W4
000B46  524FE2     SUB.B W4, #0x2, [W15]
000B48  3A000A     BRA NZ, 0xB5E
1428:                          {
1429:                              pBDTEntryIn[0]->CNT = 0;
000B4A  8040D4     MOV pBDTEntryIn, W4
000B4C  EB4A00     CLR.B [W4]
1430:                              pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);        
000B4E  B3C485     MOV #0x48, W5
000B50  8040D4     MOV pBDTEntryIn, W4
000B52  984215     MOV.B W5, [W4+1]
1431:                              pBDTEntryIn[0]->STAT.Val |= _USIE;
000B54  8040D4     MOV pBDTEntryIn, W4
000B56  904294     MOV.B [W4+1], W5
000B58  A07405     BSET.B W5, #7
000B5A  984215     MOV.B W5, [W4+1]
000B5C  370019     BRA 0xB90
1432:                          }
1433:                          else if(controlTransferState == CTRL_TRF_TX)
000B5E  20A634     MOV #0xA63, W4
000B60  784214     MOV.B [W4], W4
000B62  524FE1     SUB.B W4, #0x1, [W15]
000B64  3A0015     BRA NZ, 0xB90
1434:                          {
1435:                              BothEP0OutUOWNsSet = false;	//Indicator flag used in USBCtrlTrfOutHandler()
000B66  EF6A68     CLR.B BothEP0OutUOWNsSet
1436:              
1437:                              //This buffer (when ping pong buffering is enabled on EP0 OUT) receives the
1438:                              //next SETUP packet.
1439:                              #if((USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG))
1440:                                  pBDTEntryEP0OutCurrent->CNT = USB_EP0_BUFF_SIZE;
000B68  B3C084     MOV #0x8, W4
000B6A  8052F5     MOV pBDTEntryEP0OutCurrent, W5
000B6C  784A84     MOV.B W4, [W5]
1441:                                  pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
000B6E  8052F5     MOV pBDTEntryEP0OutCurrent, W5
000B70  20A4C6     MOV #0xA4C, W6
000B72  980296     MOV W6, [W5+2]
1442:                                  pBDTEntryEP0OutCurrent->STAT.Val = _BSTALL; //Prepare endpoint to accept a SETUP transaction
000B74  B3C047     MOV #0x4, W7
000B76  984297     MOV.B W7, [W5+1]
1443:                                  pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
000B78  8052F7     MOV pBDTEntryEP0OutCurrent, W7
000B7A  904017     MOV.B [W7+1], W0
000B7C  B3C805     MOV #0x80, W5
000B7E  704005     IOR.B W0, W5, W0
000B80  984390     MOV.B W0, [W7+1]
1444:                                  BothEP0OutUOWNsSet = true;	//Indicator flag used in USBCtrlTrfOutHandler()
000B82  B3C010     MOV #0x1, W0
000B84  B7EA68     MOV.B WREG, BothEP0OutUOWNsSet
1445:                              #endif
1446:              
1447:                              //This EP0 OUT buffer receives the 0-byte OUT status stage packet.
1448:                              pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000B86  805307     MOV pBDTEntryEP0OutNext, W7
000B88  784B84     MOV.B W4, [W7]
1449:                              pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
000B8A  805304     MOV pBDTEntryEP0OutNext, W4
000B8C  980216     MOV W6, [W4+2]
1450:                              pBDTEntryEP0OutNext->STAT.Val = _USIE;           // Note: DTSEN is 0
000B8E  984215     MOV.B W5, [W4+1]
1451:                          }
1452:                      }    
1453:                  }
1454:              }   
000B90  060000     RETURN
1455:              
1456:              
1457:              /*******************************************************************************
1458:                Function: void USBCtrlEPAllowDataStage(void);
1459:                  
1460:                Summary: This function allows the data stage of either a host-to-device or
1461:                          device-to-host control transfer (with data stage) to complete.
1462:                          This function is meant to be used in conjunction with either the
1463:                          USBDeferOUTDataStage() or USBDeferINDataStage().  If the firmware
1464:                          does not call either USBDeferOUTDataStage() or USBDeferINDataStage(),
1465:                          then the firmware does not need to manually call 
1466:                          USBCtrlEPAllowDataStage(), as the USB stack will call this function
1467:                          instead.
1468:                   
1469:                Description:
1470:                  
1471:                Conditions: A control transfer (with data stage) should already be pending, 
1472:                              if the firmware calls this function.  Additionally, the firmware
1473:                              should have called either USBDeferOUTDataStage() or 
1474:                              USBDeferINDataStage() at the start of the control transfer, if
1475:                              the firmware will be calling this function manually.
1476:              
1477:                Input:
1478:              
1479:                Return:
1480:              
1481:                Remarks: 
1482:                *****************************************************************************/
1483:              void USBCtrlEPAllowDataStage(void)
1484:              {
1485:                  USBDeferINDataStagePackets = false;
000CC2  B3C000     MOV #0x0, W0
000CC4  B7E802     MOV.B WREG, USBDeferINDataStagePackets
000CC6  B7E800     MOV.B WREG, USBDeferOUTDataStagePackets
1486:                  USBDeferOUTDataStagePackets = false;
1487:              
1488:                  if(controlTransferState == CTRL_TRF_RX) //(<setup><out><out>...<out><in>)
000CC8  20A634     MOV #0xA63, W4
000CCA  784214     MOV.B [W4], W4
000CCC  524FE2     SUB.B W4, #0x2, [W15]
000CCE  3A000D     BRA NZ, 0xCEA
1489:                  {
1490:                      //Prepare EP0 OUT to receive the first OUT data packet in the data stage sequence.
1491:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000CD0  B3C085     MOV #0x8, W5
000CD2  805304     MOV pBDTEntryEP0OutNext, W4
000CD4  784A05     MOV.B W5, [W4]
1492:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
000CD6  805304     MOV pBDTEntryEP0OutNext, W4
000CD8  20A545     MOV #0xA54, W5
000CDA  980215     MOV W5, [W4+2]
1493:                      pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
000CDC  B3C485     MOV #0x48, W5
000CDE  984215     MOV.B W5, [W4+1]
1494:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
000CE0  805304     MOV pBDTEntryEP0OutNext, W4
000CE2  904294     MOV.B [W4+1], W5
000CE4  A07405     BSET.B W5, #7
000CE6  984215     MOV.B W5, [W4+1]
000CE8  37001C     BRA 0xD22
1495:                  }   
1496:                  else    //else must be controlTransferState == CTRL_TRF_TX (<setup><in><in>...<in><out>)
1497:                  {
1498:                      //Error check the data stage byte count.  Make sure the user specified
1499:                      //value was no greater than the number of bytes the host requested.
1500:              		if(SetupPkt.wLength < inPipes[0].wCount.Val)
000CEA  20A524     MOV #0xA52, W4
000CEC  784214     MOV.B [W4], W4
000CEE  FB8204     ZE W4, W4
000CF0  20A535     MOV #0xA53, W5
000CF2  784295     MOV.B [W5], W5
000CF4  DD2AC8     SL W5, #8, W5
000CF6  728284     IOR W5, W4, W5
000CF8  804044     MOV 0x808, W4
000CFA  528F84     SUB W5, W4, [W15]
000CFC  310008     BRA C, 0xD0E
1501:              		{
1502:              			inPipes[0].wCount.Val = SetupPkt.wLength;
000CFE  20A525     MOV #0xA52, W5
000D00  784295     MOV.B [W5], W5
000D02  FB8285     ZE W5, W5
000D04  20A534     MOV #0xA53, W4
000D06  784214     MOV.B [W4], W4
000D08  DD2248     SL W4, #8, W4
000D0A  720205     IOR W4, W5, W4
000D0C  884044     MOV W4, 0x808
1503:              		}
1504:              		USBCtrlTrfTxService();  //Copies one IN data packet worth of data from application buffer
000D0E  07FBC5     RCALL _USBCtrlTrfTxService
1505:              		                        //to CtrlTrfData buffer.  Also keeps track of how many bytes remaining.
1506:              
1507:              	    //Cnt should have been initialized by responsible request owner (ex: by
1508:              	    //using the USBEP0SendRAMPtr() or USBEP0SendROMPtr() API function).
1509:              		pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
000D10  8040D4     MOV pBDTEntryIn, W4
000D12  20A545     MOV #0xA54, W5
000D14  980215     MOV W5, [W4+2]
1510:              		pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
000D16  B3C485     MOV #0x48, W5
000D18  984215     MOV.B W5, [W4+1]
1511:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
000D1A  8040D4     MOV pBDTEntryIn, W4
000D1C  904294     MOV.B [W4+1], W5
000D1E  A07405     BSET.B W5, #7
000D20  984215     MOV.B W5, [W4+1]
1512:                  }     
1513:              }    
000D22  060000     RETURN
1514:              
1515:              
1516:              /******************************************************************************/
1517:              /** Internal Functions *********************************************************/
1518:              /******************************************************************************/
1519:              
1520:              /********************************************************************
1521:               * Function:        void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
1522:               *
1523:               * PreCondition:    None
1524:               *
1525:               * Input:           uint8_t EPNum - the endpoint to be configured
1526:               *                  uint8_t direction - the direction to be configured
1527:               *                                   (either OUT_FROM_HOST or IN_TO_HOST)
1528:               *
1529:               * Output:          None
1530:               *
1531:               * Side Effects:    None
1532:               *
1533:               * Overview:        This function will configure the specified 
1534:               *                  endpoint
1535:               *
1536:               * Note:            None
1537:               *******************************************************************/
1538:              static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
1539:              {
1540:                  volatile BDT_ENTRY* handle;
1541:              
1542:                  //Compute a pointer to the even BDT entry corresponding to the
1543:                  //EPNum and direction values passed to this function.
1544:                  handle = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN]; //Get address of start of BDT
1545:                  handle += EP(EPNum,direction,0u);     //Add in offset to the BDT of interest
000470  FB8000     ZE W0, W0
000472  FB8281     ZE W1, W5
000474  400200     ADD W0, W0, W4
000476  428204     ADD W5, W4, W4
000478  DD2243     SL W4, #3, W4
00047A  20C005     MOV #0xC00, W5
00047C  420205     ADD W4, W5, W4
1546:                  
1547:                  handle->STAT.UOWN = 0;  //mostly redundant, since USBStdSetCfgHandler() 
00047E  A1F014     BCLR [W4], #15
1548:                  //already cleared the entire BDT table
1549:              
1550:                  //Make sure our pBDTEntryIn/Out[] pointer is initialized.  Needed later
1551:                  //for USBTransferOnePacket() API calls.
1552:                  if(direction == OUT_FROM_HOST)
000480  50CFE0     SUB.B W1, #0x0, [W15]
000482  3A0004     BRA NZ, 0x48C
1553:                  {
1554:                      pBDTEntryOut[EPNum] = handle;
000484  400000     ADD W0, W0, W0
000486  208165     MOV #0x816, W5
000488  783284     MOV W4, [W5+W0]
00048A  370003     BRA 0x492
1555:                  }
1556:                  else
1557:                  {
1558:                      pBDTEntryIn[EPNum] = handle;
00048C  400000     ADD W0, W0, W0
00048E  2081A5     MOV #0x81A, W5
000490  783284     MOV W4, [W5+W0]
1559:                  }
1560:              
1561:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
1562:                      handle->STAT.DTS = 0;
000492  A1E014     BCLR [W4], #14
1563:                      (handle+1)->STAT.DTS = 1;
000494  420264     ADD W4, #0x4, W4
000496  A0E014     BSET [W4], #14
1564:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1565:                      //Set DTS to one because the first thing we will do
1566:                      //when transmitting is toggle the bit
1567:                      handle->STAT.DTS = 1;
1568:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1569:                      if(EPNum != 0)
1570:                      {
1571:                          handle->STAT.DTS = 1;
1572:                      }
1573:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)    
1574:                      if(EPNum != 0)
1575:                      {
1576:                          handle->STAT.DTS = 0;
1577:                          (handle+1)->STAT.DTS = 1;
1578:                      }
1579:                  #endif
1580:              }
000498  060000     RETURN
1581:              
1582:              
1583:              /******************************************************************************
1584:               * Function:        void USBCtrlEPServiceComplete(void)
1585:               *
1586:               * PreCondition:    None
1587:               *
1588:               * Input:           None
1589:               *
1590:               * Output:          None
1591:               *
1592:               * Side Effects:    None
1593:               *
1594:               * Overview:        This routine wrap up the remaining tasks in servicing
1595:               *                  a Setup Request. Its main task is to set the endpoint
1596:               *                  controls appropriately for a given situation. See code
1597:               *                  below.
1598:               *                  There are three main scenarios:
1599:               *                  a) There was no handler for the Request, in this case
1600:               *                     a STALL should be sent out.
1601:               *                  b) The host has requested a read control transfer,
1602:               *                     endpoints are required to be setup in a specific way.
1603:               *                  c) The host has requested a write control transfer, or
1604:               *                     a control data stage is not required, endpoints are
1605:               *                     required to be setup in a specific way.
1606:               *
1607:               *                  Packet processing is resumed by clearing PKTDIS bit.
1608:               *
1609:               * Note:            None
1610:               *****************************************************************************/
1611:              static void USBCtrlEPServiceComplete(void)
1612:              {
1613:                  /*
1614:                   * PKTDIS bit is set when a Setup Transaction is received.
1615:                   * Clear to resume packet processing.
1616:                   */
1617:                  USBPacketDisable = 0;
000D24  A9A494     BCLR U1CON, #5
1618:              
1619:              	//Check the busy bits and the SetupPtk.DataDir variables to determine what type of
1620:              	//control transfer is currently in progress.  We need to know the type of control
1621:              	//transfer that is currently pending, in order to know how to properly arm the 
1622:              	//EP0 IN and EP0 OUT endpoints.
1623:                  if(inPipes[0].info.bits.busy == 0)
000D26  200804     MOV #0x80, W4
000D28  804030     MOV 0x806, W0
000D2A  620200     AND W4, W0, W4
000D2C  520FE0     SUB W4, #0x0, [W15]
000D2E  3A0024     BRA NZ, 0xD78
1624:                  {
1625:                      if(outPipes[0].info.bits.busy == 1)
000D30  208114     MOV #0x811, W4
000D32  784214     MOV.B [W4], W4
000D34  524FE0     SUB.B W4, #0x0, [W15]
000D36  3D000B     BRA GE, 0xD4E
1626:                      {
1627:                          controlTransferState = CTRL_TRF_RX;
000D38  B3C020     MOV #0x2, W0
000D3A  B7EA63     MOV.B WREG, controlTransferState
1628:                          /*
1629:                           * Control Write:
1630:                           * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
1631:                           */
1632:              
1633:                          //1. Prepare OUT EP to receive data, unless a USB class request handler
1634:                          //   function decided to defer the data stage (ex: because the intended
1635:                          //   RAM buffer wasn't available yet) by calling USBDeferDataStage().
1636:                          //   If it did so, it is then responsible for calling USBCtrlEPAllowDataStage(),
1637:                          //   once it is ready to begin receiving the data.
1638:                          if(USBDeferOUTDataStagePackets == false)
000D3C  208004     MOV #0x800, W4
000D3E  784214     MOV.B [W4], W4
000D40  524FE0     SUB.B W4, #0x0, [W15]
000D42  3A0001     BRA NZ, 0xD46
1639:                          {
1640:                              USBCtrlEPAllowDataStage();
000D44  07FFBE     RCALL USBCtrlEPAllowDataStage
1641:                          }
1642:                          
1643:                          //2.  IN endpoint 0 status stage will be armed by USBCtrlEPAllowStatusStage() 
1644:                          //after all of the OUT data has been received and consumed, or if a timeout occurs.
1645:                          USBStatusStageEnabledFlag2 = false;
000D46  B3C000     MOV #0x0, W0
000D48  B7EA6F     MOV.B WREG, USBStatusStageEnabledFlag2
000D4A  B7EA6E     MOV.B WREG, USBStatusStageEnabledFlag1
000D4C  37003F     BRA 0xDCC
1646:                          USBStatusStageEnabledFlag1 = false;
1647:                      }
1648:                      else
1649:                      {
1650:                          /*
1651:                           * If no one knows how to service this request then stall.
1652:                           * Must also prepare EP0 to receive the next SETUP transaction.
1653:                           */
1654:                          pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000D4E  B3C085     MOV #0x8, W5
000D50  805304     MOV pBDTEntryEP0OutNext, W4
000D52  784A05     MOV.B W5, [W4]
1655:                          pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
000D54  805304     MOV pBDTEntryEP0OutNext, W4
000D56  20A4C5     MOV #0xA4C, W5
000D58  980215     MOV W5, [W4+2]
1656:                          pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
000D5A  B3C0C5     MOV #0xC, W5
000D5C  984215     MOV.B W5, [W4+1]
1657:                          pBDTEntryEP0OutNext->STAT.Val |= _USIE;
000D5E  805304     MOV pBDTEntryEP0OutNext, W4
000D60  904314     MOV.B [W4+1], W6
000D62  B3C805     MOV #0x80, W5
000D64  734305     IOR.B W6, W5, W6
000D66  984216     MOV.B W6, [W4+1]
1658:                          pBDTEntryIn[0]->STAT.Val = _BSTALL;
000D68  B3C046     MOV #0x4, W6
000D6A  8040D4     MOV pBDTEntryIn, W4
000D6C  984216     MOV.B W6, [W4+1]
1659:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
000D6E  8040D4     MOV pBDTEntryIn, W4
000D70  904314     MOV.B [W4+1], W6
000D72  734285     IOR.B W6, W5, W5
000D74  984215     MOV.B W5, [W4+1]
000D76  37002A     BRA 0xDCC
1660:                      }
1661:                  }
1662:                  else    // A module has claimed ownership of the control transfer session.
1663:                  {
1664:              		if(SetupPkt.DataDir == USB_SETUP_DEVICE_TO_HOST_BITFIELD)
000D78  20A4C4     MOV #0xA4C, W4
000D7A  784214     MOV.B [W4], W4
000D7C  524FE0     SUB.B W4, #0x0, [W15]
000D7E  3D0010     BRA GE, 0xDA0
1665:              		{
1666:              			controlTransferState = CTRL_TRF_TX;
000D80  B3C010     MOV #0x1, W0
000D82  B7EA63     MOV.B WREG, controlTransferState
1667:              			/*
1668:              			 * Control Read:
1669:              			 * <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
1670:              			 *
1671:              			 * 1. Prepare IN EP to transfer data to the host.  If however the data
1672:              			 *    wasn't ready yet (ex: because the firmware needs to go and read it from
1673:              			 *    some slow/currently unavailable resource, such as an external I2C EEPconst),
1674:              			 *    Then the class request handler reponsible should call the USBDeferDataStage()
1675:              			 *    macro.  In this case, the firmware may wait up to 500ms, before it is required
1676:              			 *    to transmit the first IN data packet.  Once the data is ready, and the firmware
1677:              			 *    is ready to begin sending the data, it should then call the 
1678:              			 *    USBCtrlEPAllowDataStage() function to start the data stage.
1679:              			 */
1680:              			if(USBDeferINDataStagePackets == false)
000D84  208024     MOV #0x802, W4
000D86  784214     MOV.B [W4], W4
000D88  524FE0     SUB.B W4, #0x0, [W15]
000D8A  3A0001     BRA NZ, 0xD8E
1681:                          {
1682:                              USBCtrlEPAllowDataStage();
000D8C  07FF9A     RCALL USBCtrlEPAllowDataStage
1683:              			}
1684:              
1685:                          // 2. (Optionally) allow the status stage now, to prepare for early termination.
1686:                          //    Note: If a class request handler decided to set USBDeferStatusStagePacket == true,
1687:                          //    then it is responsible for eventually calling USBCtrlEPAllowStatusStage() once it
1688:                          //    is ready.  If the class request handler does this, it needs to be careful to
1689:                          //    be written so that it can handle the early termination scenario.
1690:                          //    Ex: It should call USBCtrlEPAllowStatusStage() when any of the following occurs:
1691:                          //    1.  The desired total number of bytes were sent to the host.
1692:                          //    2.  The number of bytes that the host originally requested (in the SETUP packet that 
1693:                          //        started the control transfer) has been reached.
1694:                          //    3.  Or, if a timeout occurs (ex: <50ms since the last successful EP0 IN transaction), regardless 
1695:                          //        of how many bytes have actually been sent.  This is necessary to prevent a deadlock situation
1696:                          //        (where the control transfer can't complete, due to continuous NAK on status stage) if the
1697:                          //        host performs early termination.  If enabled, the USB_ENABLE_STATUS_STAGE_TIMEOUTS usb_config.h
1698:                          //        option can take care of this for you.
1699:                          //    Note: For this type of control transfer, there is normally no harm in simply arming the
1700:                          //    status stage packet right now, even if the IN data is not ready yet.  This allows for
1701:                          //    immediate early termination, without adding unecessary delay.  Therefore, it is generally not
1702:                          //    recommended for the USB class handler firmware to call USBDeferStatusStage(), for this 
1703:                          //    type of control transfer.  If the USB class handler firmware needs more time to fetch the IN
1704:                          //    data that needs to be sent to the host, it should instead use the USBDeferDataStage() function.
1705:                          USBStatusStageEnabledFlag2 = false;
000D8E  B3C000     MOV #0x0, W0
000D90  B7EA6F     MOV.B WREG, USBStatusStageEnabledFlag2
000D92  B7EA6E     MOV.B WREG, USBStatusStageEnabledFlag1
1706:                          USBStatusStageEnabledFlag1 = false;
1707:                          if(USBDeferStatusStagePacket == false)
000D94  208014     MOV #0x801, W4
000D96  784214     MOV.B [W4], W4
000D98  524F80     SUB.B W4, W0, [W15]
000D9A  3A0018     BRA NZ, 0xDCC
1708:                          {
1709:                              USBCtrlEPAllowStatusStage();
000D9C  07FEC7     RCALL USBCtrlEPAllowStatusStage
000D9E  370016     BRA 0xDCC
1710:                          } 
1711:              		}
1712:              		else   // (SetupPkt.DataDir == USB_SETUP_DIRECTION_HOST_TO_DEVICE)
1713:              		{
1714:              			//This situation occurs for special types of control transfers,
1715:              			//such as that which occurs when the host sends a SET_ADDRESS
1716:              			//control transfer.  Ex:
1717:              			//
1718:              			//<SETUP[0]><IN[1]> | <SETUP[0]>
1719:              				
1720:              			//Although the data direction is HOST_TO_DEVICE, there is no data stage
1721:              			//(hence: outPipes[0].info.bits.busy == 0).  There is however still
1722:              			//an IN status stage.
1723:              
1724:              			controlTransferState = CTRL_TRF_RX;     //Since this is a HOST_TO_DEVICE control transfer
000DA0  B3C020     MOV #0x2, W0
000DA2  B7EA63     MOV.B WREG, controlTransferState
1725:              			
1726:              			//1. Prepare OUT EP to receive the next SETUP packet.
1727:              			pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000DA4  B3C085     MOV #0x8, W5
000DA6  805304     MOV pBDTEntryEP0OutNext, W4
000DA8  784A05     MOV.B W5, [W4]
1728:              			pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
000DAA  805304     MOV pBDTEntryEP0OutNext, W4
000DAC  20A4C5     MOV #0xA4C, W5
000DAE  980215     MOV W5, [W4+2]
1729:              			pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
000DB0  B3C045     MOV #0x4, W5
000DB2  984215     MOV.B W5, [W4+1]
1730:                          pBDTEntryEP0OutNext->STAT.Val |= _USIE;
000DB4  805304     MOV pBDTEntryEP0OutNext, W4
000DB6  904294     MOV.B [W4+1], W5
000DB8  A07405     BSET.B W5, #7
000DBA  984215     MOV.B W5, [W4+1]
1731:              				
1732:              			//2. Prepare for IN status stage of the control transfer
1733:                          USBStatusStageEnabledFlag2 = false;
000DBC  B3C000     MOV #0x0, W0
000DBE  B7EA6F     MOV.B WREG, USBStatusStageEnabledFlag2
000DC0  B7EA6E     MOV.B WREG, USBStatusStageEnabledFlag1
1734:                          USBStatusStageEnabledFlag1 = false;
1735:              			if(USBDeferStatusStagePacket == false)
000DC2  208014     MOV #0x801, W4
000DC4  784214     MOV.B [W4], W4
000DC6  524F80     SUB.B W4, W0, [W15]
000DC8  3A0001     BRA NZ, 0xDCC
1736:                          {
1737:                              USBCtrlEPAllowStatusStage();
000DCA  07FEB0     RCALL USBCtrlEPAllowStatusStage
1738:                          } 
1739:              		}
1740:              
1741:                  }//end if(ctrl_trf_session_owner == MUID_NULL)
1742:              
1743:              }//end USBCtrlEPServiceComplete
000DCC  060000     RETURN
1744:              
1745:              
1746:              /******************************************************************************
1747:               * Function:        void USBCtrlTrfTxService(void)
1748:               *
1749:               * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
1750:               *
1751:               * Input:           None
1752:               *
1753:               * Output:          None
1754:               *
1755:               * Side Effects:    None
1756:               *
1757:               * Overview:        This routine is used for device to host control transfers 
1758:               *					(IN transactions).  This function takes care of managing a
1759:               *                  transfer over multiple USB transactions.
1760:               *					This routine should be called from only two places.
1761:               *                  One from USBCtrlEPServiceComplete() and one from
1762:               *                  USBCtrlTrfInHandler().
1763:               *
1764:               * Note:            
1765:               *****************************************************************************/
1766:              static void USBCtrlTrfTxService(void)
1767:              {
1768:                  uint8_t byteToSend;
1769:              
1770:                  //Figure out how many bytes of data to send in the next IN transaction.
1771:                  //Assume a full size packet, unless otherwise determined below.
1772:                  byteToSend = USB_EP0_BUFF_SIZE;         
00049C  B3C084     MOV #0x8, W4
1773:                  if(inPipes[0].wCount.Val < (uint8_t)USB_EP0_BUFF_SIZE)
00049A  804045     MOV 0x808, W5
00049E  528FE7     SUB W5, #0x7, [W15]
0004A0  3E000E     BRA GTU, 0x4BE
1774:                  {
1775:                      byteToSend = inPipes[0].wCount.Val;
0004A2  804044     MOV 0x808, W4
1776:              
1777:                      //Keep track of whether or not we have sent a "short packet" yet.
1778:                      //This is useful so that later on, we can configure EP0 IN to STALL,
1779:                      //after we have sent all of the intended data.  This makes sure the
1780:                      //hardware STALLs if the host erroneously tries to send more IN token 
1781:                      //packets, requesting more data than intended in the control transfer.
1782:                      if(shortPacketStatus == SHORT_PKT_NOT_USED)
0004A4  20A625     MOV #0xA62, W5
0004A6  784295     MOV.B [W5], W5
0004A8  52CFE0     SUB.B W5, #0x0, [W15]
0004AA  3A0003     BRA NZ, 0x4B2
1783:                      {
1784:                          shortPacketStatus = SHORT_PKT_PENDING;
0004AC  B3C010     MOV #0x1, W0
0004AE  B7EA62     MOV.B WREG, shortPacketStatus
0004B0  370006     BRA 0x4BE
1785:                      }
1786:                      else if(shortPacketStatus == SHORT_PKT_PENDING)
0004B2  20A625     MOV #0xA62, W5
0004B4  784295     MOV.B [W5], W5
0004B6  52CFE1     SUB.B W5, #0x1, [W15]
0004B8  3A0002     BRA NZ, 0x4BE
1787:                      {
1788:                          shortPacketStatus = SHORT_PKT_SENT;
0004BA  B3C020     MOV #0x2, W0
0004BC  B7EA62     MOV.B WREG, shortPacketStatus
1789:                      }
1790:                  }
1791:              
1792:                  //Keep track of how many bytes remain to be sent in the transfer, by
1793:                  //subtracting the number of bytes about to be sent from the total.
1794:                  inPipes[0].wCount.Val -= byteToSend;
0004BE  FB8004     ZE W4, W0
0004C0  B52808     SUB 0x808
1795:                  
1796:                  //Next, load the number of bytes to send to BC7..0 in buffer descriptor.
1797:                  //Note: Control endpoints may never have a max packet size of > 64 bytes.
1798:                  //Therefore, the BC8 and BC9 bits should always be maintained clear.
1799:                  pBDTEntryIn[0]->CNT = byteToSend;
0004C2  8040D5     MOV pBDTEntryIn, W5
0004C4  784A84     MOV.B W4, [W5]
1800:              
1801:                  //Now copy the data from the source location, to the CtrlTrfData[] buffer,
1802:                  //which we will send to the host.
1803:                  pDst = (USB_VOLATILE uint8_t*)CtrlTrfData;                // Set destination pointer
0004C6  20A545     MOV #0xA54, W5
0004C8  885325     MOV W5, pDst
1804:                  if(inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   // Determine type of memory source
0004CA  AB0806     BTST 0x806, #0
0004CC  320003     BRA Z, 0x4D4
1805:                  {
1806:                      while(byteToSend)
0004D4  524FE0     SUB.B W4, #0x0, [W15]
0004D6  32000F     BRA Z, 0x4F6
0004E4  3AFFF9     BRA NZ, 0x4D8
0004E6  370007     BRA 0x4F6
1807:                      {
1808:                          *pDst++ = *inPipes[0].pSrc.bRom++;
0004D8  804025     MOV inPipes, W5
0004DA  805326     MOV pDst, W6
0004DC  785B35     MOV.B [W5++], [W6++]
0004DE  885326     MOV W6, pDst
0004E0  884025     MOV W5, inPipes
1809:                          byteToSend--;
0004E2  E94204     DEC.B W4, W4
1810:                      }//end while(byte_to_send.Val)
1811:                  }
1812:                  else  // RAM
1813:                  {
1814:                      while(byteToSend)
0004CE  524FE0     SUB.B W4, #0x0, [W15]
0004D0  3A000B     BRA NZ, 0x4E8
0004D2  370011     BRA 0x4F6
0004F4  3AFFF9     BRA NZ, 0x4E8
1815:                      {
1816:                          *pDst++ = *inPipes[0].pSrc.bRam++;
0004E8  804025     MOV inPipes, W5
0004EA  805326     MOV pDst, W6
0004EC  785B35     MOV.B [W5++], [W6++]
0004EE  885326     MOV W6, pDst
0004F0  884025     MOV W5, inPipes
1817:                          byteToSend--;
0004F2  E94204     DEC.B W4, W4
1818:                      }//end while(byte_to_send.Val)
1819:                  }//end if(usb_stat.ctrl_trf_mem == _const)
1820:              }//end USBCtrlTrfTxService
0004F6  060000     RETURN
1821:              
1822:              /******************************************************************************
1823:               * Function:        void USBCtrlTrfRxService(void)
1824:               *
1825:               * PreCondition:    pDst and wCount are setup properly.
1826:               *                  pSrc is always &CtrlTrfData
1827:               *                  usb_stat.ctrl_trf_mem is always USB_EP0_RAM.
1828:               *                  wCount should be set to 0 at the start of each control
1829:               *                  transfer.
1830:               *
1831:               * Input:           None
1832:               *
1833:               * Output:          None
1834:               *
1835:               * Side Effects:    None
1836:               *
1837:               * Overview:        This routine is used for host to device control transfers
1838:               *					(uses OUT transactions).  This function receives the data that arrives
1839:               *					on EP0 OUT, and copies it into the appropriate outPipes[0].pDst.bRam
1840:               *					buffer.  Once the host has sent all the data it was intending
1841:               *					to send, this function will call the appropriate outPipes[0].pFunc()
1842:               *					handler (unless it is NULL), so that it can be used by the
1843:               *					intended target firmware.
1844:               *
1845:               * Note:            None
1846:               *****************************************************************************/
1847:              static void USBCtrlTrfRxService(void)
1848:              {
1849:                  uint8_t byteToRead;
1850:                  uint8_t i;
1851:              
1852:                  //Load byteToRead with the number of bytes the host just sent us in the 
1853:                  //last OUT transaction.
1854:                  byteToRead = pBDTEntryEP0OutCurrent->CNT;   
000B92  8052F4     MOV pBDTEntryEP0OutCurrent, W4
000B94  784094     MOV.B [W4], W1
1855:              
1856:                  //Update the "outPipes[0].wCount.Val", which keeps track of the total number
1857:                  //of remaining bytes expected to be received from the host, in the control
1858:                  //transfer.  First check to see if the host sent us more bytes than the
1859:                  //application firmware was expecting to receive.
1860:                  if(byteToRead > outPipes[0].wCount.Val)
000B96  208125     MOV #0x812, W5
000B98  784295     MOV.B [W5], W5
000B9A  FB8285     ZE W5, W5
000B9C  208134     MOV #0x813, W4
000B9E  784214     MOV.B [W4], W4
000BA0  DD2248     SL W4, #8, W4
000BA2  720205     IOR W4, W5, W4
000BA4  FB8281     ZE W1, W5
000BA6  528F84     SUB W5, W4, [W15]
000BA8  360004     BRA LEU, 0xBB2
1861:                  {
1862:                      byteToRead = outPipes[0].wCount.Val;
000BAA  BFC812     MOV.B 0x812, WREG
000BAC  208134     MOV #0x813, W4
000BAE  784214     MOV.B [W4], W4
000BB0  784080     MOV.B W0, W1
1863:                  }	
1864:                  //Reduce the number of remaining bytes by the number we just received.
1865:                  outPipes[0].wCount.Val -= byteToRead;
000BB2  208125     MOV #0x812, W5
000BB4  784295     MOV.B [W5], W5
000BB6  FB8285     ZE W5, W5
000BB8  208134     MOV #0x813, W4
000BBA  784214     MOV.B [W4], W4
000BBC  DD2248     SL W4, #8, W4
000BBE  720205     IOR W4, W5, W4
000BC0  FB8281     ZE W1, W5
000BC2  520205     SUB W4, W5, W4
000BC4  208125     MOV #0x812, W5
000BC6  784295     MOV.B [W5], W5
000BC8  784004     MOV.B W4, W0
000BCA  B7E812     MOV.B WREG, 0x812
000BCC  DE2248     LSR W4, #8, W4
000BCE  208135     MOV #0x813, W5
000BD0  784295     MOV.B [W5], W5
000BD2  784004     MOV.B W4, W0
000BD4  B7E813     MOV.B WREG, 0x813
1866:              
1867:                  //Copy the OUT DATAx packet bytes that we just received from the host,
1868:                  //into the user application buffer space.
1869:                  for(i=0;i<byteToRead;i++)
000BD6  50CFE0     SUB.B W1, #0x0, [W15]
000BD8  320017     BRA Z, 0xC08
000BDA  EB4280     CLR.B W5
000C02  E84285     INC.B W5, W5
000C04  50CF85     SUB.B W1, W5, [W15]
000C06  3EFFEA     BRA GTU, 0xBDC
1870:                  {
1871:                      *outPipes[0].pDst.bRam++ = CtrlTrfData[i];
000BDC  2080F7     MOV #0x80F, W7
000BDE  784397     MOV.B [W7], W7
000BE0  FB8387     ZE W7, W7
000BE2  208104     MOV #0x810, W4
000BE4  784214     MOV.B [W4], W4
000BE6  DD2248     SL W4, #8, W4
000BE8  FB8305     ZE W5, W6
000BEA  720207     IOR W4, W7, W4
000BEC  20A547     MOV #0xA54, W7
000BEE  7B5A67     MOV.B [W7+W6], [W4++]
000BF0  2080F6     MOV #0x80F, W6
000BF2  784316     MOV.B [W6], W6
000BF4  784004     MOV.B W4, W0
000BF6  B7E80F     MOV.B WREG, outPipes
000BF8  DE2248     LSR W4, #8, W4
000BFA  208106     MOV #0x810, W6
000BFC  784316     MOV.B [W6], W6
000BFE  784004     MOV.B W4, W0
000C00  B7E810     MOV.B WREG, 0x810
1872:                  }//end while(byteToRead.Val)
1873:              
1874:                  //If there is more data to receive, prepare EP0 OUT so that it can receive 
1875:              	//the next packet in the sequence.
1876:                  if(outPipes[0].wCount.Val > 0)
000C08  208125     MOV #0x812, W5
000C0A  784295     MOV.B [W5], W5
000C0C  FB8285     ZE W5, W5
000C0E  208134     MOV #0x813, W4
000C10  784214     MOV.B [W4], W4
000C12  DD2248     SL W4, #8, W4
000C14  720205     IOR W4, W5, W4
000C16  320018     BRA Z, 0xC48
1877:                  {
1878:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000C18  B3C085     MOV #0x8, W5
000C1A  805304     MOV pBDTEntryEP0OutNext, W4
000C1C  784A05     MOV.B W5, [W4]
1879:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
000C1E  805304     MOV pBDTEntryEP0OutNext, W4
000C20  20A545     MOV #0xA54, W5
000C22  980215     MOV W5, [W4+2]
1880:                      if(pBDTEntryEP0OutCurrent->STAT.DTS == 0)
000C24  240005     MOV #0x4000, W5
000C26  8052F6     MOV pBDTEntryEP0OutCurrent, W6
000C28  628296     AND W5, [W6], W5
000C2A  3A0007     BRA NZ, 0xC3A
1881:                      {
1882:                          pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
000C2C  B3C485     MOV #0x48, W5
000C2E  984215     MOV.B W5, [W4+1]
1883:                          pBDTEntryEP0OutNext->STAT.Val |= _USIE;
000C30  805304     MOV pBDTEntryEP0OutNext, W4
000C32  904294     MOV.B [W4+1], W5
000C34  A07405     BSET.B W5, #7
000C36  984215     MOV.B W5, [W4+1]
000C38  370029     BRA 0xC8C
1884:                      }
1885:                      else
1886:                      {
1887:                          pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
000C3A  B3C085     MOV #0x8, W5
000C3C  984215     MOV.B W5, [W4+1]
1888:                          pBDTEntryEP0OutNext->STAT.Val |= _USIE;
000C3E  805304     MOV pBDTEntryEP0OutNext, W4
000C40  904294     MOV.B [W4+1], W5
000C42  A07405     BSET.B W5, #7
000C44  984215     MOV.B W5, [W4+1]
000C46  370022     BRA 0xC8C
1889:                      }
1890:                  }
1891:                  else
1892:                  {
1893:              	    //We have received all OUT packets that we were expecting to
1894:              	    //receive for the control transfer.  Prepare EP0 OUT to receive
1895:              		//the next SETUP transaction that may arrive.
1896:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000C48  B3C085     MOV #0x8, W5
000C4A  805304     MOV pBDTEntryEP0OutNext, W4
000C4C  784A05     MOV.B W5, [W4]
1897:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
000C4E  805304     MOV pBDTEntryEP0OutNext, W4
000C50  20A4C5     MOV #0xA4C, W5
000C52  980215     MOV W5, [W4+2]
1898:                      //Configure EP0 OUT to receive the next SETUP transaction for any future
1899:                      //control transfers.  However, set BSTALL in case the host tries to send
1900:                      //more data than it claims it was going to send.
1901:                      pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
000C54  B3C045     MOV #0x4, W5
000C56  984215     MOV.B W5, [W4+1]
1902:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
000C58  805304     MOV pBDTEntryEP0OutNext, W4
000C5A  904294     MOV.B [W4+1], W5
000C5C  A07405     BSET.B W5, #7
000C5E  984215     MOV.B W5, [W4+1]
1903:              
1904:              		//All data bytes for the host to device control write (OUT) have now been
1905:              		//received successfully.
1906:              		//Go ahead and call the user specified callback function, to use/consume
1907:              		//the control transfer data (ex: if the "void (*function)" parameter 
1908:              		//was non-NULL when USBEP0Receive() was called).
1909:                      if(outPipes[0].pFunc != NULL)
000C60  208145     MOV #0x814, W5
000C62  784295     MOV.B [W5], W5
000C64  FB8285     ZE W5, W5
000C66  208154     MOV #0x815, W4
000C68  784214     MOV.B [W4], W4
000C6A  DD2248     SL W4, #8, W4
000C6C  720205     IOR W4, W5, W4
000C6E  320008     BRA Z, 0xC80
1910:                      {
1911:                          #if defined(__XC8)
1912:                              //Special pragmas to suppress an expected/harmless warning
1913:                              //message when building with the XC8 compiler
1914:                              #pragma warning push
1915:                              #pragma warning disable 1088
1916:                              outPipes[0].pFunc();    //Call the user's callback function
1917:                              #pragma warning pop
1918:                          #else
1919:                              outPipes[0].pFunc();    //Call the user's callback function
000C70  208145     MOV #0x814, W5
000C72  784295     MOV.B [W5], W5
000C74  FB8285     ZE W5, W5
000C76  208154     MOV #0x815, W4
000C78  784214     MOV.B [W4], W4
000C7A  DD2248     SL W4, #8, W4
000C7C  720205     IOR W4, W5, W4
000C7E  010004     CALL W4
1920:                          #endif
1921:                      }
1922:                      outPipes[0].info.bits.busy = 0;    
000C80  A9E811     BCLR 0x811, #7
1923:              
1924:                      //Ready to arm status stage IN transaction now, if the application
1925:                      //firmware has completed processing the request.  If it is still busy
1926:                      //and needs more time to finish handling the request, then the user
1927:                      //callback (the one called by the outPipes[0].pFunc();) should set the
1928:                      //USBDeferStatusStagePacket to true (by calling USBDeferStatusStage()).  In
1929:                      //this case, it is the application's firmware responsibility to call 
1930:                      //the USBCtrlEPAllowStatusStage() function, once it is fully done handling the request.
1931:                      //Note: The application firmware must process the request and call
1932:                      //USBCtrlEPAllowStatusStage() in a semi-timely fashion.  "Semi-timely"
1933:                      //means either 50ms, 500ms, or 5 seconds, depending on the type of
1934:                      //control transfer.  See the USB 2.0 specification section 9.2.6 for
1935:                      //more details.
1936:                      if(USBDeferStatusStagePacket == false)
000C82  208014     MOV #0x801, W4
000C84  784214     MOV.B [W4], W4
000C86  524FE0     SUB.B W4, #0x0, [W15]
000C88  3A0001     BRA NZ, 0xC8C
1937:                      {
1938:                          USBCtrlEPAllowStatusStage();
000C8A  07FF50     RCALL USBCtrlEPAllowStatusStage
1939:                      }            
1940:                  }    
1941:              
1942:              }//end USBCtrlTrfRxService
000C8C  060000     RETURN
1943:              
1944:              
1945:              /********************************************************************
1946:               * Function:        void USBStdSetCfgHandler(void)
1947:               *
1948:               * PreCondition:    None
1949:               *
1950:               * Input:           None
1951:               *
1952:               * Output:          None
1953:               *
1954:               * Side Effects:    None
1955:               *
1956:               * Overview:        This routine first disables all endpoints by
1957:               *                  clearing UEP registers. It then configures
1958:               *                  (initializes) endpoints by calling the callback
1959:               *                  function USBCBInitEP().
1960:               *
1961:               * Note:            None
1962:               *******************************************************************/
1963:              static void USBStdSetCfgHandler(void)
1964:              {
000868  BE9F88     MOV.D W8, [W15++]
1965:                  uint8_t i;
1966:              
1967:                  // This will generate a zero length packet
1968:                  inPipes[0].info.bits.busy = 1;            
00086A  A8E806     BSET 0x806, #7
1969:              
1970:                  //Clear all of the endpoint control registers
1971:                  DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
00086C  EB0400     CLR W8
00086E  882568     MOV W8, U1EP1
1972:              
1973:                  //Clear all of the BDT entries
1974:                  memset((void*)&BDT[0], 0x00, sizeof(BDT));
000870  20C009     MOV #0xC00, W9
000872  200202     MOV #0x20, W2
000874  780088     MOV W8, W1
000876  780009     MOV W9, W0
000878  07FD7E     RCALL _memset
1975:              
1976:                  // Assert reset request to all of the Ping Pong buffer pointers
1977:                  USBPingPongBufferReset = 1;                                   
00087A  A82494     BSET U1CON, #1
1978:              
1979:              	//Re-Initialize all ping pong software state bits to 0 (which corresponds to
1980:              	//the EVEN buffer being the next one that will be used), since we are also 
1981:              	//doing a hardware ping pong pointer reset above.
1982:              	for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
1983:              	{
1984:              		ep_data_in[i].Val = 0u;
00087C  784008     MOV.B W8, W0
00087E  B7EA69     MOV.B WREG, ep_data_in
000880  B7EA6B     MOV.B WREG, ep_data_out
000882  B7EA6A     MOV.B WREG, 0xA6A
000884  B7EA6C     MOV.B WREG, 0xA6C
000886  B7EA5C     MOV.B WREG, USBAlternateInterface
1985:                      ep_data_out[i].Val = 0u;
1986:              	}
1987:              
1988:                  //clear the alternate interface settings
1989:                  memset((void*)&USBAlternateInterface,0x00,USB_MAX_NUM_INT);
1990:              
1991:                  //Stop trying to reset ping pong buffer pointers
1992:                  USBPingPongBufferReset = 0;
000888  A92494     BCLR U1CON, #1
1993:              
1994:                  pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
00088A  448268     ADD W9, #0x8, W4
00088C  8840D4     MOV W4, pBDTEntryIn
1995:              
1996:              	//Set the next out to the current out packet
1997:                  pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN];
00088E  8852F9     MOV W9, pBDTEntryEP0OutCurrent
1998:                  pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
000890  885309     MOV W9, pBDTEntryEP0OutNext
1999:              
2000:                  //set the current configuration
2001:                  USBActiveConfiguration = SetupPkt.bConfigurationValue;
000892  BFCA4E     MOV.B 0xA4E, WREG
000894  B7E80E     MOV.B WREG, USBActiveConfiguration
2002:              
2003:                  //if the configuration value == 0
2004:                  if(USBActiveConfiguration == 0)
000896  2080E4     MOV #0x80E, W4
000898  784214     MOV.B [W4], W4
00089A  524FE0     SUB.B W4, #0x0, [W15]
00089C  3A0003     BRA NZ, 0x8A4
2005:                  {
2006:                      //Go back to the addressed state
2007:                      USBDeviceState = ADDRESS_STATE;
00089E  200104     MOV #0x10, W4
0008A0  884064     MOV W4, USBDeviceState
0008A2  370006     BRA 0x8B0
2008:                  }
2009:                  else
2010:                  {
2011:                      //initialize the required endpoints
2012:                      USB_SET_CONFIGURATION_HANDLER(EVENT_CONFIGURED,(void*)&USBActiveConfiguration,1);
0008A4  200012     MOV #0x1, W2
0008A6  2080E1     MOV #0x80E, W1
0008A8  200010     MOV #0x1, W0
0008AA  07FD43     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2013:              
2014:                      //Otherwise go to the configured state.  Update the state variable last,
2015:                      //after performing all of the set configuration related initialization
2016:                      //tasks.
2017:                      USBDeviceState = CONFIGURED_STATE;		
0008AC  200204     MOV #0x20, W4
0008AE  884064     MOV W4, USBDeviceState
2018:                  }//end if(SetupPkt.bConfigurationValue == 0)
2019:              }//end USBStdSetCfgHandler
0008B0  BE044F     MOV.D [--W15], W8
0008B2  060000     RETURN
2020:              
2021:              
2022:              /********************************************************************
2023:               * Function:        void USBStdGetDscHandler(void)
2024:               *
2025:               * PreCondition:    None
2026:               *
2027:               * Input:           None
2028:               *
2029:               * Output:          None
2030:               *
2031:               * Side Effects:    None
2032:               *
2033:               * Overview:        This routine handles the standard GET_DESCRIPTOR
2034:               *                  request.
2035:               *
2036:               * Note:            None
2037:               *******************************************************************/
2038:              static void USBStdGetDscHandler(void)
2039:              {
2040:                  if(SetupPkt.bmRequestType == 0x80)
0004F8  20A4C5     MOV #0xA4C, W5
0004FA  784295     MOV.B [W5], W5
0004FC  B3C804     MOV #0x80, W4
0004FE  52CF84     SUB.B W5, W4, [W15]
000500  3A0036     BRA NZ, 0x56E
2041:                  {
2042:                      inPipes[0].info.Val = USB_EP0_ROM | USB_EP0_BUSY | USB_EP0_INCLUDE_ZERO;
000502  B3CC00     MOV #0xC0, W0
000504  B7E806     MOV.B WREG, 0x806
2043:              
2044:                      switch(SetupPkt.bDescriptorType)
000506  20A4F4     MOV #0xA4F, W4
000508  784214     MOV.B [W4], W4
00050A  524FE2     SUB.B W4, #0x2, [W15]
00050C  320009     BRA Z, 0x520
00050E  524FE3     SUB.B W4, #0x3, [W15]
000510  32001B     BRA Z, 0x548
000512  524FE1     SUB.B W4, #0x1, [W15]
000514  3A002B     BRA NZ, 0x56C
2045:                      {
2046:                          case USB_DESCRIPTOR_DEVICE:
2047:                              #if !defined(USB_USER_DEVICE_DESCRIPTOR)
2048:                                  inPipes[0].pSrc.bRom = (const uint8_t*)&device_dsc;
2049:                              #else
2050:                                  inPipes[0].pSrc.bRom = (const uint8_t*)USB_USER_DEVICE_DESCRIPTOR;
000516  283844     MOV #0x8384, W4
000518  884024     MOV W4, inPipes
2051:                              #endif
2052:                              inPipes[0].wCount.Val = sizeof(device_dsc);
00051A  200124     MOV #0x12, W4
00051C  884044     MOV W4, 0x808
2053:                              break;
00051E  370027     BRA 0x56E
2054:                          case USB_DESCRIPTOR_CONFIGURATION:
2055:                              //First perform error case check, to make sure the host is requesting a 
2056:                              //legal descriptor index.  If the request index is illegal, don't do 
2057:                              //anything (so that the default STALL response will be sent).
2058:                              if(SetupPkt.bDscIndex < USB_MAX_NUM_CONFIG_DSC)
000520  20A4E4     MOV #0xA4E, W4
000522  784214     MOV.B [W4], W4
000524  524FE0     SUB.B W4, #0x0, [W15]
000526  3A000E     BRA NZ, 0x544
2059:                              {
2060:                                  #if !defined(USB_USER_CONFIG_DESCRIPTOR)
2061:                                      inPipes[0].pSrc.bRom = *(USB_CD_Ptr+SetupPkt.bDscIndex);
2062:                                  #else
2063:                                      inPipes[0].pSrc.bRom = *(USB_USER_CONFIG_DESCRIPTOR+SetupPkt.bDscIndex);
000528  20A4E4     MOV #0xA4E, W4
00052A  784214     MOV.B [W4], W4
00052C  FB8204     ZE W4, W4
00052E  420204     ADD W4, W4, W4
000530  284425     MOV #0x8442, W5
000532  7A02E5     MOV [W5+W4], W5
000534  884025     MOV W5, inPipes
2064:                                  #endif
2065:              
2066:                                  //This must be loaded using byte addressing.  The source pointer
2067:                                  //  may not be word aligned for the 16 or 32 bit machines resulting
2068:                                  //  in an address error on the dereference.
2069:                                  inPipes[0].wCount.byte.LB = *(inPipes[0].pSrc.bRom+2);
000536  804024     MOV inPipes, W4
000538  904024     MOV.B [W4+2], W0
00053A  B7E808     MOV.B WREG, 0x808
2070:                                  inPipes[0].wCount.byte.HB = *(inPipes[0].pSrc.bRom+3);
00053C  804024     MOV inPipes, W4
00053E  904034     MOV.B [W4+3], W0
000540  B7E809     MOV.B WREG, 0x809
000542  370015     BRA 0x56E
2071:                              }
2072:              				else
2073:              				{
2074:              					inPipes[0].info.Val = 0;
000544  EF6806     CLR.B 0x806
000546  370013     BRA 0x56E
2075:              				}
2076:                              break;
2077:                          case USB_DESCRIPTOR_STRING:
2078:                              //USB_NUM_STRING_DESCRIPTORS was introduced as optional in release v2.3.  In v2.4 and
2079:                              //  later it is now manditory.  This should be defined in usb_config.h and should
2080:                              //  indicate the number of string descriptors.
2081:                              if(SetupPkt.bDscIndex<USB_NUM_STRING_DESCRIPTORS)
000548  20A4E4     MOV #0xA4E, W4
00054A  784214     MOV.B [W4], W4
00054C  524FE3     SUB.B W4, #0x3, [W15]
00054E  3E000C     BRA GTU, 0x568
2082:                              {
2083:                                  //Get a pointer to the String descriptor requested
2084:                                  inPipes[0].pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
000550  20A4E4     MOV #0xA4E, W4
000552  784214     MOV.B [W4], W4
000554  FB8204     ZE W4, W4
000556  420204     ADD W4, W4, W4
000558  284445     MOV #0x8444, W5
00055A  7A02E5     MOV [W5+W4], W5
00055C  884025     MOV W5, inPipes
2085:                                  // Set data count
2086:                                  inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
00055E  804024     MOV inPipes, W4
000560  784214     MOV.B [W4], W4
000562  FB8204     ZE W4, W4
000564  884044     MOV W4, 0x808
000566  370003     BRA 0x56E
2087:                              }
2088:                              #if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)
2089:                              else if(SetupPkt.bDscIndex == MICROSOFT_OS_DESCRIPTOR_INDEX)
2090:                              {
2091:                                  //Get a pointer to the special MS OS string descriptor requested
2092:                                  inPipes[0].pSrc.bRom = (const uint8_t*)&MSOSDescriptor;
2093:                                  // Set data count
2094:                                  inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
2095:                              }    
2096:                              #endif
2097:                              else
2098:                              {
2099:                                  inPipes[0].info.Val = 0;
000568  EF6806     CLR.B 0x806
00056A  370001     BRA 0x56E
2100:                              }
2101:                              break;
2102:                          default:
2103:                              inPipes[0].info.Val = 0;
00056C  EF6806     CLR.B 0x806
2104:                              break;
2105:                      }//end switch
2106:                  }//end if
2107:              }//end USBStdGetDscHandler
00056E  060000     RETURN
2108:              
2109:              /********************************************************************
2110:               * Function:        void USBStdGetStatusHandler(void)
2111:               *
2112:               * PreCondition:    None
2113:               *
2114:               * Input:           None
2115:               *
2116:               * Output:          None
2117:               *
2118:               * Side Effects:    None
2119:               *
2120:               * Overview:        This routine handles the standard GET_STATUS request
2121:               *
2122:               * Note:            None
2123:               *******************************************************************/
2124:              static void USBStdGetStatusHandler(void)
2125:              {
2126:                  CtrlTrfData[0] = 0;                 // Initialize content
000570  B3C000     MOV #0x0, W0
000572  B7EA54     MOV.B WREG, CtrlTrfData
000574  B7EA55     MOV.B WREG, 0xA55
2127:                  CtrlTrfData[1] = 0;
2128:              
2129:                  switch(SetupPkt.Recipient)
000576  20A4C4     MOV #0xA4C, W4
000578  784214     MOV.B [W4], W4
00057A  62027F     AND W4, #0x1F, W4
00057C  520FE1     SUB W4, #0x1, [W15]
00057E  32000C     BRA Z, 0x598
000580  520FE2     SUB W4, #0x2, [W15]
000582  32000C     BRA Z, 0x59C
000584  520FE0     SUB W4, #0x0, [W15]
000586  3A0022     BRA NZ, 0x5CC
2130:                  {
2131:                      case USB_SETUP_RECIPIENT_DEVICE_BITFIELD:
2132:                          inPipes[0].info.bits.busy = 1;
000588  A8E806     BSET 0x806, #7
2133:                          /*
2134:                           * [0]: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
2135:                           *      bit1: RemoteWakeup        [0] Disabled    [1] Enabled
2136:                           */
2137:                          if(self_power == 1) // self_power is defined in HardwareProfile.h
2138:                          {
2139:                              CtrlTrfData[0]|=0x01;
00058A  A80A54     BSET CtrlTrfData, #0
2140:                          }
2141:              
2142:                          if(RemoteWakeup == true)
00058C  2080A4     MOV #0x80A, W4
00058E  784214     MOV.B [W4], W4
000590  524F80     SUB.B W4, W0, [W15]
000592  32001C     BRA Z, 0x5CC
2143:                          {
2144:                              CtrlTrfData[0]|=0x02;
000594  A82A54     BSET CtrlTrfData, #1
000596  37001A     BRA 0x5CC
2145:                          }
2146:                          break;
2147:                      case USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:
2148:                          inPipes[0].info.bits.busy = 1;     // No data to update
000598  A8E806     BSET 0x806, #7
2149:                          break;
00059A  370018     BRA 0x5CC
2150:                      case USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:
2151:                          inPipes[0].info.bits.busy = 1;
00059C  A8E806     BSET 0x806, #7
2152:                          /*
2153:                           * [0]: bit0: Halt Status [0] Not Halted [1] Halted
2154:                           */
2155:                          {
2156:                              BDT_ENTRY *p;
2157:              
2158:                              if(SetupPkt.EPDir == 0)
00059E  20A504     MOV #0xA50, W4
0005A0  784214     MOV.B [W4], W4
0005A2  524FE0     SUB.B W4, #0x0, [W15]
0005A4  350007     BRA LT, 0x5B4
2159:                              {
2160:                                  p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
0005A6  20A504     MOV #0xA50, W4
0005A8  784214     MOV.B [W4], W4
0005AA  62026F     AND W4, #0xF, W4
0005AC  420204     ADD W4, W4, W4
0005AE  208165     MOV #0x816, W5
0005B0  7A02E5     MOV [W5+W4], W5
0005B2  370006     BRA 0x5C0
2161:                              }
2162:                              else
2163:                              {
2164:                                  p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
0005B4  20A504     MOV #0xA50, W4
0005B6  784214     MOV.B [W4], W4
0005B8  62026F     AND W4, #0xF, W4
0005BA  420204     ADD W4, W4, W4
0005BC  2081A5     MOV #0x81A, W5
0005BE  7A02E5     MOV [W5+W4], W5
2165:                              }
2166:              
2167:                              if((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 1))
0005C0  284004     MOV #0x8400, W4
0005C2  620295     AND W4, [W5], W5
0005C4  528F84     SUB W5, W4, [W15]
0005C6  3A0002     BRA NZ, 0x5CC
2168:                                  CtrlTrfData[0]=0x01;    // Set bit0
0005C8  B3C010     MOV #0x1, W0
0005CA  B7EA54     MOV.B WREG, CtrlTrfData
2169:                              break;
2170:                          }
2171:                  }//end switch
2172:              
2173:                  if(inPipes[0].info.bits.busy == 1)
0005CC  200804     MOV #0x80, W4
0005CE  804035     MOV 0x806, W5
0005D0  620205     AND W4, W5, W4
0005D2  520FE0     SUB W4, #0x0, [W15]
0005D4  320005     BRA Z, 0x5E0
2174:                  {
2175:                      inPipes[0].pSrc.bRam = (uint8_t*)&CtrlTrfData;        // Set Source
0005D6  20A544     MOV #0xA54, W4
0005D8  884024     MOV W4, inPipes
2176:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;      // Set memory type
0005DA  A80806     BSET 0x806, #0
2177:                      inPipes[0].wCount.v[0] = 2;                           // Set data count
0005DC  B3C020     MOV #0x2, W0
0005DE  B7E808     MOV.B WREG, 0x808
2178:                  }//end if(...)
2179:              }//end USBStdGetStatusHandler
0005E0  060000     RETURN
2180:              
2181:              /********************************************************************
2182:               * Function:        void USBStallHandler(void)
2183:               *
2184:               * PreCondition:    None
2185:               *
2186:               * Input:           None
2187:               *
2188:               * Output:          None
2189:               *
2190:               * Side Effects:    
2191:               *
2192:               * Overview:        This function handles the event of a STALL 
2193:               *                  occuring on the bus
2194:               *
2195:               * Note:            None
2196:               *******************************************************************/
2197:              static void USBStallHandler(void)
2198:              {
2199:                  /*
2200:                   * Does not really have to do anything here,
2201:                   * even for the control endpoint.
2202:                   * All BDs of Endpoint 0 are owned by SIE right now,
2203:                   * but once a Setup Transaction is received, the ownership
2204:                   * for EP0_OUT will be returned to CPU.
2205:                   * When the Setup Transaction is serviced, the ownership
2206:                   * for EP0_IN will then be forced back to CPU by firmware.
2207:                   */
2208:              
2209:                  if(U1EP0bits.EPSTALL == 1)
0005E2  AB24AA     BTST U1EP0, #1
0005E4  320011     BRA Z, 0x608
2210:                  {
2211:                      // UOWN - if 0, owned by CPU, if 1, owned by SIE
2212:                      if((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE|_BSTALL)))
0005E6  8052F4     MOV pBDTEntryEP0OutCurrent, W4
0005E8  904314     MOV.B [W4+1], W6
0005EA  B3C805     MOV #0x80, W5
0005EC  534F85     SUB.B W6, W5, [W15]
0005EE  3A000B     BRA NZ, 0x606
0005F0  8040D5     MOV pBDTEntryIn, W5
0005F2  904315     MOV.B [W5+1], W6
0005F4  B3C845     MOV #0x84, W5
0005F6  534F85     SUB.B W6, W5, [W15]
0005F8  3A0006     BRA NZ, 0x606
2213:                      {
2214:                          // Set ep0Bo to stall also
2215:                          pBDTEntryEP0OutCurrent->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
0005FA  B3C0C5     MOV #0xC, W5
0005FC  984215     MOV.B W5, [W4+1]
2216:                          pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
0005FE  8052F4     MOV pBDTEntryEP0OutCurrent, W4
000600  904294     MOV.B [W4+1], W5
000602  A07405     BSET.B W5, #7
000604  984215     MOV.B W5, [W4+1]
2217:                      }//end if
2218:                      U1EP0bits.EPSTALL = 0;               // Clear stall status
000606  A924AA     BCLR U1EP0, #1
2219:                  }//end if
2220:              
2221:                  USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);
000608  200804     MOV #0x80, W4
00060A  882454     MOV W4, U1IR
2222:              }
00060C  060000     RETURN
2223:              
2224:              /********************************************************************
2225:               * Function:        void USBSuspend(void)
2226:               *
2227:               * PreCondition:    None
2228:               *
2229:               * Input:           None
2230:               *
2231:               * Output:          None
2232:               *
2233:               * Side Effects:    
2234:               *
2235:               * Overview:        This function handles if the host tries to 
2236:               *                  suspend the device
2237:               *
2238:               * Note:            None
2239:               *******************************************************************/
2240:              static void USBSuspend(void)
2241:              {
2242:                  /*
2243:                   * NOTE: Do not clear UIRbits.ACTVIF here!
2244:                   * Reason:
2245:                   * ACTVIF is only generated once an IDLEIF has been generated.
2246:                   * This is a 1:1 ratio interrupt generation.
2247:                   * For every IDLEIF, there will be only one ACTVIF regardless of
2248:                   * the number of subsequent bus transitions.
2249:                   *
2250:                   * If the ACTIF is cleared here, a problem could occur when:
2251:                   * [       IDLE       ][bus activity ->
2252:                   * <--- 3 ms ----->     ^
2253:                   *                ^     ACTVIF=1
2254:                   *                IDLEIF=1
2255:                   *  #           #           #           #   (#=Program polling flags)
2256:                   *                          ^
2257:                   *                          This polling loop will see both
2258:                   *                          IDLEIF=1 and ACTVIF=1.
2259:                   *                          However, the program services IDLEIF first
2260:                   *                          because ACTIVIE=0.
2261:                   *                          If this routine clears the only ACTIVIF,
2262:                   *                          then it can never get out of the suspend
2263:                   *                          mode.
2264:                   */
2265:                  USBActivityIE = 1;                     // Enable bus activity interrupt
0006C6  A88482     BSET U1OTGIE, #4
2266:                  USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
0006C8  200104     MOV #0x10, W4
0006CA  882454     MOV W4, U1IR
2267:              
2268:                  #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2269:                      U1CONbits.SUSPND = 1;                   // Put USB module in power conserve
2270:                                                              // mode, SIE clock inactive
2271:                  #endif
2272:                  USBBusIsSuspended = true;
0006CC  B3C010     MOV #0x1, W0
0006CE  B7E80B     MOV.B WREG, USBBusIsSuspended
2273:               
2274:                  /*
2275:                   * At this point the PIC can go into sleep,idle, or
2276:                   * switch to a slower clock, etc.  This should be done in the
2277:                   * USBCBSuspend() if necessary.
2278:                   */
2279:                  USB_SUSPEND_HANDLER(EVENT_SUSPEND,0,0);
0006D0  EB0100     CLR W2
0006D2  EB0080     CLR W1
0006D4  200750     MOV #0x75, W0
0006D6  07FE2D     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2280:              }
0006D8  060000     RETURN
2281:              
2282:              /********************************************************************
2283:               * Function:        void USBWakeFromSuspend(void)
2284:               *
2285:               * PreCondition:    None
2286:               *
2287:               * Input:           None
2288:               *
2289:               * Output:          None
2290:               *
2291:               * Side Effects:    None
2292:               *
2293:               * Overview:
2294:               *
2295:               * Note:            None
2296:               *******************************************************************/
2297:              static void USBWakeFromSuspend(void)
2298:              {
2299:                  USBBusIsSuspended = false;
0006B4  EF680B     CLR.B USBBusIsSuspended
2300:              
2301:                  /*
2302:                   * If using clock switching, the place to restore the original
2303:                   * microcontroller core clock frequency is in the USBCBWakeFromSuspend() callback
2304:                   */
2305:                  USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0);
0006B6  EB0100     CLR W2
0006B8  EB0080     CLR W1
0006BA  200740     MOV #0x74, W0
0006BC  07FE3A     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2306:              
2307:                  #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2308:                      //To avoid improperly clocking the USB module, make sure the oscillator
2309:                      //settings are consistant with USB operation before clearing the SUSPND bit.
2310:                      //Make sure the correct oscillator settings are selected in the 
2311:                      //"USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0)" handler.
2312:                      U1CONbits.SUSPND = 0;   // Bring USB module out of power conserve
2313:                                              // mode.
2314:                  #endif
2315:              
2316:              
2317:                  USBActivityIE = 0;
0006BE  A98482     BCLR U1OTGIE, #4
2318:              
2319:                  /********************************************************************
2320:                  Bug Fix: Feb 26, 2007 v2.1
2321:                  *********************************************************************
2322:                  The ACTVIF bit cannot be cleared immediately after the USB module wakes
2323:                  up from Suspend or while the USB module is suspended. A few clock cycles
2324:                  are required to synchronize the internal hardware state machine before
2325:                  the ACTIVIF bit can be cleared by firmware. Clearing the ACTVIF bit
2326:                  before the internal hardware is synchronized may not have an effect on
2327:                  the value of ACTVIF. Additonally, if the USB module uses the clock from
2328:                  the 96 MHz PLL source, then after clearing the SUSPND bit, the USB
2329:                  module may not be immediately operational while waiting for the 96 MHz
2330:                  PLL to lock.
2331:                  ********************************************************************/
2332:              
2333:                  // UIRbits.ACTVIF = 0;                      // Removed
2334:                  #if defined(__18CXX) || defined(__XC8)
2335:                  while(USBActivityIF)
2336:                  #endif
2337:                  {
2338:                      USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
0006C0  200104     MOV #0x10, W4
0006C2  882404     MOV W4, U1OTGIR
2339:                  }  // Added
2340:              
2341:              }//end USBWakeFromSuspend
0006C4  060000     RETURN
2342:              
2343:              /********************************************************************
2344:               * Function:        void USBCtrlEPService(void)
2345:               *
2346:               * PreCondition:    USTAT is loaded with a valid endpoint address.
2347:               *
2348:               * Input:           None
2349:               *
2350:               * Output:          None
2351:               *
2352:               * Side Effects:    None
2353:               *
2354:               * Overview:        USBCtrlEPService checks for three transaction
2355:               *                  types that it knows how to service and services
2356:               *                  them:
2357:               *                  1. EP0 SETUP
2358:               *                  2. EP0 OUT
2359:               *                  3. EP0 IN
2360:               *                  It ignores all other types (i.e. EP1, EP2, etc.)
2361:               *
2362:               * Note:            None
2363:               *******************************************************************/
2364:              static void USBCtrlEPService(void)
2365:              {
2366:                  //If we get to here, that means a successful transaction has just occurred 
2367:                  //on EP0.  This means "progress" has occurred in the currently pending 
2368:                  //control transfer, so we should re-initialize our timeout counter.
2369:                  #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
2370:                      USBStatusStageTimeoutCounter = USB_STATUS_STAGE_TIMEOUT;
000E20  B3C2D0     MOV #0x2D, W0
000E22  B7EA6D     MOV.B WREG, USBStatusStageTimeoutCounter
2371:                  #endif
2372:              	
2373:              	//Check if the last transaction was on EP0 OUT endpoint (of any kind, to either the even or odd buffer if ping pong buffers used)
2374:                  if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
000E24  20A664     MOV #0xA66, W4
000E26  784214     MOV.B [W4], W4
000E28  B20FB4     AND #0xFB, W4
000E2A  3A0027     BRA NZ, 0xE7A
2375:                  {
2376:              		//Point to the EP0 OUT buffer of the buffer that arrived
2377:                      #if defined (_PIC14E) || defined(__18CXX) || defined(__XC8)
2378:                          pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>1];
2379:                      #elif defined(__C30__) || defined(__C32__) || defined __XC16__
2380:                          pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>2];
000E2C  20A662     MOV #0xA66, W2
000E2E  784112     MOV.B [W2], W2
000E30  FB8102     ZE W2, W2
000E32  DE1142     LSR W2, #2, W2
000E34  DD12C2     SL W2, #2, W5
000E36  20C006     MOV #0xC00, W6
000E38  428206     ADD W5, W6, W4
000E3A  8852F4     MOV W4, pBDTEntryEP0OutCurrent
2381:                      #else
2382:                          #error "unimplemented"
2383:                      #endif
2384:              
2385:              		//Set the next out to the current out packet
2386:                      pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
000E3C  885304     MOV W4, pBDTEntryEP0OutNext
2387:              		//Toggle it to the next ping pong buffer (if applicable)
2388:                      ((uint8_t_VAL*)&pBDTEntryEP0OutNext)->Val ^= USB_NEXT_EP0_OUT_PING_PONG;
000E3E  784384     MOV.B W4, W7
000E40  A22407     BTG.B W7, #2
000E42  784007     MOV.B W7, W0
000E44  B7EA60     MOV.B WREG, pBDTEntryEP0OutNext
2389:              
2390:              		//If the current EP0 OUT buffer has a SETUP packet
2391:                      if(pBDTEntryEP0OutCurrent->STAT.PID == PID_SETUP)
000E46  7A8366     MOV [W6+W5], W6
000E48  23C005     MOV #0x3C00, W5
000E4A  630305     AND W6, W5, W6
000E4C  234005     MOV #0x3400, W5
000E4E  530F85     SUB W6, W5, [W15]
000E50  3A0012     BRA NZ, 0xE76
000E52  B3C086     MOV #0x8, W6
000E54  EB4280     CLR.B W5
2392:                      {
2393:                          unsigned char setup_cnt;
2394:              
2395:              	        //The SETUP transaction data may have gone into the the CtrlTrfData 
2396:              	        //buffer, or elsewhere, depending upon how the BDT was prepared
2397:              	        //before the transaction.  Therefore, we should copy the data to the 
2398:              	        //SetupPkt buffer so it can be processed correctly by USBCtrlTrfSetupHandler().		    
2399:                          for(setup_cnt = 0; setup_cnt < 8u; setup_cnt++) //SETUP data packets always contain exactly 8 bytes.
000E64  E84285     INC.B W5, W5
000E66  E94306     DEC.B W6, W6
000E68  3AFFF6     BRA NZ, 0xE56
2400:                          {
2401:                              *(uint8_t*)((uint8_t*)&SetupPkt + setup_cnt) = *(uint8_t*)ConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR);
000E56  900094     MOV [W4+2], W1
000E58  FB8385     ZE W5, W7
000E5A  20A4C0     MOV #0xA4C, W0
000E5C  7BF011     MOV.B [W1], [W0+W7]
2402:                              pBDTEntryEP0OutCurrent->ADR++;
000E5E  900394     MOV [W4+2], W7
000E60  E80387     INC W7, W7
000E62  980217     MOV W7, [W4+2]
2403:                          }    
2404:                          pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
000E6A  DD1142     SL W2, #2, W2
000E6C  20C024     MOV #0xC02, W4
000E6E  780280     MOV W0, W5
000E70  793205     MOV W5, [W4+W2]
2405:              
2406:              			//Handle the control transfer (parse the 8-byte SETUP command and figure out what to do)
2407:                          USBCtrlTrfSetupHandler();
000E72  07FFAD     RCALL _USBCtrlTrfSetupHandler
000E74  370008     BRA 0xE86
2408:                      }
2409:                      else
2410:                      {
2411:              			//Handle the DATA transfer
2412:                          USBCtrlTrfOutHandler();
000E76  07FF0B     RCALL _USBCtrlTrfOutHandler
000E78  370006     BRA 0xE86
2413:                      }
2414:                  }
2415:                  else if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
000E7A  20A664     MOV #0xA66, W4
000E7C  784214     MOV.B [W4], W4
000E7E  B20FB4     AND #0xFB, W4
000E80  520FE8     SUB W4, #0x8, [W15]
000E82  3A0001     BRA NZ, 0xE86
2416:                  {
2417:              		//Otherwise the transmission was and EP0 IN
2418:              		//  so take care of the IN transfer
2419:                      USBCtrlTrfInHandler();
000E84  07FBC4     RCALL _USBCtrlTrfInHandler
2420:                  }
2421:              
2422:              }//end USBCtrlEPService
000E86  060000     RETURN
2423:              
2424:              /********************************************************************
2425:               * Function:        void USBCtrlTrfSetupHandler(void)
2426:               *
2427:               * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
2428:               *
2429:               * Input:           None
2430:               *
2431:               * Output:          None
2432:               *
2433:               * Side Effects:    None
2434:               *
2435:               * Overview:        This routine is a task dispatcher and has 3 stages.
2436:               *                  1. It initializes the control transfer state machine.
2437:               *                  2. It calls on each of the module that may know how to
2438:               *                     service the Setup Request from the host.
2439:               *                     Module Example: USBD, HID, CDC, MSD, ...
2440:               *                     A callback function, USBCBCheckOtherReq(),
2441:               *                     is required to call other module handlers.
2442:               *                  3. Once each of the modules has had a chance to check if
2443:               *                     it is responsible for servicing the request, stage 3
2444:               *                     then checks direction of the transfer to determine how
2445:               *                     to prepare EP0 for the control transfer.
2446:               *                     Refer to USBCtrlEPServiceComplete() for more details.
2447:               *
2448:               * Note:            Microchip USB Firmware has three different states for
2449:               *                  the control transfer state machine:
2450:               *                  1. WAIT_SETUP
2451:               *                  2. CTRL_TRF_TX (device sends data to host through IN transactions)
2452:               *                  3. CTRL_TRF_RX (device receives data from host through OUT transactions)
2453:               *                  Refer to firmware manual to find out how one state
2454:               *                  is transitioned to another.
2455:               *
2456:               *                  A Control Transfer is composed of many USB transactions.
2457:               *                  When transferring data over multiple transactions,
2458:               *                  it is important to keep track of data source, data
2459:               *                  destination, and data count. These three parameters are
2460:               *                  stored in pSrc,pDst, and wCount. A flag is used to
2461:               *                  note if the data source is from const or RAM.
2462:               *
2463:               *******************************************************************/
2464:              static void USBCtrlTrfSetupHandler(void)
2465:              {
000DCE  781F88     MOV W8, [W15++]
2466:                  //--------------------------------------------------------------------------
2467:                  //1. Re-initialize state tracking variables related to control transfers.
2468:                  //--------------------------------------------------------------------------
2469:                  shortPacketStatus = SHORT_PKT_NOT_USED;  
000DD0  B3C000     MOV #0x0, W0
000DD2  B7EA62     MOV.B WREG, shortPacketStatus
000DD4  B7E801     MOV.B WREG, USBDeferStatusStagePacket
000DD6  B7E802     MOV.B WREG, USBDeferINDataStagePackets
000DD8  B7E800     MOV.B WREG, USBDeferOUTDataStagePackets
000DDA  B7EA68     MOV.B WREG, BothEP0OutUOWNsSet
2470:                  USBDeferStatusStagePacket = false;
2471:                  USBDeferINDataStagePackets = false;
2472:                  USBDeferOUTDataStagePackets = false;
2473:                  BothEP0OutUOWNsSet = false;
2474:                  controlTransferState = WAIT_SETUP;
000DDC  B7EA63     MOV.B WREG, controlTransferState
2475:              
2476:                  //Abandon any previous control transfers that might have been using EP0.
2477:                  //Ordinarily, nothing actually needs abandoning, since the previous control
2478:                  //transfer would have completed successfully prior to the host sending the next
2479:                  //SETUP packet.  However, in a timeout error case, or after an EP0 STALL event,
2480:                  //one or more UOWN bits might still be set.  If so, we should clear the UOWN bits,
2481:                  //so the EP0 IN/OUT endpoints are in a known inactive state, ready for re-arming
2482:                  //by the class request handler that will be called next.
2483:                  pBDTEntryIn[0]->STAT.Val &= ~(_USIE);     
000DDE  8040D5     MOV pBDTEntryIn, W5
000DE0  904315     MOV.B [W5+1], W6
000DE2  A17406     BCLR.B W6, #7
000DE4  984296     MOV.B W6, [W5+1]
2484:                  ((uint8_t_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
000DE6  2081A5     MOV #0x81A, W5
000DE8  A22415     BTG.B [W5], #2
2485:                  pBDTEntryIn[0]->STAT.Val &= ~(_USIE);      
000DEA  8040D6     MOV pBDTEntryIn, W6
000DEC  904396     MOV.B [W6+1], W7
000DEE  A17407     BCLR.B W7, #7
000DF0  984317     MOV.B W7, [W6+1]
2486:                  ((uint8_t_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
000DF2  A22415     BTG.B [W5], #2
2487:                  pBDTEntryEP0OutNext->STAT.Val &= ~(_USIE);         
000DF4  805305     MOV pBDTEntryEP0OutNext, W5
000DF6  904315     MOV.B [W5+1], W6
000DF8  A17406     BCLR.B W6, #7
000DFA  984296     MOV.B W6, [W5+1]
2488:              
2489:                  inPipes[0].info.Val = 0;
000DFC  B7E806     MOV.B WREG, 0x806
2490:                  inPipes[0].wCount.Val = 0;
000DFE  EB0400     CLR W8
000E00  884048     MOV W8, 0x808
2491:                  outPipes[0].info.Val = 0;
000E02  B7E811     MOV.B WREG, 0x811
2492:                  outPipes[0].wCount.Val = 0;
000E04  208125     MOV #0x812, W5
000E06  784295     MOV.B [W5], W5
000E08  B7E812     MOV.B WREG, 0x812
000E0A  208135     MOV #0x813, W5
000E0C  784295     MOV.B [W5], W5
000E0E  B7E813     MOV.B WREG, 0x813
2493:                  
2494:              
2495:                  //--------------------------------------------------------------------------
2496:                  //2. Now find out what was in the SETUP packet, and begin handling the request.
2497:                  //--------------------------------------------------------------------------
2498:                  USBCheckStdRequest();                                               //Check for standard USB "Chapter 9" requests.
000E10  07FD51     RCALL _USBCheckStdRequest
2499:                  USB_NONSTANDARD_EP0_REQUEST_HANDLER(EVENT_EP0_REQUEST,0,0); //Check for USB device class specific requests
000E12  780108     MOV W8, W2
000E14  780088     MOV W8, W1
000E16  200030     MOV #0x3, W0
000E18  07FA8C     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2500:              
2501:              
2502:                  //--------------------------------------------------------------------------
2503:                  //3. Re-arm EP0 IN and EP0 OUT endpoints, based on the control transfer in 
2504:                  //   progress.  If one of the above handlers (in step 2) knew how to process
2505:                  //   the request, it will have set one of the inPipes[0].info.bits.busy or
2506:                  //   outPipes[0].info.bits.busy flags = 1.  This lets the
2507:                  //   USBCtrlEPServiceComplete() function know how and which endpoints to 
2508:                  //   arm.  If both info.bits.busy flags are = 0, then no one knew how to
2509:                  //   process the request.  In this case, the default behavior will be to
2510:                  //   perform protocol STALL on EP0.
2511:                  //-------------------------------------------------------------------------- 
2512:                  USBCtrlEPServiceComplete();
000E1A  07FF84     RCALL _USBCtrlEPServiceComplete
2513:              }//end USBCtrlTrfSetupHandler
000E1C  78044F     MOV [--W15], W8
000E1E  060000     RETURN
2514:              
2515:              
2516:              /******************************************************************************
2517:               * Function:        void USBCtrlTrfOutHandler(void)
2518:               *
2519:               * PreCondition:    None
2520:               *
2521:               * Input:           None
2522:               *
2523:               * Output:          None
2524:               *
2525:               * Side Effects:    None
2526:               *
2527:               * Overview:        This routine handles an OUT transaction according to
2528:               *                  which control transfer state is currently active.
2529:               *
2530:               * Note:            Note that if the the control transfer was from
2531:               *                  host to device, the session owner should be notified
2532:               *                  at the end of each OUT transaction to service the
2533:               *                  received data.
2534:               *
2535:               *****************************************************************************/
2536:              static void USBCtrlTrfOutHandler(void)
2537:              {
2538:                  if(controlTransferState == CTRL_TRF_RX)
000C8E  20A634     MOV #0xA63, W4
000C90  784214     MOV.B [W4], W4
000C92  524FE2     SUB.B W4, #0x2, [W15]
000C94  3A0002     BRA NZ, 0xC9A
2539:                  {
2540:                      USBCtrlTrfRxService();	//Copies the newly received data into the appropriate buffer and configures EP0 OUT for next transaction.
000C96  07FF7D     RCALL _USBCtrlTrfRxService
000C98  370013     BRA 0xCC0
2541:                  }
2542:                  else //In this case the last OUT transaction must have been a status stage of a CTRL_TRF_TX (<setup><in><in>...<OUT>  <-- this last OUT just occurred as the status stage)
2543:                  {
2544:                      //If the status stage is complete, this means we are done with the 
2545:                      //control transfer.  Go back to the idle "WAIT_SETUP" state.
2546:                      controlTransferState = WAIT_SETUP;
000C9A  EF6A63     CLR.B controlTransferState
2547:              
2548:                      //Prepare EP0 OUT for the next SETUP transaction, however, it may have
2549:                      //already been prepared if ping-pong buffering was enabled on EP0 OUT,
2550:                      //and the last control transfer was of direction: device to host, see
2551:                      //USBCtrlEPServiceComplete().  If it was already prepared, do not want
2552:                      //to do anything to the BDT.
2553:                      if(BothEP0OutUOWNsSet == false)
000C9C  20A684     MOV #0xA68, W4
000C9E  784214     MOV.B [W4], W4
000CA0  524FE0     SUB.B W4, #0x0, [W15]
000CA2  3A000D     BRA NZ, 0xCBE
2554:                      {
2555:                          pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000CA4  B3C085     MOV #0x8, W5
000CA6  805304     MOV pBDTEntryEP0OutNext, W4
000CA8  784A05     MOV.B W5, [W4]
2556:                          pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
000CAA  805304     MOV pBDTEntryEP0OutNext, W4
000CAC  20A4C5     MOV #0xA4C, W5
000CAE  980215     MOV W5, [W4+2]
2557:                          pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
000CB0  B3C0C5     MOV #0xC, W5
000CB2  984215     MOV.B W5, [W4+1]
2558:                          pBDTEntryEP0OutNext->STAT.Val |= _USIE;
000CB4  805304     MOV pBDTEntryEP0OutNext, W4
000CB6  904294     MOV.B [W4+1], W5
000CB8  A07405     BSET.B W5, #7
000CBA  984215     MOV.B W5, [W4+1]
000CBC  370001     BRA 0xCC0
2559:                      }
2560:                      else
2561:                      {
2562:                              BothEP0OutUOWNsSet = false;
000CBE  EF6A68     CLR.B BothEP0OutUOWNsSet
2563:                      }
2564:                  }
2565:              }
000CC0  060000     RETURN
2566:              
2567:              /******************************************************************************
2568:               * Function:        void USBCtrlTrfInHandler(void)
2569:               *
2570:               * PreCondition:    None
2571:               *
2572:               * Input:           None
2573:               *
2574:               * Output:          None
2575:               *
2576:               * Side Effects:    None
2577:               *
2578:               * Overview:        This routine handles an IN transaction according to
2579:               *                  which control transfer state is currently active.
2580:               *
2581:               * Note:            A Set Address Request must not change the acutal address
2582:               *                  of the device until the completion of the control
2583:               *                  transfer. The end of the control transfer for Set Address
2584:               *                  Request is an IN transaction. Therefore it is necessary
2585:               *                  to service this unique situation when the condition is
2586:               *                  right. Macro mUSBCheckAdrPendingState is defined in
2587:               *                  usb9.h and its function is to specifically service this
2588:               *                  event.
2589:               *****************************************************************************/
2590:              static void USBCtrlTrfInHandler(void)
2591:              {
00060E  781F88     MOV W8, [W15++]
2592:                  uint8_t lastDTS;
2593:              
2594:                  lastDTS = pBDTEntryIn[0]->STAT.DTS;
000610  8040D4     MOV pBDTEntryIn, W4
000612  780414     MOV [W4], W8
000614  DE444E     LSR W8, #14, W8
000616  644461     AND.B W8, #0x1, W8
2595:              
2596:                  //switch to the next ping pong buffer
2597:                  ((uint8_t_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
000618  AA481A     BTG pBDTEntryIn, #2
2598:              
2599:                  //Must check if in ADR_PENDING_STATE.  If so, we need to update the address
2600:                  //now, since the IN status stage of the (set address) control transfer has 
2601:                  //evidently completed successfully.
2602:                  if(USBDeviceState == ADR_PENDING_STATE)
00061A  804064     MOV USBDeviceState, W4
00061C  520FE8     SUB W4, #0x8, [W15]
00061E  3A000C     BRA NZ, 0x638
2603:                  {
2604:                      U1ADDR = (SetupPkt.bDevADR & 0x7F);
000620  20A4E4     MOV #0xA4E, W4
000622  784214     MOV.B [W4], W4
000624  B207F4     AND #0x7F, W4
000626  8824B4     MOV W4, U1ADDR
2605:                      if(U1ADDR != 0u)
000628  8024B4     MOV U1ADDR, W4
00062A  520FE0     SUB W4, #0x0, [W15]
00062C  320003     BRA Z, 0x634
2606:                      {
2607:                          USBDeviceState=ADDRESS_STATE;
00062E  200104     MOV #0x10, W4
000630  884064     MOV W4, USBDeviceState
000632  370002     BRA 0x638
2608:                      }
2609:                      else
2610:                      {
2611:                          USBDeviceState=DEFAULT_STATE;
000634  200044     MOV #0x4, W4
000636  884064     MOV W4, USBDeviceState
2612:                      }
2613:                  }//end if
2614:              
2615:              
2616:                  if(controlTransferState == CTRL_TRF_TX)
000638  20A634     MOV #0xA63, W4
00063A  784214     MOV.B [W4], W4
00063C  524FE1     SUB.B W4, #0x1, [W15]
00063E  3A0022     BRA NZ, 0x684
2617:                  {
2618:                      pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(CtrlTrfData);
000640  20A545     MOV #0xA54, W5
000642  8040D4     MOV pBDTEntryIn, W4
000644  980215     MOV W5, [W4+2]
2619:                      USBCtrlTrfTxService();
000646  07FF29     RCALL _USBCtrlTrfTxService
2620:              
2621:                      //Check if we have already sent a short packet.  If so, configure
2622:                      //the endpoint to STALL in response to any further IN tokens (in the
2623:                      //case that the host erroneously tries to receive more data than it
2624:                      //should).
2625:                      if(shortPacketStatus == SHORT_PKT_SENT)
000648  20A624     MOV #0xA62, W4
00064A  784214     MOV.B [W4], W4
00064C  524FE2     SUB.B W4, #0x2, [W15]
00064E  3A0008     BRA NZ, 0x660
2626:                      {
2627:                          // If a short packet has been sent, don't want to send any more,
2628:                          // stall next time if host is still trying to read.
2629:                          pBDTEntryIn[0]->STAT.Val = _BSTALL;
000650  B3C045     MOV #0x4, W5
000652  8040D4     MOV pBDTEntryIn, W4
000654  984215     MOV.B W5, [W4+1]
2630:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
000656  8040D4     MOV pBDTEntryIn, W4
000658  904294     MOV.B [W4+1], W5
00065A  A07405     BSET.B W5, #7
00065C  984215     MOV.B W5, [W4+1]
00065E  370028     BRA 0x6B0
2631:                      }
2632:                      else
2633:                      {
2634:                          if(lastDTS == 0)
000660  544FE0     SUB.B W8, #0x0, [W15]
000662  3A0008     BRA NZ, 0x674
2635:                          {
2636:                              pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
000664  B3C485     MOV #0x48, W5
000666  8040D4     MOV pBDTEntryIn, W4
000668  984215     MOV.B W5, [W4+1]
2637:                              pBDTEntryIn[0]->STAT.Val |= _USIE;
00066A  8040D4     MOV pBDTEntryIn, W4
00066C  904294     MOV.B [W4+1], W5
00066E  A07405     BSET.B W5, #7
000670  984215     MOV.B W5, [W4+1]
000672  37001E     BRA 0x6B0
2638:                          }
2639:                          else
2640:                          {
2641:                              pBDTEntryIn[0]->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
000674  B3C085     MOV #0x8, W5
000676  8040D4     MOV pBDTEntryIn, W4
000678  984215     MOV.B W5, [W4+1]
2642:                              pBDTEntryIn[0]->STAT.Val |= _USIE;
00067A  8040D4     MOV pBDTEntryIn, W4
00067C  904294     MOV.B [W4+1], W5
00067E  A07405     BSET.B W5, #7
000680  984215     MOV.B W5, [W4+1]
000682  370016     BRA 0x6B0
2643:                          }
2644:                      }//end if(...)else
2645:                  }
2646:              	else // must have been a CTRL_TRF_RX status stage IN packet (<setup><out><out>...<IN>  <-- this last IN just occurred as the status stage)
2647:              	{
2648:                      //if someone is still expecting data from the control transfer
2649:                      //  then make sure to terminate that request and let them know that
2650:                      //  they are done
2651:                      if(outPipes[0].info.bits.busy == 1)
000684  208114     MOV #0x811, W4
000686  784214     MOV.B [W4], W4
000688  524FE0     SUB.B W4, #0x0, [W15]
00068A  3D0011     BRA GE, 0x6AE
2652:                      {
2653:                          if(outPipes[0].pFunc != NULL)
00068C  208145     MOV #0x814, W5
00068E  784295     MOV.B [W5], W5
000690  FB8285     ZE W5, W5
000692  208154     MOV #0x815, W4
000694  784214     MOV.B [W4], W4
000696  DD2248     SL W4, #8, W4
000698  720205     IOR W4, W5, W4
00069A  320008     BRA Z, 0x6AC
2654:                          {
2655:                              outPipes[0].pFunc();
00069C  208145     MOV #0x814, W5
00069E  784295     MOV.B [W5], W5
0006A0  FB8285     ZE W5, W5
0006A2  208154     MOV #0x815, W4
0006A4  784214     MOV.B [W4], W4
0006A6  DD2248     SL W4, #8, W4
0006A8  720205     IOR W4, W5, W4
0006AA  010004     CALL W4
2656:                          }
2657:                          outPipes[0].info.bits.busy = 0;
0006AC  A9E811     BCLR 0x811, #7
2658:                      }
2659:                  	
2660:                      controlTransferState = WAIT_SETUP;
0006AE  EF6A63     CLR.B controlTransferState
2661:                      //Don't need to arm EP0 OUT here.  It was already armed by the last <out> that
2662:                      //got processed by the USBCtrlTrfRxService() handler.
2663:              	}	
2664:              
2665:              }
0006B0  78044F     MOV [--W15], W8
0006B2  060000     RETURN
2666:              
2667:              
2668:              /********************************************************************
2669:               * Function:        void USBCheckStdRequest(void)
2670:               *
2671:               * PreCondition:    None
2672:               *
2673:               * Input:           None
2674:               *
2675:               * Output:          None
2676:               *
2677:               * Side Effects:    None
2678:               *
2679:               * Overview:        This routine checks the setup data packet to see
2680:               *                  if it knows how to handle it
2681:               *
2682:               * Note:            None
2683:               *******************************************************************/
2684:              static void USBCheckStdRequest(void)
2685:              {
2686:                  if(SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD) return;
0008B4  20A4C4     MOV #0xA4C, W4
0008B6  784214     MOV.B [W4], W4
0008B8  B24604     AND.B #0x60, W4
0008BA  3A003F     BRA NZ, 0x93A
2687:              
2688:                  switch(SetupPkt.bRequest)
0008BC  20A4D4     MOV #0xA4D, W4
0008BE  784214     MOV.B [W4], W4
0008C0  FB8204     ZE W4, W4
0008C2  200005     MOV #0x0, W5
0008C4  520FEB     SUB W4, #0xB, [W15]
0008C6  5A8FE0     SUBB W5, #0x0, [W15]
0008C8  3E0038     BRA GTU, 0x93A
0008CA  016004     BRA W4
0008CC  37001A     BRA 0x902
0008CE  37001B     BRA 0x906
0008D0  370034     BRA 0x93A
0008D2  370019     BRA 0x906
0008D4  370032     BRA 0x93A
0008D6  370006     BRA 0x8E4
0008D8  370009     BRA 0x8EC
0008DA  37002B     BRA 0x932
0008DC  37000B     BRA 0x8F4
0008DE  370008     BRA 0x8F0
0008E0  370014     BRA 0x90A
0008E2  37001E     BRA 0x920
2689:                  {
2690:                      case USB_REQUEST_SET_ADDRESS:
2691:                          inPipes[0].info.bits.busy = 1;            // This will generate a zero length packet
0008E4  A8E806     BSET 0x806, #7
2692:                          USBDeviceState = ADR_PENDING_STATE;       // Update state only
0008E6  200084     MOV #0x8, W4
0008E8  884064     MOV W4, USBDeviceState
2693:                          /* See USBCtrlTrfInHandler() for the next step */
2694:                          break;
0008EA  370027     BRA 0x93A
2695:                      case USB_REQUEST_GET_DESCRIPTOR:
2696:                          USBStdGetDscHandler();
0008EC  07FE05     RCALL _USBStdGetDscHandler
2697:                          break;
0008EE  370025     BRA 0x93A
2698:                      case USB_REQUEST_SET_CONFIGURATION:
2699:                          USBStdSetCfgHandler();
0008F0  07FFBB     RCALL _USBStdSetCfgHandler
2700:                          break;
0008F2  370023     BRA 0x93A
2701:                      case USB_REQUEST_GET_CONFIGURATION:
2702:                          inPipes[0].pSrc.bRam = (uint8_t*)&USBActiveConfiguration;         // Set Source
0008F4  2080E4     MOV #0x80E, W4
0008F6  884024     MOV W4, inPipes
2703:                          inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
0008F8  A80806     BSET 0x806, #0
2704:                          inPipes[0].wCount.v[0] = 1;                         // Set data count
0008FA  B3C010     MOV #0x1, W0
0008FC  B7E808     MOV.B WREG, 0x808
2705:                          inPipes[0].info.bits.busy = 1;
0008FE  A8E806     BSET 0x806, #7
2706:                          break;
000900  37001C     BRA 0x93A
2707:                      case USB_REQUEST_GET_STATUS:
2708:                          USBStdGetStatusHandler();
000902  07FE36     RCALL _USBStdGetStatusHandler
2709:                          break;
000904  37001A     BRA 0x93A
2710:                      case USB_REQUEST_CLEAR_FEATURE:
2711:                      case USB_REQUEST_SET_FEATURE:
2712:                          USBStdFeatureReqHandler();
000906  07FEE9     RCALL _USBStdFeatureReqHandler
2713:                          break;
000908  370018     BRA 0x93A
2714:                      case USB_REQUEST_GET_INTERFACE:
2715:                          inPipes[0].pSrc.bRam = (uint8_t*)&USBAlternateInterface[SetupPkt.bIntfID];  // Set source
00090A  20A505     MOV #0xA50, W5
00090C  784295     MOV.B [W5], W5
00090E  FB8285     ZE W5, W5
000910  20A5C4     MOV #0xA5C, W4
000912  428204     ADD W5, W4, W4
000914  884024     MOV W4, inPipes
2716:                          inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
000916  A80806     BSET 0x806, #0
2717:                          inPipes[0].wCount.v[0] = 1;                         // Set data count
000918  B3C010     MOV #0x1, W0
00091A  B7E808     MOV.B WREG, 0x808
2718:                          inPipes[0].info.bits.busy = 1;
00091C  A8E806     BSET 0x806, #7
2719:                          break;
00091E  37000D     BRA 0x93A
2720:                      case USB_REQUEST_SET_INTERFACE:
2721:                          inPipes[0].info.bits.busy = 1;
000920  A8E806     BSET 0x806, #7
2722:                          USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
000922  20A504     MOV #0xA50, W4
000924  784214     MOV.B [W4], W4
000926  FB8204     ZE W4, W4
000928  20A5C5     MOV #0xA5C, W5
00092A  20A4E6     MOV #0xA4E, W6
00092C  784316     MOV.B [W6], W6
00092E  7A7286     MOV.B W6, [W5+W4]
2723:                          break;
000930  370004     BRA 0x93A
2724:                      case USB_REQUEST_SET_DESCRIPTOR:
2725:                          USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR,0,0);
000932  EB0100     CLR W2
000934  EB0080     CLR W1
000936  200020     MOV #0x2, W0
000938  07FCFC     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2726:                          break;
2727:                      case USB_REQUEST_SYNCH_FRAME:
2728:                      default:
2729:                          break;
2730:                  }//end switch
2731:              }//end USBCheckStdRequest
00093A  060000     RETURN
2732:              
2733:              /********************************************************************
2734:               * Function:        void USBStdFeatureReqHandler(void)
2735:               *
2736:               * PreCondition:    None
2737:               *
2738:               * Input:           None
2739:               *
2740:               * Output:          Can alter BDT entries.  Can also modify USB stack
2741:               *                  Maintained variables.
2742:               *
2743:               * Side Effects:    None
2744:               *
2745:               * Overview:        This routine handles the standard SET & CLEAR
2746:               *                  FEATURES requests
2747:               *
2748:               * Note:            This is a private function, intended for internal 
2749:               *                  use by the USB stack, when processing SET/CLEAR
2750:               *                  feature requests.  
2751:               *******************************************************************/
2752:              static void USBStdFeatureReqHandler(void)
2753:              {
0006DA  FA0002     LNK #0x2
0006DC  781F88     MOV W8, [W15++]
2754:                  BDT_ENTRY *p;
2755:                  EP_STATUS current_ep_data;
2756:                  #if defined(__C32__)
2757:                      uint32_t* pUEP;
2758:                  #else
2759:                      unsigned char* pUEP;             
2760:                  #endif
2761:                  
2762:              
2763:                  #ifdef	USB_SUPPORT_OTG
2764:                  //Check for USB On-The-Go (OTG) specific requests
2765:                  if ((SetupPkt.bFeature == OTG_FEATURE_B_HNP_ENABLE)&&
2766:                      (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2767:                  {  
2768:                      inPipes[0].info.bits.busy = 1;
2769:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2770:                          USBOTGEnableHnp();
2771:                      else
2772:                          USBOTGDisableHnp();
2773:                  }
2774:              
2775:                  if ((SetupPkt.bFeature == OTG_FEATURE_A_HNP_SUPPORT)&&
2776:                      (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2777:                  {
2778:                      inPipes[0].info.bits.busy = 1;
2779:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2780:                          USBOTGEnableSupportHnp();
2781:                      else
2782:                          USBOTGDisableSupportHnp();
2783:                  }
2784:              
2785:                  if ((SetupPkt.bFeature == OTG_FEATURE_A_ALT_HNP_SUPPORT)&&
2786:                      (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2787:                  {
2788:                      inPipes[0].info.bits.busy = 1;
2789:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2790:                          USBOTGEnableAltHnp();
2791:                      else
2792:                          USBOTGDisableAltHnp();
2793:                  }
2794:                  #endif   //#ifdef USB_SUPPORT_OTG 
2795:              
2796:                  //Check if the host sent a valid SET or CLEAR feature (remote wakeup) request.
2797:                  if((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP)&&
0006DE  20A4E4     MOV #0xA4E, W4
0006E0  784214     MOV.B [W4], W4
0006E2  524FE1     SUB.B W4, #0x1, [W15]
0006E4  3A000D     BRA NZ, 0x700
0006EC  3A0009     BRA NZ, 0x700
2798:                     (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
0006E6  20A4C4     MOV #0xA4C, W4
0006E8  784214     MOV.B [W4], W4
0006EA  62427F     AND.B W4, #0x1F, W4
2799:                  {
2800:                      inPipes[0].info.bits.busy = 1;
0006EE  A8E806     BSET 0x806, #7
2801:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
0006F0  20A4D4     MOV #0xA4D, W4
0006F2  784214     MOV.B [W4], W4
0006F4  524FE3     SUB.B W4, #0x3, [W15]
0006F6  3A0003     BRA NZ, 0x6FE
2802:                          RemoteWakeup = true;
0006F8  B3C010     MOV #0x1, W0
0006FA  B7E80A     MOV.B WREG, RemoteWakeup
0006FC  370001     BRA 0x700
2803:                      else
2804:                          RemoteWakeup = false;
0006FE  EF680A     CLR.B RemoteWakeup
2805:                  }//end if
2806:              
2807:                  //Check if the host sent a valid SET or CLEAR endpoint halt request.
2808:                  if((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT)&&
000700  20A4E4     MOV #0xA4E, W4
000702  784214     MOV.B [W4], W4
000704  524FE0     SUB.B W4, #0x0, [W15]
000706  3A00AD     BRA NZ, 0x862
00070E  524FE2     SUB.B W4, #0x2, [W15]
000710  3A00A8     BRA NZ, 0x862
2809:                     (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD)&&
000708  20A4C4     MOV #0xA4C, W4
00070A  784214     MOV.B [W4], W4
00070C  62427F     AND.B W4, #0x1F, W4
000718  3200A4     BRA Z, 0x862
2810:                     (SetupPkt.EPNum != 0) && (SetupPkt.EPNum <= USB_MAX_EP_NUMBER)&&
000712  20A504     MOV #0xA50, W4
000714  784214     MOV.B [W4], W4
000716  62426F     AND.B W4, #0xF, W4
00071A  20A504     MOV #0xA50, W4
00071C  784214     MOV.B [W4], W4
00071E  62026F     AND W4, #0xF, W4
000720  520FE1     SUB W4, #0x1, [W15]
000722  3C009F     BRA GT, 0x862
000726  200204     MOV #0x20, W4
000728  528F84     SUB W5, W4, [W15]
00072A  3A009B     BRA NZ, 0x862
2811:                     (USBDeviceState == CONFIGURED_STATE))
000724  804065     MOV USBDeviceState, W5
2812:                  {
2813:              		//The request was valid.  Take control of the control transfer and
2814:              		//perform the host requested action.
2815:              		inPipes[0].info.bits.busy = 1;
00072C  A8E806     BSET 0x806, #7
2816:              
2817:                      //Fetch a pointer to the BDT that the host wants to SET/CLEAR halt on.
2818:                      if(SetupPkt.EPDir == OUT_FROM_HOST)
00072E  20A504     MOV #0xA50, W4
000730  784214     MOV.B [W4], W4
000732  524FE0     SUB.B W4, #0x0, [W15]
000734  35000D     BRA LT, 0x750
2819:                      {
2820:                          p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
000736  20A504     MOV #0xA50, W4
000738  784214     MOV.B [W4], W4
00073A  62026F     AND W4, #0xF, W4
00073C  420204     ADD W4, W4, W4
00073E  208165     MOV #0x816, W5
000740  7A02E5     MOV [W5+W4], W5
000742  9FBFE5     MOV W5, [W15-4]
2821:                          current_ep_data.Val = ep_data_out[SetupPkt.EPNum].Val;
000744  20A504     MOV #0xA50, W4
000746  784214     MOV.B [W4], W4
000748  62026F     AND W4, #0xF, W4
00074A  20A6B5     MOV #0xA6B, W5
00074C  7A4465     MOV.B [W5+W4], W8
00074E  37000C     BRA 0x768
2822:                      }
2823:                      else
2824:                      {
2825:                          p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
000750  20A504     MOV #0xA50, W4
000752  784214     MOV.B [W4], W4
000754  62026F     AND W4, #0xF, W4
000756  420204     ADD W4, W4, W4
000758  2081A5     MOV #0x81A, W5
00075A  7A02E5     MOV [W5+W4], W5
00075C  9FBFE5     MOV W5, [W15-4]
2826:                          current_ep_data.Val = ep_data_in[SetupPkt.EPNum].Val;
00075E  20A504     MOV #0xA50, W4
000760  784214     MOV.B [W4], W4
000762  62026F     AND W4, #0xF, W4
000764  20A695     MOV #0xA69, W5
000766  7A4465     MOV.B [W5+W4], W8
2827:                      }
2828:              
2829:                      //If ping pong buffering is enabled on the requested endpoint, need 
2830:                      //to point to the one that is the active BDT entry which the SIE will 
2831:                      //use for the next attempted transaction on that EP number.
2832:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2833:                          if(current_ep_data.bits.ping_pong_state == 0) //Check if even
000768  644261     AND.B W8, #0x1, W4
00076A  3A0004     BRA NZ, 0x774
2834:                          {
2835:                              USBHALPingPongSetToEven(&p);
00076C  97FA4F     MOV.B [W15-4], W4
00076E  A12404     BCLR.B W4, #2
000770  9FFFC4     MOV.B W4, [W15-4]
000772  370003     BRA 0x77A
2836:                          }
2837:                          else //else must have been odd
2838:                          {
2839:                              USBHALPingPongSetToOdd(&p);
000774  97FACF     MOV.B [W15-4], W5
000776  A02405     BSET.B W5, #2
000778  9FFFC5     MOV.B W5, [W15-4]
2840:                          }
2841:                      #endif
2842:                      
2843:                      //Update the BDT pointers with the new, next entry based on the feature
2844:                      //  request
2845:                      if(SetupPkt.EPDir == OUT_FROM_HOST)
00077A  20A504     MOV #0xA50, W4
00077C  784214     MOV.B [W4], W4
00077E  524FE0     SUB.B W4, #0x0, [W15]
000780  350008     BRA LT, 0x792
2846:                      {
2847:                          pBDTEntryOut[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
000782  20A504     MOV #0xA50, W4
000784  784214     MOV.B [W4], W4
000786  62026F     AND W4, #0xF, W4
000788  420204     ADD W4, W4, W4
00078A  208165     MOV #0x816, W5
00078C  97BB6F     MOV [W15-4], W6
00078E  7A3286     MOV W6, [W5+W4]
000790  370007     BRA 0x7A0
2848:                      }
2849:                      else
2850:                      {
2851:                          pBDTEntryIn[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
000792  20A504     MOV #0xA50, W4
000794  784214     MOV.B [W4], W4
000796  62026F     AND W4, #0xF, W4
000798  420204     ADD W4, W4, W4
00079A  2081A5     MOV #0x81A, W5
00079C  97B86F     MOV [W15-4], W0
00079E  7A3280     MOV W0, [W5+W4]
2852:                      }
2853:              
2854:              		//Check if it was a SET_FEATURE endpoint halt request
2855:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
0007A0  20A4D4     MOV #0xA4D, W4
0007A2  784214     MOV.B [W4], W4
0007A4  524FE3     SUB.B W4, #0x3, [W15]
0007A6  3A001D     BRA NZ, 0x7E2
2856:                      {
2857:                          if(p->STAT.UOWN == 1)
0007A8  97BA6F     MOV [W15-4], W4
0007AA  EB0280     CLR W5
0007AC  128F94     SUBR W5, [W4], [W15]
0007AE  3D0013     BRA GE, 0x7D6
2858:                          {
2859:                              //Mark that we are terminating this transfer and that the user
2860:                              //  needs to be notified later
2861:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
0007B0  20A504     MOV #0xA50, W4
0007B2  784214     MOV.B [W4], W4
0007B4  524FE0     SUB.B W4, #0x0, [W15]
0007B6  350008     BRA LT, 0x7C8
2862:                              {
2863:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 1;
0007B8  20A505     MOV #0xA50, W5
0007BA  784295     MOV.B [W5], W5
0007BC  6282EF     AND W5, #0xF, W5
0007BE  20A6B6     MOV #0xA6B, W6
0007C0  7AC266     MOV.B [W6+W5], W4
0007C2  A01004     BSET W4, #1
0007C4  7AF304     MOV.B W4, [W6+W5]
0007C6  370007     BRA 0x7D6
2864:                              }
2865:                              else
2866:                              {
2867:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 1;
0007C8  20A505     MOV #0xA50, W5
0007CA  784295     MOV.B [W5], W5
0007CC  6282EF     AND W5, #0xF, W5
0007CE  20A696     MOV #0xA69, W6
0007D0  7AC266     MOV.B [W6+W5], W4
0007D2  A01004     BSET W4, #1
0007D4  7AF304     MOV.B W4, [W6+W5]
2868:                              }
2869:                          }
2870:              
2871:              			//Then STALL the endpoint
2872:                          p->STAT.Val |= _BSTALL;
0007D6  97BA6F     MOV [W15-4], W4
2873:                          p->STAT.Val |= _USIE;
0007D8  904314     MOV.B [W4+1], W6
0007DA  B3C845     MOV #0x84, W5
0007DC  734285     IOR.B W6, W5, W5
0007DE  984215     MOV.B W5, [W4+1]
0007E0  370040     BRA 0x862
2874:                      }//if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2875:                      else
2876:                      {
2877:              			//Else the request must have been a CLEAR_FEATURE endpoint halt.
2878:                          #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2879:                              //toggle over the to the non-active BDT
2880:                              USBAdvancePingPongBuffer(&p);  
0007E2  97FB4F     MOV.B [W15-4], W6
0007E4  A22406     BTG.B W6, #2
0007E6  9FFFC6     MOV.B W6, [W15-4]
2881:              
2882:                              if(p->STAT.UOWN == 1)
0007E8  97B8EF     MOV [W15-4], W1
0007EA  EB0000     CLR W0
0007EC  100F91     SUBR W0, [W1], [W15]
0007EE  3D0008     BRA GE, 0x800
2883:                              {
2884:                                  //Clear UOWN and set DTS state so it will be correct the next time
2885:                                  //the application firmware uses USBTransferOnePacket() on the EP.
2886:                                  p->STAT.Val &= (~_USIE);    //Clear UOWN bit
0007F0  904211     MOV.B [W1+1], W4
0007F2  A17404     BCLR.B W4, #7
2887:                                  p->STAT.Val |= _DAT1;       //Set DTS to DATA1
0007F4  A06404     BSET.B W4, #6
0007F6  984094     MOV.B W4, [W1+1]
2888:                                  USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
0007F8  200022     MOV #0x2, W2
0007FA  200050     MOV #0x5, W0
0007FC  07FD9A     RCALL USER_USB_CALLBACK_EVENT_HANDLER
0007FE  370003     BRA 0x806
2889:                              }
2890:                              else
2891:                              {
2892:                                  //UOWN already clear, but still need to set DTS to DATA1     
2893:              					p->STAT.Val |= _DAT1;
000800  904211     MOV.B [W1+1], W4
000802  A06404     BSET.B W4, #6
000804  984094     MOV.B W4, [W1+1]
2894:                              }
2895:              
2896:                              //toggle back to the active BDT (the one the SIE is currently looking at
2897:                              //and will use for the next successful transaction to take place on the EP
2898:                              USBAdvancePingPongBuffer(&p);    
000806  97FA4F     MOV.B [W15-4], W4
000808  A22404     BTG.B W4, #2
00080A  9FFFC4     MOV.B W4, [W15-4]
2899:                              
2900:                              //Check if we are currently terminating, or have previously terminated
2901:                              //a transaction on the given endpoint.  If so, need to clear UOWN,
2902:                              //set DTS to the proper state, and call the application callback
2903:                              //function.
2904:                              if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
00080C  644462     AND.B W8, #0x2, W8
00080E  3A0004     BRA NZ, 0x818
000810  97BA6F     MOV [W15-4], W4
000812  EB0280     CLR W5
000814  128F94     SUBR W5, [W4], [W15]
000816  3D001B     BRA GE, 0x84E
2905:                              {
2906:                                  if(SetupPkt.EPDir == OUT_FROM_HOST)
000818  20A504     MOV #0xA50, W4
00081A  784214     MOV.B [W4], W4
00081C  524FE0     SUB.B W4, #0x0, [W15]
00081E  350008     BRA LT, 0x830
2907:                                  {
2908:                                      ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
000820  20A505     MOV #0xA50, W5
000822  784295     MOV.B [W5], W5
000824  6282EF     AND W5, #0xF, W5
000826  20A6B6     MOV #0xA6B, W6
000828  7AC266     MOV.B [W6+W5], W4
00082A  A11004     BCLR W4, #1
00082C  7AF304     MOV.B W4, [W6+W5]
00082E  370007     BRA 0x83E
2909:                                  }
2910:                                  else
2911:                                  {
2912:                                      ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
000830  20A505     MOV #0xA50, W5
000832  784295     MOV.B [W5], W5
000834  6282EF     AND W5, #0xF, W5
000836  20A696     MOV #0xA69, W6
000838  7AC266     MOV.B [W6+W5], W4
00083A  A11004     BCLR W4, #1
00083C  7AF304     MOV.B W4, [W6+W5]
2913:                                  }
2914:                                  //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
2915:                                  p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);  
00083E  97B8EF     MOV [W15-4], W1
000840  904211     MOV.B [W1+1], W4
000842  B243B4     AND.B #0x3B, W4
000844  984094     MOV.B W4, [W1+1]
2916:                                  //Call the application event handler callback function, so it can 
2917:              					//decide if the endpoint should get re-armed again or not.
2918:                                  USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
000846  200022     MOV #0x2, W2
000848  200050     MOV #0x5, W0
00084A  07FD73     RCALL USER_USB_CALLBACK_EVENT_HANDLER
00084C  370003     BRA 0x854
2919:                              }
2920:                              else
2921:                              {
2922:                                  //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
2923:                                  p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL); 
00084E  904294     MOV.B [W4+1], W5
000850  B243B5     AND.B #0x3B, W5
000852  984215     MOV.B W5, [W4+1]
2924:                              } 
2925:                          #else //else we must not be using ping-pong buffering on the requested endpoint
2926:                              //Check if we need to call the user transfer terminated event callback function.
2927:                              //We should call the callback, if the endpoint was previously terminated,
2928:                              //or the endpoint is currently armed, and the host is performing clear
2929:                              //endpoint halt, even though the endpoint wasn't stalled.
2930:                              if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
2931:                              {
2932:                                  //We are going to call the user transfer terminated callback.
2933:                                  //Clear the flag so we know we took care of it and don't need
2934:                                  //to call it again later.
2935:                                  if(SetupPkt.EPDir == OUT_FROM_HOST)
2936:                                  {
2937:                                      ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
2938:                                  }
2939:                                  else
2940:                                  {
2941:                                      ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
2942:                                  }
2943:               
2944:                                  //Clear UOWN and remove the STALL condition.   
2945:                                  //  In this case we also need to set the DTS bit to 1 so that
2946:                                  //  it toggles to DATA0 the next time the application firmware
2947:                                  //  calls USBTransferOnePacket() (or equivalent macro).  
2948:                                  p->STAT.Val &= ~(_USIE | _BSTALL);  
2949:                                  p->STAT.Val |= _DAT1;
2950:                                  //Let the application firmware know a transaction just
2951:                                  //got terminated by the host, and that it is now free to
2952:                                  //re-arm the endpoint or do other tasks if desired.                                        
2953:                                  USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
2954:                              }
2955:                              else
2956:                              {
2957:                                  //Clear UOWN and remove the STALL condition.   
2958:                                  //  In this case we also need to set the DTS bit to 1 so that
2959:                                  //  it toggles to DATA0 the next time the application firmware
2960:                                  //  calls USBTransferOnePacket() (or equivalent macro).  
2961:                                  p->STAT.Val &= ~(_USIE | _BSTALL);  
2962:                                  p->STAT.Val |= _DAT1;
2963:                              } 
2964:                          #endif //end of #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2965:                          
2966:              			//Get a pointer to the appropriate UEPn register
2967:                          #if defined(__C32__)
2968:                              pUEP = (uint32_t*)(&U1EP0);
2969:                              pUEP += (SetupPkt.EPNum*4);
2970:                          #else
2971:                              pUEP = (unsigned char*)(&U1EP0+SetupPkt.EPNum);
000854  20A504     MOV #0xA50, W4
000856  784214     MOV.B [W4], W4
000858  62026F     AND W4, #0xF, W4
00085A  420204     ADD W4, W4, W4
00085C  204AA5     MOV #0x4AA, W5
00085E  420205     ADD W4, W5, W4
2972:                          #endif
2973:              
2974:              			//Clear the STALL bit in the UEP register
2975:                          *pUEP &= ~UEP_STALL;            
000860  A11414     BCLR.B [W4], #1
2976:                      }//end if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2977:                  }//end if (lots of checks for set/clear endpoint halt)
2978:              }//end USBStdFeatureReqHandler
000862  78044F     MOV [--W15], W8
000864  FA8000     ULNK
000866  060000     RETURN
2979:              
2980:              
2981:              /** EOF USBDevice.c *****************************************************/
---  F:/microchip/mla/v2013_12_20/apps/usb/device/msd_internal_flash/firmware/src/system_config/tvserver/system.c
1:                 /********************************************************************
2:                  Software License Agreement:
3:                 
4:                  The software supplied herewith by Microchip Technology Incorporated
5:                  (the "Company") for its PIC(R) Microcontroller is intended and
6:                  supplied to you, the Company's customer, for use solely and
7:                  exclusively on Microchip PIC Microcontroller products. The
8:                  software is owned by the Company and/or its supplier, and is
9:                  protected under applicable copyright laws. All rights are reserved.
10:                 Any use in violation of the foregoing restrictions may subject the
11:                 user to criminal sanctions under applicable laws, as well as to
12:                 civil liability for the breach of the terms and conditions of this
13:                 license.
14:                
15:                 THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
16:                 WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
17:                 TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
18:                 PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
19:                 IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
20:                 CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
21:                 *******************************************************************/
22:                
23:                #include <system.h>
24:                #include <system_config.h>
25:                #include <usb/usb.h>
26:                
27:                #include <xc.h>
28:                
29:                // CONFIG4
30:                #pragma config DSWDTPS = DSWDTPSF       // DSWDT Postscale Select (1:2,147,483,648 (25.7 days))
31:                #pragma config DSWDTOSC = LPRC          // Deep Sleep Watchdog Timer Oscillator Select (DSWDT uses Low Power RC Oscillator (LPRC))
32:                #pragma config RTCOSC = LPRC            // RTCC Reference Oscillator  Select (RTCC uses Low Power RC Oscillator (LPRC))
33:                #pragma config DSBOREN = ON             // Deep Sleep BOR Enable bit (BOR enabled in Deep Sleep)
34:                #pragma config DSWDTEN = ON             // Deep Sleep Watchdog Timer (DSWDT enabled)
35:                
36:                // CONFIG3
37:                #pragma config WPFP = WPFP63            // Write Protection Flash Page Segment Boundary (Highest Page (same as page 42))
38:                #pragma config SOSCSEL = IO             // Secondary Oscillator Pin Mode Select (SOSC pins have digital I/O functions (RA4, RB4))
39:                #pragma config WUTSEL = LEG             // Voltage Regulator Wake-up Time Select (Default regulator start-up time used)
40:                #pragma config WPDIS = WPDIS            // Segment Write Protection Disable (Segmented code protection disabled)
41:                #pragma config WPCFG = WPCFGDIS         // Write Protect Configuration Page Select (Last page and Flash Configuration words are unprotected)
42:                #pragma config WPEND = WPENDMEM         // Segment Write Protection End Page Select (Write Protect from WPFP to the last page of memory)
43:                
44:                // CONFIG2
45:                #pragma config POSCMOD = NONE           // Primary Oscillator Select (Primary Oscillator disabled)
46:                #pragma config I2C1SEL = PRI            // I2C1 Pin Select bit (Use default SCL1/SDA1 pins for I2C1 )
47:                #pragma config IOL1WAY = OFF            // IOLOCK One-Way Set Disable
48:                #pragma config OSCIOFNC = OFF           // OSCO Pin Configuration (OSCO pin functions as clock output (CLKO))
49:                #pragma config FCKSM = CSDCMD           // Clock Switching and Fail-Safe Clock Monitor (Sw Disabled, Mon Disabled)
50:                #pragma config FNOSC = FRCPLL           // Initial Oscillator Select (32 MHz CPU clock)
51:                #pragma config PLL96MHZ = ON            // 96MHz PLL Startup Select (96 MHz PLL Startup is enabled automatically on start-up)
52:                #pragma config PLLDIV = NODIV           // USB 96 MHz PLL Prescaler Select (Oscillator input = default FRC 4MHz)
53:                #pragma config IESO = ON                // Internal External Switchover (IESO mode (Two-Speed Start-up) enabled)
54:                
55:                // CONFIG1
56:                #pragma config WDTPS = PS32768          // Watchdog Timer Postscaler (1:32,768)
57:                #pragma config FWPSA = PR128            // WDT Prescaler (Prescaler ratio of 1:128)
58:                #pragma config WINDIS = OFF             // Windowed WDT (Standard Watchdog Timer enabled,(Windowed-mode is disabled))
59:                #pragma config FWDTEN = ON              // Watchdog Timer (Watchdog Timer is enabled)
60:                #pragma config ICS = PGx3               // Emulator Pin Placement Select bits (Emulator functions are shared with PGEC3/PGED3)
61:                #pragma config GWRP = OFF               // General Segment Write Protect (Writes to program memory are allowed)
62:                #pragma config GCP = ON                 // General Segment Code Protect (Code protection is enabled for the entire program memory space)
63:                #pragma config JTAGEN = OFF             // JTAG Port Enable (JTAG port is disabled)
64:                
65:                /*********************************************************************
66:                * Function: void SYSTEM_Initialize( SYSTEM_STATE state )
67:                *
68:                * Overview: Initializes the system.
69:                *
70:                * PreCondition: None
71:                *
72:                * Input:  SYSTEM_STATE - the state to initialize the system into
73:                *
74:                * Output: None
75:                *
76:                ********************************************************************/
77:                void SYSTEM_Initialize( void )
78:                {
79:                
80:                    // Disable analog inputs
81:                    AD1PCFG = 0xFFFF;
002456  EFA32C     SETM AD1PCFG
82:                }
002458  060000     RETURN
83:                
84:                #if defined(USB_INTERRUPT)
85:                void __attribute__((interrupt,auto_psv)) _USB1Interrupt()
86:                {
00245A  F80036     PUSH RCOUNT
00245C  BE9F80     MOV.D W0, [W15++]
00245E  BE9F82     MOV.D W2, [W15++]
002460  BE9F84     MOV.D W4, [W15++]
002462  BE9F86     MOV.D W6, [W15++]
002464  F80034     PUSH PSVPAG
002466  200000     MOV #0x0, W0
002468  8801A0     MOV W0, PSVPAG
87:                    USBDeviceTasks();
00246A  07F50E     RCALL USBDeviceTasks
88:                }
00246C  F90034     POP PSVPAG
00246E  BE034F     MOV.D [--W15], W6
002470  BE024F     MOV.D [--W15], W4
002472  BE014F     MOV.D [--W15], W2
002474  BE004F     MOV.D [--W15], W0
002476  F90036     POP RCOUNT
002478  064000     RETFIE
89:                #endif
---  F:/microchip/mla/v2013_12_20/apps/usb/device/msd_internal_flash/firmware/src/main.c  ---------------
1:                 /********************************************************************
2:                  Software License Agreement:
3:                 
4:                  The software supplied herewith by Microchip Technology Incorporated
5:                  (the "Company") for its PIC(R) Microcontroller is intended and
6:                  supplied to you, the Company's customer, for use solely and
7:                  exclusively on Microchip PIC Microcontroller products. The
8:                  software is owned by the Company and/or its supplier, and is
9:                  protected under applicable copyright laws. All rights are reserved.
10:                 Any use in violation of the foregoing restrictions may subject the
11:                 user to criminal sanctions under applicable laws, as well as to
12:                 civil liability for the breach of the terms and conditions of this
13:                 license.
14:                
15:                 THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
16:                 WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
17:                 TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
18:                 PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
19:                 IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
20:                 CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
21:                ********************************************************************/
22:                
23:                /** INCLUDES *******************************************************/
24:                #include <system.h>
25:                #include <system_config.h>
26:                
27:                #include <usb/usb.h>
28:                #include <usb/usb_device_msd.h>
29:                
30:                #include "app_device_msd.h"
31:                #include "ethernet/wizchip_conf.h"
32:                
33:                // bytes allocated to sockets
34:                uint8_t tx_buffer_sizes[_WIZCHIP_SOCK_NUM_] = { 1500, 0, 0, 0, 0, 0, 0, 0 };  // TX buffers
35:                uint8_t rx_buffer_sizes[_WIZCHIP_SOCK_NUM_] = { 1500, 0, 0, 0, 0, 0, 0, 0 };  // RX buffers
36:                
37:                extern bool poll_net(uint32_t lba,uint8_t *sector_buffer);
38:                
39:                #define DD_LED TRISBbits.TRISB15
40:                #define LED LATBbits.LATB15
41:                
42:                static unsigned char flag=0;
43:                
44:                volatile uint16_t ticker;
45:                
46:                void __attribute__((interrupt,auto_psv)) _T1Interrupt()
47:                {
0002B0  F80034     PUSH PSVPAG
0002B2  781F88     MOV W8, [W15++]
0002B4  200008     MOV #0x0, W8
0002B6  8801A8     MOV W8, PSVPAG
0002B8  78044F     MOV [--W15], W8
48:                    ticker++;
0002BA  EC2B44     INC ticker
49:                    
50:                  IFS0bits.T1IF = 0;
0002BC  A96084     BCLR IFS0, #3
51:                }
0002BE  F90034     POP PSVPAG
0002C0  064000     RETFIE
52:                
53:                void toggle(uint8_t state)
54:                {
55:                    if(state==0 || state==1)
0002C2  504FE1     SUB.B W0, #0x1, [W15]
0002C4  3E0007     BRA GTU, 0x2D4
56:                        LED = state;
0002C6  DD004F     SL W0, #15, W0
0002C8  27FFF4     MOV #0x7FFF, W4
0002CA  801665     MOV LATB, W5
0002CC  620205     AND W4, W5, W4
0002CE  720000     IOR W4, W0, W0
0002D0  881660     MOV W0, LATB
0002D2  37000A     BRA 0x2E8
57:                    else
58:                        LED ^= 1;
0002D4  801665     MOV LATB, W5
0002D6  DE2ACF     LSR W5, #15, W5
0002D8  A20405     BTG.B W5, #0
0002DA  FB8285     ZE W5, W5
0002DC  DD2ACF     SL W5, #15, W5
0002DE  27FFF4     MOV #0x7FFF, W4
0002E0  801666     MOV LATB, W6
0002E2  620206     AND W4, W6, W4
0002E4  720205     IOR W4, W5, W4
0002E6  881664     MOV W4, LATB
59:                }
0002E8  060000     RETURN
60:                
61:                MAIN_RETURN main(void)
62:                {
0002EA  FA0004     LNK #0x4
0002EC  BE9F88     MOV.D W8, [W15++]
0002EE  781F8A     MOV W10, [W15++]
63:                    wiz_PhyConf phy;
64:                
65:                //    SYSTEM_Initialize(SYSTEM_STATE_USB_START);
66:                
67:                    LED=1;
0002F0  A8E2CD     BSET 0x2CD, #7
68:                    DD_LED=0;
0002F2  A9E2C9     BCLR 0x2C9, #7
69:                
70:                    // Start timer1, clock=Fosc/2, set period to 1ms
71:                    T1CON = 32768;
0002F4  280004     MOV #0x8000, W4
0002F6  880824     MOV W4, T1CON
72:                    PR1 = 16384;
0002F8  240004     MOV #0x4000, W4
0002FA  880814     MOV W4, PR1
73:                    IEC0bits.T1IE = 1;
0002FC  A86094     BSET IEC0, #3
74:                
75:                    USBDeviceInit();
0002FE  07031E     RCALL USBDeviceInit
76:                    USBDeviceAttach();
000300  070400     RCALL USBDeviceAttach
77:                
78:                    wizchip_init(&tx_buffer_sizes,&rx_buffer_sizes);
000302  20B3C1     MOV #0xB3C, W1
000304  20B340     MOV #0xB34, W0
000306  070FBC     RCALL wizchip_init
79:                
80:                    phy.by = PHY_CONFBY_HW;
000308  EB4200     CLR.B W4
00030A  9FF7E4     MOV.B W4, [W15-10]
81:                    phy.mode = PHY_MODE_AUTONEGO;
00030C  B3C014     MOV #0x1, W4
00030E  9FF7F4     MOV.B W4, [W15-9]
82:                    wizphy_setphyconf(&phy);
000310  57806A     SUB W15, #0xA, W0
000312  071049     RCALL wizphy_setphyconf
83:                
84:                    LED=0;
000314  A9E2CD     BCLR 0x2CD, #7
85:                    
86:                    while(1)
87:                    {
88:                        ClrWdt();
00031C  FE6000     CLRWDT
89:                
90:                        poll_net(-1,NULL);
000316  EB0500     CLR W10
000318  EB8400     SETM W8
00031A  EB8480     SETM W9
00031E  78010A     MOV W10, W2
000320  BE0008     MOV.D W8, W0
000322  070E8C     RCALL poll_net
91:                
92:                        SYSTEM_Tasks();
93:                
94:                        #if defined(USB_POLLING)
95:                
96:                            // Interrupt or polling method.  If using polling, must call
97:                            // this function periodically.  This function will take care
98:                            // of processing and responding to SETUP transactions
99:                            // (such as during the enumeration process when you first
100:                           // plug in).  USB hosts require that USB devices should accept
101:                           // and process SETUP packets in a timely fashion.  Therefore,
102:                           // when using polling, this function should be called
103:                           // regularly (such as once every 1.8ms or faster** [see
104:                           // inline code comments in usb_device.c for explanation when
105:                           // "or faster" applies])  In most cases, the USBDeviceTasks()
106:                           // function does not take very long to execute (ex: <100
107:                           // instruction cycles) before it returns.
108:                           USBDeviceTasks();
109:                       #endif
110:               
111:                       /* If the USB device isn't configured yet, we can't really do anything
112:                        * else since we don't have a host to talk to.  So jump back to the
113:                        * top of the while loop. */
114:                       if( USBGetDeviceState() < CONFIGURED_STATE )
000324  804064     MOV USBDeviceState, W4
000326  520FFF     SUB W4, #0x1F, [W15]
000328  36FFF9     BRA LEU, 0x31C
115:                       {
116:                           /* Jump back to the top of the while loop. */
117:                           continue;
118:                       }
119:               
120:                       /* If we are currently suspended, then we need to see if we need to
121:                        * issue a remote wakeup.  In either case, we shouldn't process any
122:                        * keyboard commands since we aren't currently communicating to the host
123:                        * thus just continue back to the start of the while loop. */
124:                       if( USBIsDeviceSuspended() == true )
00032A  AB2488     BTST U1PWRC, #1
00032C  3AFFF7     BRA NZ, 0x31C
125:                       {
126:                           /* Jump back to the top of the while loop. */
127:                           continue;
128:                       }
129:               
130:                       //Application specific tasks
131:                       APP_DeviceMSDTasks();
00032E  070F76     RCALL APP_DeviceMSDTasks
000330  37FFF5     BRA 0x31C
132:               
133:                   }//end while
134:               }//end main
135:               
136:               
137:               /*******************************************************************
138:                * Function:        bool USER_USB_CALLBACK_EVENT_HANDLER(
139:                *                        USB_EVENT event, void *pdata, uint16_t size)
140:                *
141:                * PreCondition:    None
142:                *
143:                * Input:           USB_EVENT event - the type of event
144:                *                  void *pdata - pointer to the event data
145:                *                  uint16_t size - size of the event data
146:                *
147:                * Output:          None
148:                *
149:                * Side Effects:    None
150:                *
151:                * Overview:        This function is called from the USB stack to
152:                *                  notify a user application that a USB event
153:                *                  occured.  This callback is in interrupt context
154:                *                  when the USB_INTERRUPT option is selected.
155:                *
156:                * Note:            None
157:                *******************************************************************/
158:               bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size)
159:               {
160:                   switch((int)event)
000332  500FE3     SUB W0, #0x3, [W15]
000334  320006     BRA Z, 0x342
000336  500FE5     SUB W0, #0x5, [W15]
000338  320006     BRA Z, 0x346
00033A  500FE1     SUB W0, #0x1, [W15]
00033C  3A0018     BRA NZ, 0x36E
161:                   {
162:                       case EVENT_TRANSFER:
163:                           //Add application specific callback task or callback function here if desired.
164:                           break;
165:               
166:                       case EVENT_SOF:
167:                           break;
168:               
169:                       case EVENT_SUSPEND:
170:                           break;
171:               
172:                       case EVENT_RESUME:
173:                           break;
174:               
175:                       case EVENT_CONFIGURED:
176:                           /* When the device is configured, we can (re)initialize the demo
177:                            * code. */
178:                           APP_DeviceMSDInitialize();
00033E  070F69     RCALL APP_DeviceMSDInitialize
179:                           break;
000340  370016     BRA 0x36E
180:               
181:                       case EVENT_SET_DESCRIPTOR:
182:                           break;
183:               
184:                       case EVENT_EP0_REQUEST:
185:                           /* We have received a non-standard USB request.  The MSD driver
186:                            * needs to check to see if the request was for it. */
187:                           USBCheckMSDRequest();
000342  070650     RCALL USBCheckMSDRequest
188:                           break;
000344  370014     BRA 0x36E
189:               
190:                       case EVENT_BUS_ERROR:
191:                           break;
192:               
193:                       case EVENT_TRANSFER_TERMINATED:
194:                           //Add application specific callback task or callback function here if desired.
195:                           //The EVENT_TRANSFER_TERMINATED event occurs when the host performs a CLEAR
196:                           //FEATURE (endpoint halt) request on an application endpoint which was
197:                           //previously armed (UOWN was = 1).  Here would be a good place to:
198:                           //1.  Determine which endpoint the transaction that just got terminated was
199:                           //      on, by checking the handle value in the *pdata.
200:                           //2.  Re-arm the endpoint if desired (typically would be the case for OUT
201:                           //      endpoints).
202:               
203:                           //Check if the host recently did a clear endpoint halt on the MSD OUT endpoint.
204:                           //In this case, we want to re-arm the MSD OUT endpoint, so we are prepared
205:                           //to receive the next CBW that the host might want to send.
206:                           //Note: If however the STALL was due to a CBW not valid condition,
207:                           //then we are required to have a persistent STALL, where it cannot
208:                           //be cleared (until MSD reset recovery takes place).  See MSD BOT
209:                           //specs v1.0, section 6.6.1.
210:                           if(MSDWasLastCBWValid() == false)
000346  20A754     MOV #0xA75, W4
000348  784214     MOV.B [W4], W4
00034A  524FE0     SUB.B W4, #0x0, [W15]
00034C  3A0007     BRA NZ, 0x35C
211:                           {
212:                               //Need to re-stall the endpoints, for persistent STALL behavior.
213:                               USBStallEndpoint(MSD_DATA_IN_EP, IN_TO_HOST);
00034E  B3C011     MOV #0x1, W1
000350  784001     MOV.B W1, W0
000352  07038C     RCALL USBStallEndpoint
214:                               USBStallEndpoint(MSD_DATA_OUT_EP, OUT_FROM_HOST);
000354  EB4080     CLR.B W1
000356  B3C010     MOV #0x1, W0
000358  070389     RCALL USBStallEndpoint
00035A  370009     BRA 0x36E
215:                           }
216:                           else
217:                           {
218:                               //Check if the host cleared halt on the bulk out endpoint.  In this
219:                               //case, we should re-arm the endpoint, so we can receive the next CBW.
220:                               if((USB_HANDLE)pdata == USBGetNextHandle(MSD_DATA_OUT_EP, OUT_FROM_HOST))
00035C  8040C4     MOV 0x818, W4
00035E  520F81     SUB W4, W1, [W15]
000360  3A0006     BRA NZ, 0x36E
221:                               {
222:                                   USBMSDOutHandle = USBRxOnePacket(MSD_DATA_OUT_EP, (uint8_t*)&msd_cbw, MSD_OUT_EP_SIZE);
000362  B3C403     MOV #0x40, W3
000364  2081E2     MOV #0x81E, W2
000366  EB4080     CLR.B W1
000368  B3C010     MOV #0x1, W0
00036A  070356     RCALL USBTransferOnePacket
00036C  885380     MOV W0, USBMSDOutHandle
223:                               }
224:                           }
225:                           break;
226:               
227:                       default:
228:                           break;
229:                   }
230:                   return true;
231:               }
00036E  B3C010     MOV #0x1, W0
000370  060000     RETURN
232:               
233:               /*******************************************************************************
234:                End of File
235:               */
236:               
---  F:/microchip/mla/v2013_12_20/apps/usb/device/msd_internal_flash/firmware/src/app_device_msd.c  -----
1:                 /********************************************************************
2:                  Software License Agreement:
3:                 
4:                  The software supplied herewith by Microchip Technology Incorporated
5:                  (the "Company") for its PIC(R) Microcontroller is intended and
6:                  supplied to you, the Company's customer, for use solely and
7:                  exclusively on Microchip PIC Microcontroller products. The
8:                  software is owned by the Company and/or its supplier, and is
9:                  protected under applicable copyright laws. All rights are reserved.
10:                 Any use in violation of the foregoing restrictions may subject the
11:                 user to criminal sanctions under applicable laws, as well as to
12:                 civil liability for the breach of the terms and conditions of this
13:                 license.
14:                
15:                 THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
16:                 WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
17:                 TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
18:                 PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
19:                 IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
20:                 CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
21:                 *******************************************************************/
22:                
23:                #include <system.h>
24:                #include <system_config.h>
25:                
26:                #include <usb/usb.h>
27:                #include <usb/usb_device_hid.h>
28:                #include <usb/usb_device_msd.h>
29:                
30:                #include <driver/fileio/internal_flash.h>
31:                
32:                #include "ethernet/socket.h"
33:                #include "ataoe.h"
34:                
35:                static FILEIO_MEDIA_INFORMATION mediaInformation;
36:                
37:                #define PORT_TO_USE 3000
38:                
39:                static uint8_t client_mac[6],server_mac[6];
40:                static uint16_t server_major=0xFFFFu;
41:                static uint8_t server_minor=0xFF;
42:                
43:                static AtaOE ataoe;
44:                
45:                static uint16_t config_timeout,read_timeout;
46:                static bool config_active,read_active;
47:                extern void toggle(uint8_t state);
48:                
49:                #define CONFIG_TIMEOUT 2000
50:                #define READ_TIMEOUT 2000
51:                
52:                bool poll_net(uint32_t lba,uint8_t *sector_buffer)
53:                {
00203C  FA000A     LNK #0xA
00203E  BE9F88     MOV.D W8, [W15++]
002040  781F8A     MOV W10, [W15++]
002042  BE0400     MOV.D W0, W8
002044  780502     MOV W2, W10
54:                    extern uint16_t ticker;
55:                    uint32_t tip = 0xFFFFFFFF;
002046  EB8200     SETM W4
002048  EB8280     SETM W5
00204A  9FBF84     MOV W4, [W15-16]
00204C  9FBF95     MOV W5, [W15-14]
56:                    uint16_t rlen =0;
57:                    uint16_t mac_destport;
58:                    uint16_t len =0;
59:                    uint8_t mac_destip[4];
60:                
61:                    switch(getSn_SR(AOE_SOCKET))
00204E  203080     MOV #0x308, W0
002050  200001     MOV #0x0, W1
002052  07FE8C     RCALL WIZCHIP_READ
002054  504FE0     SUB.B W0, #0x0, [W15]
002056  320004     BRA Z, 0x2060
002058  B3C424     MOV #0x42, W4
00205A  504F84     SUB.B W0, W4, [W15]
00205C  3A0012     BRA NZ, 0x2082
00205E  37008A     BRA 0x2174
62:                    {
63:                        case SOCK_CLOSED:
64:                            close(AOE_SOCKET);                                      // close the SOCKET
002060  EB4000     CLR.B W0
002062  07FC63     RCALL close
65:                            socket(AOE_SOCKET,Sn_MR_MACRAW,PORT_TO_USE,0);          // open the SOCKET with MACRAW mode
002064  EB4180     CLR.B W3
002066  20BB82     MOV #0xBB8, W2
002068  B3C041     MOV #0x4, W1
00206A  784003     MOV.B W3, W0
00206C  07FC8C     RCALL socket
66:                            getSHAR(client_mac);
00206E  200063     MOV #0x6, W3
002070  20ACE2     MOV #0xACE, W2
002072  209000     MOV #0x900, W0
002074  200001     MOV #0x0, W1
002076  07FEA9     RCALL WIZCHIP_READ_BUF
67:                            config_active=0;
002078  EB4200     CLR.B W4
00207A  784004     MOV.B W4, W0
00207C  B7EAD4     MOV.B WREG, config_active
00207E  B7EAD5     MOV.B WREG, read_active
68:                            read_active=0;
69:                            break;
002080  3700C3     BRA 0x2208
70:                
71:                        default:
72:                
73:                            ataoe.header.msg_type = AOE_TYPE;
002082  288A24     MOV #0x88A2, W4
002084  885714     MOV W4, 0xAE2
74:                            ataoe.header.flags = 0x0;
002086  B3C000     MOV #0x0, W0
002088  B7EAE4     MOV.B WREG, 0xAE4
00208A  B7EAE5     MOV.B WREG, 0xAE5
75:                            ataoe.header.error = 0;
76:                            memcpy(ataoe.header.src_mac, client_mac, 6);
00208C  20ADC4     MOV #0xADC, W4
00208E  20ACE5     MOV #0xACE, W5
002090  090005     REPEAT #0x5
002092  785A35     MOV.B [W5++], [W4++]
77:                
78:                            // look for the server if lba = -1 or not detected
79:                            if(lba==0xFFFFFFFFLu || (server_major==0xFFFFu && server_minor==0xFF))
002094  440FE1     ADD W8, #0x1, [W15]
002096  4C8FE0     ADDC W9, #0x0, [W15]
002098  320007     BRA Z, 0x20A8
00209A  805984     MOV server_major, W4
00209C  420FE1     ADD W4, #0x1, [W15]
00209E  3A002F     BRA NZ, 0x20FE
0020A0  20B325     MOV #0xB32, W5
0020A2  784295     MOV.B [W5], W5
0020A4  42CFE1     ADD.B W5, #0x1, [W15]
0020A6  3A002B     BRA NZ, 0x20FE
80:                            {
81:                                if(!config_active)
0020A8  20AD44     MOV #0xAD4, W4
0020AA  784214     MOV.B [W4], W4
0020AC  524FE0     SUB.B W4, #0x0, [W15]
0020AE  3A001D     BRA NZ, 0x20EA
82:                                {
83:                
84:                                config_timeout=ticker;
0020B0  F80B44     PUSH ticker
0020B2  F90AFA     POP config_timeout
85:                                config_active=1;
0020B4  B3C015     MOV #0x1, W5
0020B6  784005     MOV.B W5, W0
0020B8  B7EAD4     MOV.B WREG, config_active
86:                
87:                                ataoe.header.major = 0xFFFFu;
0020BA  EB8200     SETM W4
0020BC  885734     MOV W4, 0xAE6
88:                                ataoe.header.minor = 0xFF;
0020BE  784004     MOV.B W4, W0
0020C0  B7EAE8     MOV.B WREG, 0xAE8
89:                                ataoe.header.cmd = AOE_CMD_CONFIG;
0020C2  784005     MOV.B W5, W0
0020C4  B7EAE9     MOV.B WREG, 0xAE9
90:                
91:                                memset(ataoe.header.dst_mac, 0xFF, 6);
0020C6  EFAAD6     SETM ataoe
0020C8  EFAAD8     SETM 0xAD8
0020CA  8856D4     MOV W4, 0xADA
92:                
93:                                ataoe.body.cfg.aoe_ccmd = ATAOE_CCMD_READ;
0020CC  EB4500     CLR.B W10
0020CE  78400A     MOV.B W10, W0
0020D0  B7EAF3     MOV.B WREG, 0xAF3
94:                                ataoe.body.cfg.buffer_count = 0;
0020D2  EB0200     CLR W4
0020D4  885774     MOV W4, 0xAEE
95:                                ataoe.body.cfg.firmware_version= 0;
0020D6  885784     MOV W4, 0xAF0
96:                                ataoe.body.cfg.sectors=0;
0020D8  B7EAF2     MOV.B WREG, 0xAF2
97:                                ataoe.body.cfg.length=0;
0020DA  8857A4     MOV W4, 0xAF4
98:                
99:                                sendto(AOE_SOCKET,(uint8_t*)&ataoe,sizeof(ataoe.header)+sizeof(ataoe.body.cfg),(uint8_t *)&tip,PORT_TO_USE);
0020DC  20BB84     MOV #0xBB8, W4
0020DE  5781F0     SUB W15, #0x10, W3
0020E0  200202     MOV #0x20, W2
0020E2  20AD61     MOV #0xAD6, W1
0020E4  07FCC1     RCALL sendto
100:                       
101:               
102:                               }
103:                               else
104:                               {
105:                                   if((ticker - config_timeout) >= CONFIG_TIMEOUT)
0020EA  8057D6     MOV config_timeout, W6
0020EC  805A24     MOV ticker, W4
0020EE  520306     SUB W4, W6, W6
0020F2  207CF5     MOV #0x7CF, W5
0020F4  530F85     SUB W6, W5, [W15]
0020F6  360088     BRA LEU, 0x2208
106:                                       config_active=0;
0020F8  784004     MOV.B W4, W0
0020FA  B7EAD4     MOV.B WREG, config_active
0020FC  370085     BRA 0x2208
107:                               }
108:               
109:                           }
110:                           else // ATAOE server is found
111:                           {
112:                               if(!read_active)
0020FE  20AD55     MOV #0xAD5, W5
002100  784295     MOV.B [W5], W5
002102  52CFE0     SUB.B W5, #0x0, [W15]
002104  3A002D     BRA NZ, 0x2160
113:                               {
114:                                   
115:                                   read_timeout=ticker;
002106  F80B44     PUSH ticker
002108  F90AFC     POP read_timeout
116:                                   read_active=1;
00210A  B3C015     MOV #0x1, W5
00210C  784005     MOV.B W5, W0
00210E  B7EAD5     MOV.B WREG, read_active
117:               
118:                               ataoe.header.major = server_major;
002110  885734     MOV W4, 0xAE6
119:                               ataoe.header.minor = server_minor;
002112  BFCB32     MOV.B server_minor, WREG
002114  B7EAE8     MOV.B WREG, 0xAE8
120:                               ataoe.header.cmd = AOE_CMD_ATA;
002116  EB4500     CLR.B W10
002118  78400A     MOV.B W10, W0
00211A  B7EAE9     MOV.B WREG, 0xAE9
121:                               memcpy(ataoe.header.dst_mac, server_mac, 6);
00211C  20AD64     MOV #0xAD6, W4
00211E  20AFE6     MOV #0xAFE, W6
002120  090005     REPEAT #0x5
002122  785A36     MOV.B [W6++], [W4++]
122:               
123:                               ataoe.body.iss.aflag = 0;
002124  B7EAEE     MOV.B WREG, 0xAEE
124:                               ataoe.body.iss.sectors = 1;
002126  784005     MOV.B W5, W0
002128  B7EAF0     MOV.B WREG, 0xAF0
125:                               ataoe.body.iss.lba0 = (uint8_t)lba;
00212A  784008     MOV.B W8, W0
00212C  B7EAF2     MOV.B WREG, 0xAF2
126:                               ataoe.body.iss.lba1 = (uint8_t)(lba >> 8);
00212E  DD4B48     SL W9, #8, W6
002130  DE4248     LSR W8, #8, W4
002132  730204     IOR W6, W4, W4
002134  DE4AC8     LSR W9, #8, W5
002136  784004     MOV.B W4, W0
002138  B7EAF3     MOV.B WREG, 0xAF3
127:                               ataoe.body.iss.lba2 = (uint8_t)(lba >> 16);
00213A  DE4A40     LSR W9, #0, W4
00213C  200005     MOV #0x0, W5
00213E  784004     MOV.B W4, W0
002140  B7EAF4     MOV.B WREG, 0xAF4
128:                               ataoe.body.iss.lba3 = (uint8_t)(lba >> 24);
002142  DE4C48     LSR W9, #8, W8
002144  784008     MOV.B W8, W0
002146  B7EAF5     MOV.B WREG, 0xAF5
129:                               ataoe.body.iss.err  = 0;
002148  78400A     MOV.B W10, W0
00214A  B7EAEF     MOV.B WREG, 0xAEF
130:                               ataoe.body.iss.acmd = 0x20;
00214C  B3C200     MOV #0x20, W0
00214E  B7EAF1     MOV.B WREG, 0xAF1
131:               
132:                               sendto(AOE_SOCKET,(uint8_t*)&ataoe,sizeof(ataoe.header)+sizeof(ataoe.body.iss),(uint8_t *)&tip,PORT_TO_USE);
002150  20BB84     MOV #0xBB8, W4
002152  5781F0     SUB W15, #0x10, W3
002154  200242     MOV #0x24, W2
002156  20AD61     MOV #0xAD6, W1
002158  78400A     MOV.B W10, W0
00215A  07FC86     RCALL sendto
133:                               }
134:                               else
135:                               {
136:                                   if((ticker-read_timeout) >= READ_TIMEOUT)
002160  8057E6     MOV read_timeout, W6
002162  805A24     MOV ticker, W4
002164  520306     SUB W4, W6, W6
002168  207CF5     MOV #0x7CF, W5
00216A  530F85     SUB W6, W5, [W15]
00216C  36004D     BRA LEU, 0x2208
137:                                       read_active=0;
00216E  784004     MOV.B W4, W0
002170  B7EAD5     MOV.B WREG, read_active
002172  37004A     BRA 0x2208
138:                               }
139:                           }
140:               
141:                           break;
142:               
143:                       // Response
144:               	case SOCK_MACRAW:
145:               
146:                           toggle(1);
002174  B3C010     MOV #0x1, W0
002176  07F0A5     RCALL toggle
147:                           rlen = getSn_RX_RSR(AOE_SOCKET);
002178  EB4000     CLR.B W0
00217A  07FE8E     RCALL getSn_RX_RSR
148:                           if ( rlen >= sizeof(ataoe.header)) // remaining length
00217E  500FF7     SUB W0, #0x17, [W15]
002180  360043     BRA LEU, 0x2208
149:                           {
150:                               len = recvfrom(AOE_SOCKET,(uint8_t *)&ataoe,sizeof(ataoe.header),mac_destip,&mac_destport);
002182  57826C     SUB W15, #0xC, W4
002184  5781EA     SUB W15, #0xA, W3
002186  200182     MOV #0x18, W2
002188  20AD61     MOV #0xAD6, W1
00218A  EB4000     CLR.B W0
00218C  07FD01     RCALL recvfrom
151:               
152:               		if((len == sizeof(ataoe.header)) && (ataoe.header.msg_type == AOE_TYPE) && (ataoe.header.flags & 0x10))
002190  500FF8     SUB W0, #0x18, [W15]
002192  3A003A     BRA NZ, 0x2208
002194  288A25     MOV #0x88A2, W5
002196  805716     MOV 0xAE2, W6
002198  530F85     SUB W6, W5, [W15]
00219A  3A0036     BRA NZ, 0x2208
00219C  20AE45     MOV #0xAE4, W5
00219E  784295     MOV.B [W5], W5
0021A0  6282F0     AND W5, #0x10, W5
0021A2  320032     BRA Z, 0x2208
153:               		{
154:                                   if(ataoe.header.cmd == AOE_CMD_CONFIG)
0021A4  20AE95     MOV #0xAE9, W5
0021A6  784295     MOV.B [W5], W5
0021A8  52CFE1     SUB.B W5, #0x1, [W15]
0021AA  3A0010     BRA NZ, 0x21CC
155:                                   {
156:                                       recvfrom(AOE_SOCKET, (uint8_t *)&ataoe.body.cfg, sizeof(ataoe.body.cfg), mac_destip, &mac_destport);
0021AC  57826C     SUB W15, #0xC, W4
0021AE  5781EA     SUB W15, #0xA, W3
0021B0  200082     MOV #0x8, W2
0021B2  20AEE1     MOV #0xAEE, W1
0021B4  EB4000     CLR.B W0
0021B6  07FCEC     RCALL recvfrom
157:               
158:                                       server_major = ataoe.header.major;
0021B8  F80AE6     PUSH 0xAE6
0021BA  F90B30     POP server_major
159:                                       server_minor = ataoe.header.minor;
0021BC  BFCAE8     MOV.B 0xAE8, WREG
0021BE  B7EB32     MOV.B WREG, server_minor
160:                                       memcpy(server_mac, ataoe.header.src_mac,6);
0021C0  20AFE4     MOV #0xAFE, W4
0021C2  20ADC5     MOV #0xADC, W5
0021C4  090005     REPEAT #0x5
0021C6  785A35     MOV.B [W5++], [W4++]
161:                                   }
162:                                   else if(ataoe.header.cmd == AOE_CMD_ATA)
0021CE  52CF84     SUB.B W5, W4, [W15]
0021D0  3A001B     BRA NZ, 0x2208
163:                                   {
164:                                       if((ataoe.header.major == server_major) && (ataoe.header.minor == server_minor))
0021D2  805985     MOV server_major, W5
0021D4  805736     MOV 0xAE6, W6
0021D6  530F85     SUB W6, W5, [W15]
0021D8  3A0017     BRA NZ, 0x2208
0021DA  20B325     MOV #0xB32, W5
0021DC  784295     MOV.B [W5], W5
0021DE  20AE86     MOV #0xAE8, W6
0021E0  784316     MOV.B [W6], W6
0021E2  534F85     SUB.B W6, W5, [W15]
0021E4  3A0011     BRA NZ, 0x2208
165:                                       {
166:                                           recvfrom(AOE_SOCKET, (uint8_t *)&ataoe.body.iss, sizeof(ataoe.body.iss), mac_destip, &mac_destport);
0021E6  57826C     SUB W15, #0xC, W4
0021E8  5781EA     SUB W15, #0xA, W3
0021EA  2000C2     MOV #0xC, W2
0021EC  20AEE1     MOV #0xAEE, W1
0021EE  EB4000     CLR.B W0
0021F0  07FCCF     RCALL recvfrom
167:               
168:                                           if(sector_buffer!=NULL)
0021F4  550FE0     SUB W10, #0x0, [W15]
0021F6  320008     BRA Z, 0x2208
169:                                           {
170:                                               recvfrom(AOE_SOCKET, sector_buffer, SECTOR_SIZE, mac_destip, &mac_destport);
0021F8  57826C     SUB W15, #0xC, W4
0021FA  5781EA     SUB W15, #0xA, W3
0021FC  202002     MOV #0x200, W2
0021FE  78008A     MOV W10, W1
002200  EB4000     CLR.B W0
002202  07FCC6     RCALL recvfrom
171:                                               read_active=0;
002204  EF6AD5     CLR.B read_active
172:                                               return 1;
002206  B3C014     MOV #0x1, W4
173:                                           }
174:                                       }
175:                                   }
176:                               }
177:                           }
178:                           break;
179:                   }
180:               
181:                 return 0;
0020E6  78420A     MOV.B W10, W4
0020E8  37008F     BRA 0x2208
0020F0  EB4200     CLR.B W4
00215C  78420A     MOV.B W10, W4
00215E  370054     BRA 0x2208
002166  EB4200     CLR.B W4
00217C  EB4200     CLR.B W4
00218E  EB4200     CLR.B W4
0021C8  EB4200     CLR.B W4
0021CA  37001E     BRA 0x2208
0021CC  EB4200     CLR.B W4
0021F2  EB4200     CLR.B W4
182:               }
002208  784004     MOV.B W4, W0
00220A  78054F     MOV [--W15], W10
00220C  BE044F     MOV.D [--W15], W8
00220E  FA8000     ULNK
002210  060000     RETURN
183:               
184:               static uint8_t FILEIO_NET_MediaDetect(void* config)
001FFA  BFCB32     MOV.B server_minor, WREG
001FFC  EAC000     COM.B W0, W0
001FFE  FB8000     ZE W0, W0
002000  EA0000     NEG W0, W0
002002  DE004F     LSR W0, #15, W0
185:               {
186:                   if(server_major != 0xFFFFu && server_minor != 0xFF)
001FF4  805984     MOV server_major, W4
001FF6  420FE1     ADD W4, #0x1, [W15]
001FF8  320005     BRA Z, 0x2004
187:                        return true;
188:                   else
189:                        return false;
001FF2  EB4000     CLR.B W0
190:               
191:               }//end MediaDetect
002004  060000     RETURN
192:               
193:               static uint16_t FILEIO_NET_SectorSizeRead(void* config)
194:               {
195:                   return FILEIO_CONFIG_MEDIA_SECTOR_SIZE;
196:               }
002006  202000     MOV #0x200, W0
002008  060000     RETURN
197:               
198:               static uint32_t FILEIO_NET_CapacityRead(void* config)
199:               {
200:                   //The SCSI READ_CAPACITY command wants to know the last valid LBA address
201:                   //that the host is allowed to read or write to.  Since LBA addresses start
202:                   //at and include 0, a return value of 0 from this function would mean the
203:                   //host is allowed to read and write the LBA == 0x00000000, which would be
204:                   //1 sector worth of capacity.
205:                   //Therefore, the last valid LBA that the host may access is
206:                   //DRV_FILEIO_INTERNAL_FLASH_TOTAL_DISK_SIZE - 1.
207:               
208:                   return 0xFFFFFFFELu;
209:               }
00200A  2FFFE0     MOV #0xFFFE, W0
00200C  2FFFF1     MOV #0xFFFF, W1
00200E  060000     RETURN
210:               
211:               static FILEIO_MEDIA_INFORMATION * FILEIO_NET_MediaInitialize(void* config)
212:               {
213:                   mediaInformation.validityFlags.bits.sectorSize = true;
002010  20AC60     MOV #0xAC6, W0
002012  900210     MOV [W0+2], W4
002014  A00004     BSET W4, #0
002016  980014     MOV W4, [W0+2]
214:                   mediaInformation.sectorSize = FILEIO_CONFIG_MEDIA_SECTOR_SIZE;
002018  202004     MOV #0x200, W4
00201A  980024     MOV W4, [W0+4]
215:               
216:                   mediaInformation.errorCode = MEDIA_NO_ERROR;
00201C  EB0800     CLR [W0]
217:                   return &mediaInformation;
218:               }//end MediaInitialize
00201E  060000     RETURN
219:               
220:               /******************************************************************************
221:                * Function:        uint8_t SectorRead(uint32_t sector_addr, uint8_t *buffer)
222:                *
223:                * PreCondition:    None
224:                *
225:                * Input:           sector_addr - Sector address, each sector contains 512-byte
226:                *                  buffer      - Buffer where data will be stored, see
227:                *                                'ram_acs.h' for 'block' definition.
228:                *                                'Block' is dependent on whether internal or
229:                *                                external memory is used
230:                *
231:                * Output:          Returns true if read successful, false otherwise
232:                *
233:                * Side Effects:    None
234:                *
235:                * Overview:        SectorRead reads 512 bytes of data from the card starting
236:                *                  at the sector address specified by sector_addr and stores
237:                *                  them in the location pointed to by 'buffer'.
238:                *
239:                * Note:            The device expects the address field in the command packet
240:                *                  to be byte address. Therefore the sector_addr must first
241:                *                  be converted to byte address. This is accomplished by
242:                *                  shifting the address left 9 times.
243:                *****************************************************************************/
244:               static uint8_t FILEIO_NET_SectorRead(void* config, uint32_t sector_addr, uint8_t* buffer)
002028  BFCB32     MOV.B server_minor, WREG
00202A  EAC000     COM.B W0, W0
00202C  FB8000     ZE W0, W0
00202E  EA0000     NEG W0, W0
002030  DE004F     LSR W0, #15, W0
245:               {
246:                   if(server_major == 0xFFFFu && server_minor == 0xFF)
002022  805984     MOV server_major, W4
002024  420FE1     ADD W4, #0x1, [W15]
002026  3A0005     BRA NZ, 0x2032
247:                           return false;
248:               
249:                   // block until its been read
250:                   //while(!poll_net(sector_addr, buffer))
251:                   //    ClrWdt();
252:               
253:                    return true;
002020  B3C010     MOV #0x1, W0
254:                }
002032  060000     RETURN
255:               
256:               static uint8_t FILEIO_NET_SectorWrite(void* config, uint32_t sector_addr, uint8_t* buffer, uint8_t allowWriteToZero)
257:               {
258:                   return false;
259:               }
002034  EB4000     CLR.B W0
002036  060000     RETURN
260:               
261:               static uint8_t FILEIO_NET_WriteProtectStateGet(void* config)
262:               {
263:                   return true;
264:               }
002038  B3C010     MOV #0x1, W0
00203A  060000     RETURN
265:               
266:               //The LUN variable definition is critical to the MSD function driver.  This
267:               //  array is a structure of function pointers that are the functions that
268:               //  will take care of each of the physical media.  For each additional LUN
269:               //  that is added to the system, an entry into this array needs to be added
270:               //  so that the stack can know where to find the physical layer functions.
271:               //  In this example the media initialization function is named
272:               //  "MediaInitialize", the read capacity function is named "ReadCapacity",
273:               //  etc.
274:               LUN_FUNCTIONS LUN[MAX_LUN + 1] =
275:               {
276:                   {
277:                       (FILEIO_MEDIA_INFORMATION* (*)(void *))&FILEIO_NET_MediaInitialize,
278:                       (uint32_t (*)(void *))&FILEIO_NET_CapacityRead,
279:                       (uint16_t (*)(void *))&FILEIO_NET_SectorSizeRead,
280:                       (bool  (*)(void *))&FILEIO_NET_MediaDetect,
281:                       (uint8_t  (*)(void *, uint32_t, uint8_t*))&FILEIO_NET_SectorRead,
282:                       (uint8_t  (*)(void *))&FILEIO_NET_WriteProtectStateGet,
283:                       (uint8_t  (*)(void *, uint32_t, uint8_t *, uint8_t))&FILEIO_NET_SectorWrite,
284:                       (void *)NULL
285:                   }
286:               };
287:               
288:               /* Standard Response to INQUIRY command stored in ROM 	*/
289:               const InquiryResponse inq_resp = {
290:               	0x00,		// peripheral device is connected, direct access block device
291:               	0x80,           // removable
292:               	0x04,	 	// version = 00=> does not conform to any standard, 4=> SPC-2
293:               	0x02,		// response is in format specified by SPC-2
294:               	0x20,		// n-4 = 36-4=32= 0x20
295:               	0x00,		// sccs etc.
296:               	0x00,		// bque=1 and cmdque=0,indicates simple queueing 00 is obsolete,
297:               			// but as in case of other device, we are just using 00
298:               	0x00,		// 00 obsolete, 0x80 for basic task queueing
299:               	{'M','i','c','r','o','c','h','p'
300:                   },
301:               	// this is the T10 assigned Vendor ID
302:               	{'M','a','s','s',' ','S','t','o','r','a','g','e',' ',' ',' ',' '
303:                   },
304:               	{'0','0','0','1'
305:                   }
306:               };
307:               
308:               
309:               /*********************************************************************
310:               * Function: void APP_DeviceMSDInitialize(void);
311:               *
312:               * Overview: Initializes the Custom HID demo code
313:               *
314:               * PreCondition: None
315:               *
316:               * Input: None
317:               *
318:               * Output: None
319:               *
320:               ********************************************************************/
321:               void APP_DeviceMSDInitialize()
322:               {
323:                   #if (MSD_DATA_IN_EP == MSD_DATA_OUT_EP)
324:                       USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
002212  B3C1D1     MOV #0x1D, W1
002214  B3C010     MOV #0x1, W0
002216  07F3EA     RCALL USBEnableEndpoint
325:                   #else
326:                       USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
327:                       USBEnableEndpoint(MSD_DATA_OUT_EP,USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
328:                   #endif
329:               
330:                   USBMSDInit();
002218  07F757     RCALL USBMSDInit
331:               }
00221A  060000     RETURN
332:               
333:               /*********************************************************************
334:               * Function: void APP_DeviceMSDTasks(void);
335:               *
336:               * Overview: Keeps the Custom HID demo running.
337:               *
338:               * PreCondition: The demo should have been initialized and started via
339:               *   the APP_DeviceMSDInitialize() and APP_DeviceMSDStart() demos
340:               *   respectively.
341:               *
342:               * Input: None
343:               *
344:               * Output: None
345:               *
346:               ********************************************************************/
347:               void APP_DeviceMSDTasks()
348:               {
349:                   MSDTasks();
00221C  07FAD1     RCALL MSDTasks
350:               }
00221E  060000     RETURN
---  F:/microchip/mla/v2013_12_20/apps/usb/device/msd_internal_flash/firmware/src/Ethernet/wizchip_conf.c
1:                 //****************************************************************************/ 
2:                 //!
3:                 //! \file wizchip_conf.c
4:                 //! \brief WIZCHIP Config Header File.
5:                 //! \version 1.0.0
6:                 //! \date 2013/10/21
7:                 //! \par  Revision history
8:                 //!       <2013/10/21> 1st Release
9:                 //! \author MidnightCow
10:                //! \copyright
11:                //!
12:                //! Copyright (c)  2013, WIZnet Co., LTD.
13:                //! All rights reserved.
14:                //! 
15:                //! Redistribution and use in source and binary forms, with or without 
16:                //! modification, are permitted provided that the following conditions 
17:                //! are met: 
18:                //! 
19:                //!     * Redistributions of source code must retain the above copyright 
20:                //! notice, this list of conditions and the following disclaimer. 
21:                //!     * Redistributions in binary form must reproduce the above copyright
22:                //! notice, this list of conditions and the following disclaimer in the
23:                //! documentation and/or other materials provided with the distribution. 
24:                //!     * Neither the name of the <ORGANIZATION> nor the names of its 
25:                //! contributors may be used to endorse or promote products derived 
26:                //! from this software without specific prior written permission. 
27:                //! 
28:                //! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
29:                //! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
30:                //! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
31:                //! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
32:                //! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
33:                //! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
34:                //! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
35:                //! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
36:                //! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
37:                //! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
38:                //! THE POSSIBILITY OF SUCH DAMAGE.
39:                //
40:                //*****************************************************************************/
41:                #include "wizchip_conf.h"
42:                
43:                /*
44:                int8_t ctlwizchip(ctlwizchip_type cwtype, void* arg)
45:                {
46:                   uint8_t tmp = 0;
47:                   uint8_t* ptmp[2] = {0,0};
48:                   switch(cwtype)
49:                   {
50:                      case CW_RESET_WIZCHIP:
51:                         wizchip_sw_reset();
52:                         break;
53:                      case CW_INIT_WIZCHIP:
54:                         if(arg != 0) 
55:                         {
56:                            ptmp[0] = (uint8_t*)arg;
57:                            ptmp[1] = ptmp[0] + _WIZCHIP_SOCK_NUM_;
58:                         }
59:                         return wizchip_init(ptmp[0], ptmp[1]);;
60:                      case CW_CLR_INTERRUPT:
61:                         wizchip_clrinterrupt(*((intr_kind*)arg));
62:                         break;
63:                      case CW_GET_INTERRUPT:
64:                        *((uint16_t*)arg) = wizchip_getinterrupt();
65:                         break;
66:                      case CW_SET_INTRMASK:
67:                         wizchip_setinterruptmask(*((uint16_t*)arg));
68:                         break;         
69:                      case CW_GET_INTRMASK:
70:                         *((uint16_t*)arg) = wizchip_getinterruptmask();
71:                         break;
72:                   #if _WIZCHIP_ > 5100
73:                      case CW_SET_INTRTIME:
74:                         setINTLEVEL(*(uint16_t*)arg);
75:                         break;
76:                      case CW_GET_INTRTIME:
77:                         *(uint16_t*)arg = getINTLEVEL();
78:                         break;
79:                   #endif
80:                      case CW_GET_ID:
81:                         ((uint8_t*)arg)[0] = (uint8_t)_WIZCHIP_;
82:                         ((uint8_t*)arg)[1] = (uint8_t)(_WIZCHIP_ >> 8);
83:                         ((uint8_t*)arg)[2] = 0;
84:                         ((uint8_t*)arg)[3] = 0;
85:                         ((uint8_t*)arg)[4] = 0;
86:                         ((uint8_t*)arg)[5] = 0;
87:                         break;
88:                   #if _WIZCHIP_ ==  5500
89:                      case CW_RESET_PHY:
90:                         wizphy_reset();
91:                         break;
92:                      case CW_SET_PHYCONF:
93:                         wizphy_setphyconf((wiz_PhyConf*)arg);
94:                         break;
95:                      case CW_GET_PHYCONF:
96:                         wizphy_getphyconf((wiz_PhyConf*)arg);
97:                         break;
98:                      case CW_GET_PHYSTATUS:
99:                         break;
100:                     case CW_SET_PHYPOWMODE:
101:                        return wizphy_setphypmode(*(uint8_t*)arg);
102:                  #endif
103:                     case CW_GET_PHYPOWMODE:
104:                        tmp = wizphy_getphypmode();
105:                        if((int8_t)tmp == -1) return -1;
106:                        *(uint8_t*)arg = tmp;
107:                        break;
108:                     case CW_GET_PHYLINK:
109:                        tmp = wizphy_getphylink();
110:                        if((int8_t)tmp == -1) return -1;
111:                        *(uint8_t*)arg = tmp;
112:                        break;
113:                     default:
114:                        return -1;
115:                  }
116:                  return 0;
117:               }
118:               
119:               int8_t ctlnetwork(ctlnetwork_type cntype, void* arg)
120:               {
121:                  
122:                  switch(cntype)
123:                  {
124:                     case CN_SET_NETINFO:
125:                        wizchip_setnetinfo((wiz_NetInfo*)arg);
126:                        break;
127:                     case CN_GET_NETINFO:
128:                        wizchip_getnetinfo((wiz_NetInfo*)arg);
129:                        break;
130:                     case CN_SET_NETMODE:
131:                        return wizchip_setnetmode(*(netmode_type*)arg);
132:                     case CN_GET_NETMODE:
133:                        *(netmode_type*)arg = wizchip_getnetmode();
134:                        break;
135:                     case CN_SET_TIMEOUT:
136:                        wizchip_settimeout((wiz_NetTimeout*)arg);
137:                        break;
138:                     case CN_GET_TIMEOUT:
139:                        wizchip_gettimeout((wiz_NetTimeout*)arg);
140:                        break;
141:                     default:
142:                        return -1;
143:                  }
144:                  return 0;
145:               }
146:               */
147:               
148:               void wizchip_sw_reset(void)
149:               {
002220  FA0012     LNK #0x12
150:                  uint8_t gw[4], sn[4], sip[4];
151:                  uint8_t mac[6];
152:                  getSHAR(mac);
002222  200063     MOV #0x6, W3
002224  578166     SUB W15, #0x6, W2
002226  209000     MOV #0x900, W0
002228  200001     MOV #0x0, W1
00222A  07FDCF     RCALL WIZCHIP_READ_BUF
153:                  getGAR(gw);  getSUBR(sn);  getSIPR(sip);
00222C  200043     MOV #0x4, W3
00222E  578172     SUB W15, #0x12, W2
002230  201000     MOV #0x100, W0
002232  200001     MOV #0x0, W1
002234  07FDCA     RCALL WIZCHIP_READ_BUF
002236  200043     MOV #0x4, W3
002238  57816E     SUB W15, #0xE, W2
00223A  205000     MOV #0x500, W0
00223C  200001     MOV #0x0, W1
00223E  07FDC5     RCALL WIZCHIP_READ_BUF
002240  200043     MOV #0x4, W3
002242  57816A     SUB W15, #0xA, W2
002244  20F000     MOV #0xF00, W0
002246  200001     MOV #0x0, W1
002248  07FDC0     RCALL WIZCHIP_READ_BUF
154:                  setMR(MR_RST);
00224A  B3C802     MOV #0x80, W2
00224C  B80060     MUL.UU W0, #0, W0
00224E  07FDA4     RCALL WIZCHIP_WRITE
155:                  getMR(); // for delay
002250  B80060     MUL.UU W0, #0, W0
002252  07FD8C     RCALL WIZCHIP_READ
156:                  setSHAR(mac);
002254  200063     MOV #0x6, W3
002256  578166     SUB W15, #0x6, W2
002258  209000     MOV #0x900, W0
00225A  200001     MOV #0x0, W1
00225C  07FDD7     RCALL WIZCHIP_WRITE_BUF
157:                  setGAR(gw);
00225E  200043     MOV #0x4, W3
002260  578172     SUB W15, #0x12, W2
002262  201000     MOV #0x100, W0
002264  200001     MOV #0x0, W1
002266  07FDD2     RCALL WIZCHIP_WRITE_BUF
158:                  setSUBR(sn);
002268  200043     MOV #0x4, W3
00226A  57816E     SUB W15, #0xE, W2
00226C  205000     MOV #0x500, W0
00226E  200001     MOV #0x0, W1
002270  07FDCD     RCALL WIZCHIP_WRITE_BUF
159:                  setSIPR(sip);
002272  200043     MOV #0x4, W3
002274  57816A     SUB W15, #0xA, W2
002276  20F000     MOV #0xF00, W0
002278  200001     MOV #0x0, W1
00227A  07FDC8     RCALL WIZCHIP_WRITE_BUF
160:               }
00227C  FA8000     ULNK
00227E  060000     RETURN
161:               
162:               int8_t wizchip_init(uint8_t* txsize, uint8_t* rxsize)
163:               {
002280  BE9F88     MOV.D W8, [W15++]
002282  BE9F8A     MOV.D W10, [W15++]
002284  781F8C     MOV W12, [W15++]
002286  BE0500     MOV.D W0, W10
164:                  int8_t i;
165:                  int8_t tmp = 0;
166:                  uint16_t cnt;
167:                  extern volatile uint16_t ticker;
168:                  
169:                  // Set up SPI hardware
170:                  WIZCHIP_CS_deselect();
002288  A802CC     BSET LATB, #0
171:                  WIZCHIP_RESET(0);
00228A  A982CC     BCLR LATB, #4
172:                  TRISBbits.TRISB0=0; // CS is output
00228C  A902C8     BCLR TRISB, #0
173:                  TRISBbits.TRISB2=0; // SDO is output
00228E  A942C8     BCLR TRISB, #2
174:                  TRISBbits.TRISB1=0; // SCLK is output
002290  A922C8     BCLR TRISB, #1
175:                  TRISBbits.TRISB8=1; // RDY is input
002292  A802C9     BSET 0x2C9, #0
176:                  TRISBbits.TRISB4=0; // RESET is output
002294  A982C8     BCLR TRISB, #4
177:                  
178:                  // wait > 500us
179:                  cnt=ticker;
002296  805A25     MOV ticker, W5
180:                  while((ticker - cnt) < 2) ClrWdt();
002298  805A26     MOV ticker, W6
00229A  530205     SUB W6, W5, W4
00229C  520FE1     SUB W4, #0x1, [W15]
00229E  3E0005     BRA GTU, 0x22AA
0022A0  FE6000     CLRWDT
0022A2  805A27     MOV ticker, W7
0022A4  538205     SUB W7, W5, W4
0022A6  520FE1     SUB W4, #0x1, [W15]
0022A8  36FFFB     BRA LEU, 0x22A0
181:               
182:                  WIZCHIP_RESET(1);
0022AA  A882CC     BSET LATB, #4
183:               
184:                   // Unlock registers
185:                   __builtin_write_OSCCONL(OSCCON & 0xBF);
0022AC  200BF6     MOV #0xBF, W6
0022AE  803A14     MOV OSCCON, W4
0022B0  630304     AND W6, W4, W6
0022B2  200464     MOV #0x46, W4
0022B4  200575     MOV #0x57, W5
0022B6  207427     MOV #0x742, W7
0022B8  784B84     MOV.B W4, [W7]
0022BA  784B85     MOV.B W5, [W7]
0022BC  784B86     MOV.B W6, [W7]
186:               
187:                   // SDI1=RP3
188:                   RPINR20bits.SDI1R3=0;
0022BE  A966A8     BCLR RPINR20, #3
189:                   // SDO1=RP2
190:                   RPOR1bits.RP2R=7;
0022C0  2FFE06     MOV #0xFFE0, W6
0022C2  803617     MOV RPOR1, W7
0022C4  630307     AND W6, W7, W6
0022C6  B30076     IOR #0x7, W6
0022C8  883616     MOV W6, RPOR1
191:                   // SCK1=RP1
192:                   RPOR0bits.RP1R=8;
0022CA  2E0FF6     MOV #0xE0FF, W6
0022CC  803607     MOV RPOR0, W7
0022CE  630307     AND W6, W7, W6
0022D0  A0B006     BSET W6, #11
0022D2  883606     MOV W6, RPOR0
193:               
194:                  // Lock registers
195:                   __builtin_write_OSCCONL(OSCCON | 0x40);
0022D4  803A16     MOV OSCCON, W6
0022D6  A06006     BSET W6, #6
0022D8  207427     MOV #0x742, W7
0022DA  784B84     MOV.B W4, [W7]
0022DC  784B85     MOV.B W5, [W7]
0022DE  784B86     MOV.B W6, [W7]
196:               
197:                  // Sample in middle, transmit on CLK 1->0 (CKE=0)
198:                  // Master mode, CLK idles high (CKP=1), PRESCALER=1:1
199:                  SPI1CON1=64+32+1+2+4+8+16;
0022E0  2007F4     MOV #0x7F, W4
0022E2  881214     MOV W4, SPI1CON1
200:                  // Framed SPI disabled, legacy mode (for now)
201:                  SPI1CON2=0;
0022E4  EF2244     CLR SPI1CON2
202:                  // Enable
203:                  SPI1STAT=32768;
0022E6  280004     MOV #0x8000, W4
0022E8  881204     MOV W4, SPI1STAT
204:               
205:                   // wait 50 ms
206:                  cnt=ticker;
0022EA  805A25     MOV ticker, W5
207:                  while((ticker - cnt) < 150) ClrWdt() ;
0022EC  805A24     MOV ticker, W4
0022EE  520305     SUB W4, W5, W6
0022F0  200954     MOV #0x95, W4
0022F2  530F84     SUB W6, W4, [W15]
0022F4  3E0006     BRA GTU, 0x2302
0022F6  780304     MOV W4, W6
0022F8  FE6000     CLRWDT
0022FA  805A27     MOV ticker, W7
0022FC  538205     SUB W7, W5, W4
0022FE  520F86     SUB W4, W6, [W15]
002300  36FFFB     BRA LEU, 0x22F8
208:               
209:                  while(!WIZCHIP_READY()) ;
002302  201005     MOV #0x100, W5
002304  801656     MOV PORTB, W6
002306  628206     AND W5, W6, W4
002308  520FE0     SUB W4, #0x0, [W15]
00230A  32FFFC     BRA Z, 0x2304
210:               
211:               //   wizchip_sw_reset();
212:                  if(txsize)
00230C  550FE0     SUB W10, #0x0, [W15]
00230E  320019     BRA Z, 0x2342
002310  B3C085     MOV #0x8, W5
002312  EB4300     CLR.B W6
002314  784206     MOV.B W6, W4
213:                  {
214:                     tmp = 0;
215:                     for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
00231C  E84204     INC.B W4, W4
00231E  E94285     DEC.B W5, W5
002320  3AFFFA     BRA NZ, 0x2316
216:                        tmp += txsize[i];
002316  FB0384     SE W4, W7
002318  7BC3EA     MOV.B [W10+W7], W7
00231A  434307     ADD.B W6, W7, W6
217:                     if(tmp > 16) return -1;
002322  EBC000     SETM.B W0
002324  534FF0     SUB.B W6, #0x10, [W15]
002326  3C002A     BRA GT, 0x237C
002328  B3C088     MOV #0x8, W8
00232A  EB4480     CLR.B W9
218:                     for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
00233C  E84489     INC.B W9, W9
00233E  E94408     DEC.B W8, W8
002340  3AFFF6     BRA NZ, 0x232E
219:                        setSn_TXBUF_SIZE(i, txsize[i]);
00232C  21F00C     MOV #0x1F00, W12
00232E  FB0209     SE W9, W4
002330  7A416A     MOV.B [W10+W4], W2
002332  DD2045     SL W4, #5, W0
002334  400068     ADD W0, #0x8, W0
002336  40000C     ADD W0, W12, W0
002338  DE80CF     ASR W0, #15, W1
00233A  07FD2E     RCALL WIZCHIP_WRITE
220:                  }
221:                  if(rxsize)
002344  558FE0     SUB W11, #0x0, [W15]
002346  32001A     BRA Z, 0x237C
002348  B3C085     MOV #0x8, W5
00234A  784300     MOV.B W0, W6
00234C  784206     MOV.B W6, W4
222:                  {
223:                     tmp = 0;
224:                     for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
002354  E84204     INC.B W4, W4
002356  E94285     DEC.B W5, W5
002358  3AFFFA     BRA NZ, 0x234E
225:                        tmp += rxsize[i];
00234E  FB0384     SE W4, W7
002350  7BC3EB     MOV.B [W11+W7], W7
002352  434307     ADD.B W6, W7, W6
226:                     if(tmp > 16) return -1;
00235A  EBC000     SETM.B W0
00235C  534FF0     SUB.B W6, #0x10, [W15]
00235E  3C000E     BRA GT, 0x237C
002360  B3C088     MOV #0x8, W8
002362  EB4480     CLR.B W9
227:                     for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
002374  E84489     INC.B W9, W9
002376  E94408     DEC.B W8, W8
002378  3AFFF6     BRA NZ, 0x2366
228:                        setSn_RXBUF_SIZE(i, rxsize[i]);
002364  21E00A     MOV #0x1E00, W10
002366  FB0209     SE W9, W4
002368  7A416B     MOV.B [W11+W4], W2
00236A  DD2045     SL W4, #5, W0
00236C  400068     ADD W0, #0x8, W0
00236E  40000A     ADD W0, W10, W0
002370  DE80CF     ASR W0, #15, W1
002372  07FD12     RCALL WIZCHIP_WRITE
229:                  }
230:               
231:                  return 0;
002342  EB4000     CLR.B W0
00237A  EB4000     CLR.B W0
232:               }
00237C  78064F     MOV [--W15], W12
00237E  BE054F     MOV.D [--W15], W10
002380  BE044F     MOV.D [--W15], W8
002382  060000     RETURN
233:               
234:               /*
235:               void wizchip_clrinterrupt(intr_kind intr)
236:               {
237:                  uint8_t ir  = (uint8_t)intr;
238:                  uint8_t sir = (uint8_t)((uint16_t)intr >> 8);
239:               #if _WIZCHIP_ < 5500
240:                  ir |= (1<<4); // IK_WOL
241:               #endif
242:               #if _WIZCHIP_ == 5200
243:                  ir |= (1 << 6);
244:               #endif
245:                  
246:               #if _WIZCHIP_ < 5200
247:                  sir &= 0x0F;
248:               #endif
249:               
250:               #if _WIZCHIP_ == 5100
251:                  ir |= sir;
252:                  setIR(ir);
253:               #else
254:                  setIR(ir);
255:                  setSIR(sir);
256:               #endif   
257:               }
258:               
259:               intr_kind wizchip_getinterrupt(void)
260:               {
261:                  uint8_t ir  = 0;
262:                  uint8_t sir = 0;
263:                  uint16_t ret = 0;
264:               #if _WIZCHIP_ == 5100
265:                  ir = getIR();
266:                  sir = ir 0x0F;
267:               #else
268:                  ir  = getIR();
269:                  sir = getSIR();
270:               #endif         
271:               
272:               #if _WIZCHIP_ < 5500
273:                  ir &= ~(1<<4); // IK_WOL
274:               #endif
275:               #if _WIZCHIP_ == 5200
276:                  ir &= ~(1 << 6);
277:               #endif
278:                 ret = sir;
279:                 ret = (ret << 8) + ir;
280:                 return (intr_kind)ret;
281:               }
282:               
283:               void wizchip_setinterruptmask(intr_kind intr)
284:               {
285:                  uint8_t imr  = (uint8_t)intr;
286:                  uint8_t simr = (uint8_t)((uint16_t)intr >> 8);
287:               #if _WIZCHIP_ < 5500
288:                  imr &= ~(1<<4); // IK_WOL
289:               #endif
290:               #if _WIZCHIP_ == 5200
291:                  imr &= ~(1 << 6);
292:               #endif
293:                  
294:               #if _WIZCHIP_ < 5200
295:                  simr &= 0x0F;
296:               #endif
297:               
298:               #if _WIZCHIP_ == 5100
299:                  imr |= simr;
300:                  setIMR(imr);
301:               #else
302:                  setIMR(imr);
303:                  setSIMR(simr);
304:               #endif   
305:               }
306:               
307:               intr_kind wizchip_getinterruptmask(void)
308:               {
309:                  uint8_t imr  = 0;
310:                  uint8_t simr = 0;
311:                  uint16_t ret = 0;
312:               #if _WIZCHIP_ == 5100
313:                  imr  = getIMR();
314:                  simr = imr 0x0F;
315:               #else
316:                  imr  = getIMR();
317:                  simr = getSIMR();
318:               #endif         
319:               
320:               #if _WIZCHIP_ < 5500
321:                  imr &= ~(1<<4); // IK_WOL
322:               #endif
323:               #if _WIZCHIP_ == 5200
324:                  imr &= ~(1 << 6);  // IK_DEST_UNREACH
325:               #endif
326:                 ret = simr;
327:                 ret = (ret << 8) + imr;
328:                 return (intr_kind)ret;
329:               }
330:               
331:               int8_t wizphy_getphylink(void)
332:               {
333:                  int8_t tmp;
334:               #if   _WIZCHIP_ == 5200
335:                  if(getPHYSTATUS() & PHYSTATUS_LINK)
336:                     tmp = PHY_LINK_ON;
337:                  else
338:                     tmp = PHY_LINK_OFF;
339:               #elif _WIZCHIP_ == 5500
340:                  if(getPHYCFGR() & PHYCFGR_LNK_ON)
341:                     tmp = PHY_LINK_ON;
342:                  else
343:                     tmp = PHY_LINK_OFF;
344:               #else
345:                  tmp = -1;
346:               #endif
347:                  return tmp;
348:               }
349:               
350:               
351:               #if _WIZCHIP_ > 5100
352:               
353:               int8_t wizphy_getphypmode(void)
354:               {
355:                  int8_t tmp = 0;
356:                  #if   _WIZCHIP_ == 5200
357:                     if(getPHYSTATUS() & PHYSTATUS_POWERDOWN)
358:                        tmp = PHY_POWER_DOWN;
359:                     else          
360:                        tmp = PHY_POWER_NORM;
361:                  #elif _WIZCHIP_ == 5500
362:                     if(getPHYCFGR() & PHYCFGR_OPMDC_PDOWN)
363:                        tmp = PHY_POWER_DOWN;
364:                     else 
365:                        tmp = PHY_POWER_NORM;
366:                  #else
367:                     tmp = -1;
368:                  #endif
369:                  return tmp;
370:               }
371:               #endif
372:               */
373:               
374:               #if _WIZCHIP_ == 5500
375:               void wizphy_reset(void)
376:               {
377:                  uint8_t tmp = getPHYCFGR();
002384  22E000     MOV #0x2E00, W0
002386  200001     MOV #0x0, W1
002388  07FCF1     RCALL WIZCHIP_READ
378:                  tmp &= PHYCFGR_RST;
00238A  784100     MOV.B W0, W2
00238C  A17402     BCLR.B W2, #7
379:                  setPHYCFGR(tmp);
00238E  22E000     MOV #0x2E00, W0
002390  200001     MOV #0x0, W1
002392  07FD02     RCALL WIZCHIP_WRITE
380:                  tmp = getPHYCFGR(); 
002394  22E000     MOV #0x2E00, W0
002396  200001     MOV #0x0, W1
002398  07FCE9     RCALL WIZCHIP_READ
381:                  tmp |= ~PHYCFGR_RST;
00239A  784100     MOV.B W0, W2
00239C  A07402     BSET.B W2, #7
382:                  setPHYCFGR(tmp);
00239E  22E000     MOV #0x2E00, W0
0023A0  200001     MOV #0x0, W1
0023A2  07FCFA     RCALL WIZCHIP_WRITE
383:               }
0023A4  060000     RETURN
384:               
385:               void wizphy_setphyconf(wiz_PhyConf* phyconf)
386:               {
387:                  uint8_t tmp = 0;
388:                  if(phyconf->by == PHY_CONFBY_SW)
0023A8  B3C014     MOV #0x1, W4
0023AA  124F90     SUBR.B W4, [W0], [W15]
0023AC  3A0001     BRA NZ, 0x23B0
389:                     tmp |= PHYCFGR_OPMD;
0023AE  B3C402     MOV #0x40, W2
390:                  else
391:                     tmp &= ~PHYCFGR_OPMD;
0023A6  EB4100     CLR.B W2
392:                  if(phyconf->mode == PHY_MODE_AUTONEGO)
0023B0  904210     MOV.B [W0+1], W4
0023B2  524FE1     SUB.B W4, #0x1, [W15]
0023B4  3A0002     BRA NZ, 0x23BA
393:                     tmp |= PHYCFGR_OPMDC_ALLA;
0023B6  B34382     IOR.B #0x38, W2
0023B8  37000E     BRA 0x23D6
394:                  else
395:                  {
396:                     if(phyconf->duplex == PHY_DUPLEX_FULL)
0023BA  904230     MOV.B [W0+3], W4
0023BC  524FE1     SUB.B W4, #0x1, [W15]
0023BE  3A0007     BRA NZ, 0x23CE
397:                     {
398:                        if(phyconf->speed == PHY_SPEED_100)
0023C0  904220     MOV.B [W0+2], W4
0023C2  524FE1     SUB.B W4, #0x1, [W15]
0023C4  3A0002     BRA NZ, 0x23CA
399:                           tmp |= PHYCFGR_OPMDC_100F;
0023C6  B34182     IOR.B #0x18, W2
0023C8  370006     BRA 0x23D6
400:                        else
401:                           tmp |= PHYCFGR_OPMDC_10F;
0023CA  A03402     BSET.B W2, #3
0023CC  370004     BRA 0x23D6
402:                     }   
403:                     else
404:                     {
405:                        if(phyconf->speed == PHY_SPEED_100)
0023CE  904220     MOV.B [W0+2], W4
0023D0  524FE1     SUB.B W4, #0x1, [W15]
0023D2  3A0001     BRA NZ, 0x23D6
406:                           tmp |= PHYCFGR_OPMDC_100H;
0023D4  A04402     BSET.B W2, #4
407:                        else
408:                           tmp |= PHYCFGR_OPMDC_10H;
409:                     }
410:                  }
411:                  setPHYCFGR(tmp);
0023D6  22E000     MOV #0x2E00, W0
0023D8  200001     MOV #0x0, W1
0023DA  07FCDE     RCALL WIZCHIP_WRITE
412:                  wizphy_reset();
0023DC  07FFD3     RCALL wizphy_reset
413:               }
0023DE  060000     RETURN
414:               
415:               #endif
416:               
417:               /*
418:               void wizphy_getphyconf(wiz_PhyConf* phyconf)
419:               {
420:                  uint8_t tmp = 0;
421:                  tmp = getPHYCFGR();
422:                  phyconf->by   = (tmp & PHYCFGR_OPMD) ? PHY_CONFBY_SW : PHY_CONFBY_HW;
423:                  switch(tmp & PHYCFGR_OPMDC_ALLA)
424:                  {
425:                     case PHYCFGR_OPMDC_ALLA:
426:                     case PHYCFGR_OPMDC_100FA: 
427:                        phyconf->mode = PHY_MODE_AUTONEGO;
428:                        break;
429:                     default:
430:                        phyconf->mode = PHY_MODE_MANUAL;
431:                        break;
432:                  }
433:                  switch(tmp & PHYCFGR_OPMDC_ALLA)
434:                  {
435:                     case PHYCFGR_OPMDC_100FA:
436:                     case PHYCFGR_OPMDC_100F:
437:                     case PHYCFGR_OPMDC_100H:
438:                        phyconf->speed = PHY_SPEED_100;
439:                        break;
440:                     default:
441:                        phyconf->speed = PHY_SPEED_10;
442:                        break;
443:                  }
444:                  switch(tmp & PHYCFGR_OPMDC_ALLA)
445:                  {
446:                     case PHYCFGR_OPMDC_100FA:
447:                     case PHYCFGR_OPMDC_100F:
448:                     case PHYCFGR_OPMDC_10F:
449:                        phyconf->duplex = PHY_DUPLEX_FULL;
450:                        break;
451:                     default:
452:                        phyconf->duplex = PHY_DUPLEX_HALF;
453:                        break;
454:                  }
455:               }
456:               
457:               void wizphy_getphystat(wiz_PhyConf* phyconf)
458:               {
459:                  uint8_t tmp = getPHYCFGR();
460:                  phyconf->duplex = (tmp & PHYCFGR_DPX_FULL) ? PHY_DUPLEX_FULL : PHY_DUPLEX_HALF;
461:                  phyconf->speed  = (tmp & PHYCFGR_SPD_100) ? PHY_SPEED_100 : PHY_SPEED_10;
462:               }
463:               
464:               
465:               int8_t wizphy_setphypmode(uint8_t pmode)
466:               {
467:                  uint8_t tmp = 0;
468:                  tmp = getPHYCFGR();
469:                  if((tmp & PHYCFGR_OPMD)== 0) return -1;
470:                  tmp &= ~PHYCFGR_OPMDC_ALLA;         
471:                  if( pmode == PHY_POWER_DOWN)
472:                     tmp |= PHYCFGR_OPMDC_PDOWN;
473:                  else
474:                     tmp |= PHYCFGR_OPMDC_ALLA;
475:                  setPHYCFGR(tmp);
476:                  wizphy_reset();
477:                  tmp = getPHYCFGR();
478:                  if( pmode == PHY_POWER_DOWN)
479:                  {
480:                     if(tmp & PHYCFGR_OPMDC_PDOWN) return 0;
481:                  }
482:                  else
483:                  {
484:                     if(tmp & PHYCFGR_OPMDC_ALLA) return 0;
485:                  }
486:                  return -1;
487:               }
488:               #endif
489:               
490:               
491:               void wizchip_setnetinfo(wiz_NetInfo* pnetinfo)
492:               {
493:                  setSHAR(pnetinfo->mac);
494:                  setGAR(pnetinfo->gw);
495:                  setSUBR(pnetinfo->sn);
496:                  setSIPR(pnetinfo->ip);
497:                  _DNS_[0] = pnetinfo->dns[0];
498:                  _DNS_[1] = pnetinfo->dns[1];
499:                  _DNS_[2] = pnetinfo->dns[2];
500:                  _DNS_[3] = pnetinfo->dns[3];
501:                  _DHCP_   = pnetinfo->dhcp;
502:               }
503:               
504:               void wizchip_getnetinfo(wiz_NetInfo* pnetinfo)
505:               {
506:                  getSHAR(pnetinfo->mac);
507:                  getGAR(pnetinfo->gw);
508:                  getSUBR(pnetinfo->sn);
509:                  getSIPR(pnetinfo->ip);
510:                  pnetinfo->dns[0]= _DNS_[0];
511:                  pnetinfo->dns[1]= _DNS_[1];
512:                  pnetinfo->dns[2]= _DNS_[2];
513:                  pnetinfo->dns[3]= _DNS_[3];
514:                  pnetinfo->dhcp  = _DHCP_;
515:               }
516:               
517:               int8_t wizchip_setnetmode(netmode_type netmode)
518:               {
519:                  uint8_t tmp = 0;
520:               #if _WIZCHIP_ != 5500   
521:                  if(netmode & ~(NM_WAKEONLAN | NM_PPPOE | NM_PINGBLOCK)) return -1;
522:               #else
523:                  if(netmode & ~(NM_WAKEONLAN | NM_PPPOE | NM_PINGBLOCK | NM_FORCEARP)) return -1;
524:               #endif      
525:                  tmp = getMR();
526:                  tmp |= (uint8_t)netmode;
527:                  setMR(tmp);
528:                  return 0;
529:               }
530:               
531:               netmode_type wizchip_getnetmode(void)
532:               {
533:                  return (netmode_type) getMR();
534:               }
535:               
536:               void wizchip_settimeout(wiz_NetTimeout* nettime)
537:               {
538:                  setRCR(nettime->retry_cnt);
539:                  setRTR(nettime->time_100us);
540:               }
541:               
542:               void wizchip_gettimeout(wiz_NetTimeout* nettime)
543:               {
544:                  nettime->retry_cnt = getRCR();
545:                  nettime->time_100us = getRTR();
546:               }
547:               
548:                */
549:               
550:               uint8_t dummy;
551:               
552:               void inline WIZCHIP_SPI_write_byte(uint8_t b)
553:               {
554:                   SPI1BUF=b;
0023E0  FB8000     ZE W0, W0
0023E2  881240     MOV W0, SPI1BUF
555:                   while(!SPI1STATbits.SPIRBF);
0023E4  AB0240     BTST SPI1STAT, #0
0023E6  32FFFE     BRA Z, 0x23E4
556:                   dummy=SPI1BUF;
0023E8  801244     MOV SPI1BUF, W4
0023EA  784004     MOV.B W4, W0
0023EC  B7EB48     MOV.B WREG, dummy
557:               
558:               }
0023EE  060000     RETURN
559:               
560:               uint8_t inline WIZCHIP_SPI_read_byte(void)
561:               {
562:                   SPI1BUF = 0xFF;
0023F0  200FF4     MOV #0xFF, W4
0023F2  881244     MOV W4, SPI1BUF
563:                   while(!SPI1STATbits.SPIRBF);
0023F4  AB0240     BTST SPI1STAT, #0
0023F6  32FFFE     BRA Z, 0x23F4
564:                   return SPI1BUF;
0023F8  801240     MOV SPI1BUF, W0
565:                
566:               }
0023FA  060000     RETURN
---  F:/microchip/mla/v2013_12_20/apps/usb/device/msd_internal_flash/firmware/src/Ethernet/socket.c  ----
1:                 //*****************************************************************************
2:                 //
3:                 //! \file socket.c
4:                 //! \brief SOCKET APIs Implements file.
5:                 //! \details SOCKET APIs like as Berkeley Socket APIs. 
6:                 //! \version 1.0.2
7:                 //! \date 2013/10/21
8:                 //! \par  Revision history
9:                 //!       <2013/10/21> 1st Release
10:                //!       <2013/11/04> V1.0.1 2nd Release. Refer to "20131104".
11:                //!                    In sendto(), Add to clear timeout interrupt status (Sn_IR_TIMEOUT)
12:                //!       <2013/12/20> V1.0.2 Refer to M20131220
13:                //!                    Remove Warning.
14:                //! \author MidnightCow
15:                //! \copyright
16:                //!
17:                //! Copyright (c)  2013, WIZnet Co., LTD.
18:                //! All rights reserved.
19:                //! 
20:                //! Redistribution and use in source and binary forms, with or without 
21:                //! modification, are permitted provided that the following conditions 
22:                //! are met: 
23:                //! 
24:                //!     * Redistributions of source code must retain the above copyright 
25:                //! notice, this list of conditions and the following disclaimer. 
26:                //!     * Redistributions in binary form must reproduce the above copyright
27:                //! notice, this list of conditions and the following disclaimer in the
28:                //! documentation and/or other materials provided with the distribution. 
29:                //!     * Neither the name of the <ORGANIZATION> nor the names of its 
30:                //! contributors may be used to endorse or promote products derived 
31:                //! from this software without specific prior written permission. 
32:                //! 
33:                //! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
34:                //! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
35:                //! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
36:                //! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
37:                //! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
38:                //! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
39:                //! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
40:                //! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
41:                //! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
42:                //! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
43:                //! THE POSSIBILITY OF SUCH DAMAGE.
44:                //
45:                //*****************************************************************************
46:                #include "socket.h"
47:                
48:                #define SOCK_ANY_PORT_NUM  0xC000;
49:                
50:                static uint16_t sock_any_port = SOCK_ANY_PORT_NUM;
51:                static uint16_t sock_io_mode = 0;
52:                static uint16_t sock_is_sending = 0;
53:                static uint16_t sock_remained_size[_WIZCHIP_SOCK_NUM_] = {0,0,0,0,0,0,0,0};
54:                static uint8_t  sock_pack_info[_WIZCHIP_SOCK_NUM_] = {0,0,0,0,0,0,0,0};
55:                
56:                #if _WIZCHIP_ == 5200
57:                   static uint16_t sock_next_rd[_WIZCHIP_SOCK_NUM_] ={0,};
58:                #endif
59:                
60:                #define CHECK_SOCKNUM()   \
61:                   do{                    \
62:                      if(sn > _WIZCHIP_SOCK_NUM_) return SOCKERR_SOCKNUM;   \
63:                   }while(0);             \
64:                
65:                #define CHECK_SOCKMODE(mode)  \
66:                   do{                     \
67:                      if((getSn_MR(sn) & 0x0F) != mode) return SOCKERR_SOCKMODE;  \
68:                   }while(0);              \
69:                
70:                #define CHECK_SOCKINIT()   \
71:                   do{                     \
72:                      if((getSn_SR(sn) != SOCK_INIT)) return SOCKERR_SOCKINIT; \
73:                   }while(0);              \
74:                
75:                #define CHECK_SOCKDATA()   \
76:                   do{                     \
77:                      if(len == 0) return SOCKERR_DATALEN;   \
78:                   }while(0);              \
79:                
80:                
81:                
82:                int8_t socket(uint8_t sn, uint8_t protocol, uint16_t port, uint8_t flag)
83:                {
001986  BE9F88     MOV.D W8, [W15++]
001988  BE9F8A     MOV.D W10, [W15++]
00198A  BE9F8C     MOV.D W12, [W15++]
00198C  781F8E     MOV W14, [W15++]
00198E  784500     MOV.B W0, W10
001990  784401     MOV.B W1, W8
001992  780582     MOV W2, W11
001994  784483     MOV.B W3, W9
84:                	CHECK_SOCKNUM();
001996  EBC000     SETM.B W0
001998  554FE8     SUB.B W10, #0x8, [W15]
00199A  3E0061     BRA GTU, 0x1A5E
85:                	switch(protocol)
00199C  544FE4     SUB.B W8, #0x4, [W15]
00199E  3E005E     BRA GTU, 0x1A5C
0019A0  FB0208     SE W8, W4
0019A2  200015     MOV #0x1, W5
0019A4  DD2A04     SL W5, W4, W4
0019A6  620276     AND W4, #0x16, W4
0019A8  320059     BRA Z, 0x1A5C
86:                	{
87:                      case Sn_MR_TCP :
88:                      case Sn_MR_UDP :
89:                      case Sn_MR_MACRAW :
90:                         break;
91:                   #if ( _WIZCHIP_ < 5200 )
92:                      case Sn_MR_IPRAW :
93:                      case Sn_MR_PPPoE :
94:                         break;
95:                   #endif
96:                      default :
97:                         return SOCKERR_SOCKMODE;
001A5C  B3CFB0     MOV #0xFB, W0
98:                	}
99:                	if((flag & 0x06) != 0) return SOCKERR_SOCKFLAG;
0019AA  FB8689     ZE W9, W13
0019AC  668266     AND W13, #0x6, W4
0019AE  B3CFA0     MOV #0xFA, W0
0019B0  3A0056     BRA NZ, 0x1A5E
100:               #if _WIZCHIP_ == 5200
101:                  if(flag & 0x10) return SOCKERR_SOCKFLAG;
102:               #endif
103:               	   
104:               	if(flag != 0)
0019B2  54CFE0     SUB.B W9, #0x0, [W15]
0019B4  320015     BRA Z, 0x19E0
105:               	{
106:                  	switch(protocol)
0019B6  544FE1     SUB.B W8, #0x1, [W15]
0019B8  320003     BRA Z, 0x19C0
0019BA  544FE2     SUB.B W8, #0x2, [W15]
0019BC  3A0011     BRA NZ, 0x19E0
0019BE  370005     BRA 0x19CA
107:                  	{
108:                  	   case Sn_MR_TCP:
109:                  	      if((flag & (SF_TCP_NODELAY|SF_IO_NONBLOCK))==0) return SOCKERR_SOCKFLAG;
0019C0  78020D     MOV W13, W4
0019C2  B20214     AND #0x21, W4
0019C4  B3CFA0     MOV #0xFA, W0
0019C6  3A000C     BRA NZ, 0x19E0
0019C8  37004A     BRA 0x1A5E
110:                  	      break;
111:                  	   case Sn_MR_UDP:
112:                  	      if(flag & SF_IGMP_VER2)
0019CA  78020D     MOV W13, W4
0019CC  B20204     AND #0x20, W4
0019CE  320003     BRA Z, 0x19D6
113:                  	      {
114:                  	         if((flag & SF_MULTI_ENABLE)==0) return SOCKERR_SOCKFLAG;
0019D0  B3CFA0     MOV #0xFA, W0
0019D2  54CFE0     SUB.B W9, #0x0, [W15]
0019D4  3D0044     BRA GE, 0x1A5E
115:                  	      }
116:                  	      #if _WIZCHIP_ == 5500
117:                     	      if(flag & SF_UNI_BLOCK)
0019D6  668270     AND W13, #0x10, W4
0019D8  320003     BRA Z, 0x19E0
118:                     	      {
119:                     	         if((flag & SF_MULTI_ENABLE) == 0) return SOCKERR_SOCKFLAG;
0019DA  B3CFA0     MOV #0xFA, W0
0019DC  54CFE0     SUB.B W9, #0x0, [W15]
0019DE  3D003F     BRA GE, 0x1A5E
120:                     	      }
121:                  	      #endif
122:                  	      break;
123:                  	   default:
124:                  	      break;
125:                  	}
126:                  }
127:               	close(sn);
0019E0  78400A     MOV.B W10, W0
0019E2  07FFA3     RCALL close
128:               	setSn_MR(sn, (protocol | (flag & 0xF0)));
0019E4  FB860A     ZE W10, W12
0019E6  DD6745     SL W12, #5, W14
0019E8  470768     ADD W14, #0x8, W14
0019EA  B3CF02     MOV #0xF0, W2
0019EC  64C102     AND.B W9, W2, W2
0019EE  714108     IOR.B W2, W8, W2
0019F0  B97061     MUL.SU W14, #1, W0
0019F2  0701D2     RCALL WIZCHIP_WRITE
129:               	if(!port)
0019F4  558FE0     SUB W11, #0x0, [W15]
0019F6  3A0007     BRA NZ, 0x1A06
130:               	{
131:               	   port = sock_any_port++;
0019F8  805A3B     MOV sock_any_port, W11
0019FA  E8020B     INC W11, W4
0019FC  885A34     MOV W4, sock_any_port
132:               	   if(sock_any_port == 0xFFF0) sock_any_port = SOCK_ANY_PORT_NUM;
0019FE  420FF0     ADD W4, #0x10, [W15]
001A00  3A0002     BRA NZ, 0x1A06
001A02  2C0004     MOV #0xC000, W4
001A04  885A34     MOV W4, sock_any_port
133:               	}
134:                  setSn_PORT(sn,port);	
001A06  DE5948     LSR W11, #8, W2
001A08  204000     MOV #0x400, W0
001A0A  470000     ADD W14, W0, W0
001A0C  DE80CF     ASR W0, #15, W1
001A0E  0701C4     RCALL WIZCHIP_WRITE
001A10  205000     MOV #0x500, W0
001A12  470000     ADD W14, W0, W0
001A14  DE80CF     ASR W0, #15, W1
001A16  78410B     MOV.B W11, W2
001A18  0701BF     RCALL WIZCHIP_WRITE
135:                  setSn_CR(sn,Sn_CR_OPEN);
001A1A  201008     MOV #0x100, W8
001A1C  44040E     ADD W8, W14, W8
001A1E  DEC4CF     ASR W8, #15, W9
001A20  B3C012     MOV #0x1, W2
001A22  BE0008     MOV.D W8, W0
001A24  0701B9     RCALL WIZCHIP_WRITE
136:                  while(getSn_CR(sn));
001A26  BE0008     MOV.D W8, W0
001A28  0701A1     RCALL WIZCHIP_READ
001A2A  504FE0     SUB.B W0, #0x0, [W15]
001A2C  3AFFFC     BRA NZ, 0x1A26
137:               	sock_io_mode |= ((flag & SF_IO_NONBLOCK) << sn);   
001A2E  668061     AND W13, #0x1, W0
001A30  DD000C     SL W0, W12, W0
001A32  B72B14     IOR sock_io_mode
138:                  sock_is_sending &= ~(1<<sn);
001A34  200010     MOV #0x1, W0
001A36  DD000C     SL W0, W12, W0
001A38  EA8000     COM W0, W0
001A3A  B62B1E     AND sock_is_sending
139:                  sock_remained_size[sn] = 0;
001A3C  46020C     ADD W12, W12, W4
001A3E  20B045     MOV #0xB04, W5
001A40  428284     ADD W5, W4, W5
001A42  EB0200     CLR W4
001A44  780A84     MOV W4, [W5]
140:                  sock_pack_info[sn] = 0;
001A46  20B165     MOV #0xB16, W5
001A48  7E7284     MOV.B W4, [W5+W12]
141:                  while(getSn_SR(sn) == SOCK_CLOSED);
001A4A  203008     MOV #0x300, W8
001A4C  44040E     ADD W8, W14, W8
001A4E  DEC4CF     ASR W8, #15, W9
001A50  BE0008     MOV.D W8, W0
001A52  07018C     RCALL WIZCHIP_READ
001A54  504FE0     SUB.B W0, #0x0, [W15]
001A56  32FFFC     BRA Z, 0x1A50
142:                  return (int8_t)sn;
001A58  78400A     MOV.B W10, W0
001A5A  370001     BRA 0x1A5E
143:               }	   
001A5E  78074F     MOV [--W15], W14
001A60  BE064F     MOV.D [--W15], W12
001A62  BE054F     MOV.D [--W15], W10
001A64  BE044F     MOV.D [--W15], W8
001A66  060000     RETURN
144:               
145:               int8_t close(uint8_t sn)
146:               {
00192A  BE9F88     MOV.D W8, [W15++]
00192C  BE9F8A     MOV.D W10, [W15++]
00192E  784500     MOV.B W0, W10
147:               	CHECK_SOCKNUM();
001930  EBC000     SETM.B W0
001932  554FE8     SUB.B W10, #0x8, [W15]
001934  3E0025     BRA GTU, 0x1980
148:               	
149:               	setSn_CR(sn,Sn_CR_CLOSE);
001936  FB850A     ZE W10, W10
001938  DD55C5     SL W10, #5, W11
00193A  4585E8     ADD W11, #0x8, W11
00193C  201008     MOV #0x100, W8
00193E  44040B     ADD W8, W11, W8
001940  DEC4CF     ASR W8, #15, W9
001942  B3C102     MOV #0x10, W2
001944  BE0008     MOV.D W8, W0
001946  070228     RCALL WIZCHIP_WRITE
150:                  /* wait to process the command... */
151:               	while( getSn_CR(sn) );
001948  BE0008     MOV.D W8, W0
00194A  070210     RCALL WIZCHIP_READ
00194C  504FE0     SUB.B W0, #0x0, [W15]
00194E  3AFFFC     BRA NZ, 0x1948
152:               	/* clear all interrupt of the socket. */
153:               	setSn_IR(sn, 0xFF);
001950  202000     MOV #0x200, W0
001952  40000B     ADD W0, W11, W0
001954  DE80CF     ASR W0, #15, W1
001956  B3C1F2     MOV #0x1F, W2
001958  07021F     RCALL WIZCHIP_WRITE
154:               	sock_is_sending &= ~(1<<sn);
00195A  200010     MOV #0x1, W0
00195C  DD000A     SL W0, W10, W0
00195E  EA8000     COM W0, W0
001960  B62B1E     AND sock_is_sending
155:               	sock_remained_size[sn] = 0;
001962  45020A     ADD W10, W10, W4
001964  20B045     MOV #0xB04, W5
001966  428284     ADD W5, W4, W5
001968  EB0200     CLR W4
00196A  780A84     MOV W4, [W5]
156:               	sock_pack_info[sn] = 0;
00196C  20B165     MOV #0xB16, W5
00196E  7D7284     MOV.B W4, [W5+W10]
157:               	while(getSn_SR(sn) != SOCK_CLOSED);
001970  203008     MOV #0x300, W8
001972  44040B     ADD W8, W11, W8
001974  DEC4CF     ASR W8, #15, W9
001976  BE0008     MOV.D W8, W0
001978  0701F9     RCALL WIZCHIP_READ
00197A  504FE0     SUB.B W0, #0x0, [W15]
00197C  3AFFFC     BRA NZ, 0x1976
158:               	return SOCK_OK;
00197E  B3C010     MOV #0x1, W0
159:               }
001980  BE054F     MOV.D [--W15], W10
001982  BE044F     MOV.D [--W15], W8
001984  060000     RETURN
160:               
161:               /*
162:               int8_t listen(uint8_t sn)
163:               {
164:               	CHECK_SOCKNUM();
165:                  CHECK_SOCKMODE(Sn_MR_TCP);
166:               	CHECK_SOCKINIT();
167:               	setSn_CR(sn,Sn_CR_LISTEN);
168:               	while(getSn_CR(sn));
169:                  while(getSn_SR(sn) != SOCK_LISTEN)
170:                  {
171:                     if(getSn_CR(sn) == SOCK_CLOSED)
172:                     {
173:                        close(sn);
174:                        return SOCKERR_SOCKCLOSED;
175:                     }
176:                  }
177:                  return SOCK_OK;
178:               }
179:               
180:               
181:               
182:               int8_t connect(uint8_t sn, uint8_t * addr, uint16_t port)
183:               {
184:                  CHECK_SOCKNUM();
185:                  CHECK_SOCKMODE(Sn_MR_TCP);
186:                  CHECK_SOCKINIT();
187:               	if( *((uint32_t*)addr) == 0xFFFFFFFF || *((uint32_t*)addr) == 0) return SOCKERR_IPINVALID;
188:               	if(port == 0) return SOCKERR_PORTZERO;
189:               	setSn_DIPR(sn,addr);
190:               	setSn_DPORT(sn,port);
191:                  #if _WIZCHIP_ == 5200    
192:                     setSUBR(0);
193:                  #endif
194:               	setSn_CR(sn,Sn_CR_CONNECT);
195:                  while(getSn_CR(sn));
196:                  if(sock_io_mode & (1<<sn)) return SOCK_BUSY;
197:                  while(getSn_SR(sn) != SOCK_ESTABLISHED)
198:                  {   
199:               		if (getSn_IR(sn) & Sn_IR_TIMEOUT)
200:               		{
201:               			setSn_IR(sn, Sn_IR_TIMEOUT);
202:                        #if _WIZCHIP_ == 5200   
203:                           setSUBR((uint8_t*)"\x00\x00\x00\x00");
204:                        #endif
205:                        return SOCKERR_TIMEOUT;
206:               		}
207:               	}
208:                  #if _WIZCHIP_ == 5200   
209:                     setSUBR((uint8_t*)"\x00\x00\x00\x00");
210:                  #endif
211:                  
212:                  return SOCK_OK;
213:               }
214:               
215:               int8_t disconnect(uint8_t sn)
216:               {
217:                  CHECK_SOCKNUM();
218:                  CHECK_SOCKMODE(Sn_MR_TCP);
219:               	setSn_CR(sn,Sn_CR_DISCON);
220:               	
221:               	while(getSn_CR(sn));
222:               	sock_is_sending &= ~(1<<sn);
223:                  if(sock_io_mode & (1<<sn)) return SOCK_BUSY;
224:               	while(getSn_SR(sn) != SOCK_CLOSED)
225:               	{
226:               	   if(getSn_IR(sn) & Sn_IR_TIMEOUT)
227:               	   {
228:               	      close(sn);
229:               	      return SOCKERR_TIMEOUT;
230:               	   }
231:               	}
232:               	return SOCK_OK;
233:               }
234:               
235:               int32_t send(uint8_t sn, uint8_t * buf, uint16_t len)
236:               {
237:                  uint8_t tmp=0;
238:                  uint16_t freesize=0;
239:                  
240:                  CHECK_SOCKNUM();
241:                  CHECK_SOCKMODE(Sn_MR_TCP);
242:                  CHECK_SOCKDATA();
243:                  tmp = getSn_SR(sn);
244:                  if(tmp != SOCK_ESTABLISHED && tmp != SOCK_CLOSE_WAIT) return SOCKERR_SOCKSTATUS;
245:                  if( sock_is_sending & (1<<sn) )
246:                  {
247:                     tmp = getSn_IR(sn);
248:                     if(tmp & Sn_IR_SENDOK)
249:                     {
250:                        setSn_IR(sn, Sn_IR_SENDOK);
251:                        #if _WZICHIP_ == 5200
252:                           if(getSn_TX_RD(sn) != sock_next_rd[sn])
253:                           {
254:                              setSn_CR(sn,Sn_CR_SEND);
255:                              while(getSn_CR(sn));
256:                              return SOCKERR_BUSY;
257:                           }
258:                        #endif
259:                        sock_is_sending &= ~(1<<sn);         
260:                     }
261:                     else if(tmp & Sn_IR_TIMEOUT)
262:                     {
263:                        close(sn);
264:                        return SOCKERR_TIMEOUT;
265:                     }
266:                     else return SOCK_BUSY;
267:                  }
268:                  freesize = getSn_TxMAX(sn);
269:                  if (len > freesize) len = freesize; 
270:                  while(1)
271:                  {
272:                     freesize = getSn_TX_FSR(sn);
273:                     tmp = getSn_SR(sn);
274:                     if ((tmp != SOCK_ESTABLISHED) && (tmp != SOCK_CLOSE_WAIT))
275:                     {
276:                        close(sn);
277:                        return SOCKERR_SOCKSTATUS;
278:                     }
279:                     if( (sock_io_mode & (1<<sn)) && (len > freesize) ) return SOCK_BUSY;
280:                     if(len <= freesize) break;
281:                  }
282:                  wiz_send_data(sn, buf, len);
283:                  #if _WIZCHIP_ == 5200
284:                     sock_next_rd[sn] = getSn_TX_RD(sn) + len;
285:                  #endif
286:                  setSn_CR(sn,Sn_CR_SEND);
287:                 
288:                  while(getSn_CR(sn));
289:                  sock_is_sending |= (1 << sn);
290:                  return len;
291:               }
292:               
293:               
294:               int32_t recv(uint8_t sn, uint8_t * buf, uint16_t len)
295:               {
296:                  uint8_t  tmp = 0;
297:                  uint16_t recvsize = 0;
298:                  CHECK_SOCKNUM();
299:                  CHECK_SOCKMODE(Sn_MR_TCP);
300:                  CHECK_SOCKDATA();
301:                  
302:                  recvsize = getSn_RxMAX(sn);
303:                  if(recvsize < len) len = recvsize;
304:                  while(1)
305:                  {
306:                     recvsize = getSn_RX_RSR(sn);
307:                     tmp = getSn_SR(sn);
308:                     if (tmp != SOCK_ESTABLISHED)
309:                     {
310:                        if(tmp == SOCK_CLOSE_WAIT)
311:                        {
312:                           if(recvsize != 0) break;
313:                           else if(getSn_TX_FSR(sn) == getSn_TxMAX(sn))
314:                           {
315:                              close(sn);
316:                              return SOCKERR_SOCKSTATUS;
317:                           }
318:                        }
319:                        else
320:                        {
321:                           close(sn);
322:                           return SOCKERR_SOCKSTATUS;
323:                        }
324:                     }
325:                     if((sock_io_mode & (1<<sn)) && (recvsize == 0)) return SOCK_BUSY;
326:                     if(recvsize != 0) break;
327:                  };
328:                  if(recvsize < len) len = recvsize;
329:                  wiz_recv_data(sn, buf, len);
330:                  setSn_CR(sn,Sn_CR_RECV);
331:                  while(getSn_CR(sn));
332:                  return len;
333:               }
334:               */
335:               
336:               int32_t sendto(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t * addr, uint16_t port)
337:               {
001A68  4787E6     ADD W15, #0x6, W15
001A6A  BE9F88     MOV.D W8, [W15++]
001A6C  BE9F8A     MOV.D W10, [W15++]
001A6E  BE9F8C     MOV.D W12, [W15++]
001A70  781F8E     MOV W14, [W15++]
001A72  784500     MOV.B W0, W10
001A74  780701     MOV W1, W14
001A76  780682     MOV W2, W13
001A78  780583     MOV W3, W11
001A7A  780604     MOV W4, W12
338:                  uint8_t tmp = 0;
339:                  uint16_t freesize = 0;
340:                  CHECK_SOCKNUM();
001A7C  EB8000     SETM W0
001A7E  EB8080     SETM W1
001A80  554FE8     SUB.B W10, #0x8, [W15]
001A82  3E0080     BRA GTU, 0x1B84
341:                  switch(getSn_MR(sn) & 0x0F)
001A84  FB820A     ZE W10, W4
001A86  9FB7F4     MOV W4, [W15-18]
001A88  780284     MOV W4, W5
001A8A  DD2A45     SL W5, #5, W4
001A8C  420268     ADD W4, #0x8, W4
001A8E  9FBF84     MOV W4, [W15-16]
001A90  B92061     MUL.SU W4, #1, W0
001A92  07016C     RCALL WIZCHIP_READ
001A94  60026F     AND W0, #0xF, W4
001A96  520FE2     SUB W4, #0x2, [W15]
001A98  320004     BRA Z, 0x1AA2
001A9E  520FE4     SUB W4, #0x4, [W15]
001AA0  3A0071     BRA NZ, 0x1B84
342:                  {
343:                     case Sn_MR_UDP:
344:                     case Sn_MR_MACRAW:
345:                        break;
346:                     default:
347:                        return SOCKERR_SOCKMODE;
001A9A  2FFFB0     MOV #0xFFFB, W0
001A9C  2FFFF1     MOV #0xFFFF, W1
348:                  }
349:                  CHECK_SOCKDATA();
001AA2  2FFF20     MOV #0xFFF2, W0
001AA4  2FFFF1     MOV #0xFFFF, W1
001AA6  568FE0     SUB W13, #0x0, [W15]
001AA8  32006D     BRA Z, 0x1B84
350:                  if(*((uint32_t*)addr) == 0) return SOCKERR_IPINVALID;
001AAA  BE021B     MOV.D [W11], W4
001AAC  2FFF40     MOV #0xFFF4, W0
001AAE  2FFFF1     MOV #0xFFFF, W1
001AB0  520FE0     SUB W4, #0x0, [W15]
001AB2  5A8FE0     SUBB W5, #0x0, [W15]
001AB4  320067     BRA Z, 0x1B84
351:                  if(port == 0)               return SOCKERR_PORTZERO;
001AB6  2FFF50     MOV #0xFFF5, W0
001AB8  2FFFF1     MOV #0xFFFF, W1
001ABA  560FE0     SUB W12, #0x0, [W15]
001ABC  320063     BRA Z, 0x1B84
352:                  tmp = getSn_SR(sn);
001ABE  97BC0F     MOV [W15-16], W8
001AC0  B03008     ADD #0x300, W8
001AC2  DEC4CF     ASR W8, #15, W9
001AC4  BE0008     MOV.D W8, W0
001AC6  070152     RCALL WIZCHIP_READ
001AC8  784200     MOV.B W0, W4
353:                  if(tmp != SOCK_MACRAW && tmp != SOCK_UDP) return SOCKERR_SOCKSTATUS;
001ACA  B3C425     MOV #0x42, W5
001ACC  524F85     SUB.B W4, W5, [W15]
001ACE  320005     BRA Z, 0x1ADA
001AD0  2FFF90     MOV #0xFFF9, W0
001AD2  2FFFF1     MOV #0xFFFF, W1
001AD4  B3C225     MOV #0x22, W5
001AD6  524F85     SUB.B W4, W5, [W15]
001AD8  3A0055     BRA NZ, 0x1B84
354:                     
355:                  setSn_DIPR(sn,addr);
001ADA  20C000     MOV #0xC00, W0
001ADC  97BA0F     MOV [W15-16], W4
001ADE  420000     ADD W4, W0, W0
001AE0  DE80CF     ASR W0, #15, W1
001AE2  200043     MOV #0x4, W3
001AE4  78010B     MOV W11, W2
001AE6  070192     RCALL WIZCHIP_WRITE_BUF
356:                  setSn_DPORT(sn,port);      
001AE8  DE6148     LSR W12, #8, W2
001AEA  210000     MOV #0x1000, W0
001AEC  97BA8F     MOV [W15-16], W5
001AEE  428000     ADD W5, W0, W0
001AF0  DE80CF     ASR W0, #15, W1
001AF2  070152     RCALL WIZCHIP_WRITE
001AF4  211000     MOV #0x1100, W0
001AF6  97BA0F     MOV [W15-16], W4
001AF8  420000     ADD W4, W0, W0
001AFA  DE80CF     ASR W0, #15, W1
001AFC  78410C     MOV.B W12, W2
001AFE  07014C     RCALL WIZCHIP_WRITE
357:                  freesize = getSn_TxMAX(sn);
001B00  21F000     MOV #0x1F00, W0
001B02  97BA8F     MOV [W15-16], W5
001B04  428000     ADD W5, W0, W0
001B06  DE80CF     ASR W0, #15, W1
001B08  070131     RCALL WIZCHIP_READ
001B0A  DD064A     SL W0, #10, W12
001B0C  560F8D     SUB W12, W13, [W15]
001B0E  360001     BRA LEU, 0x1B12
001B10  78060D     MOV W13, W12
358:                  if (len > freesize) len = freesize; // check size not to exceed MAX size.
359:                  while(1)
360:                  {
361:                     freesize = getSn_TX_FSR(sn);
001B18  78400A     MOV.B W10, W0
001B1A  070199     RCALL getSn_TX_FSR
001B1C  780580     MOV W0, W11
362:                     if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
001B1E  BE0008     MOV.D W8, W0
001B20  070125     RCALL WIZCHIP_READ
001B22  504FE0     SUB.B W0, #0x0, [W15]
001B24  32002D     BRA Z, 0x1B80
001B80  2FFFC0     MOV #0xFFFC, W0
001B82  2FFFF1     MOV #0xFFFF, W1
363:                     if( (sock_io_mode & (1<<sn)) && (len > freesize) ) return SOCK_BUSY;
001B12  20001D     MOV #0x1, W13
001B14  97B27F     MOV [W15-18], W4
001B16  DD6E84     SL W13, W4, W13
001B26  8058A5     MOV sock_io_mode, W5
001B28  62820D     AND W5, W13, W4
001B2A  320004     BRA Z, 0x1B34
001B2C  B80060     MUL.UU W0, #0, W0
001B2E  560F8B     SUB W12, W11, [W15]
001B30  360003     BRA LEU, 0x1B38
001B32  370028     BRA 0x1B84
364:                     if(len <= freesize) break;
001B34  558F8C     SUB W11, W12, [W15]
001B36  39FFF0     BRA NC, 0x1B18
365:                  };
366:               	wiz_send_data(sn, buf, len);
001B38  78010C     MOV W12, W2
001B3A  78008E     MOV W14, W1
001B3C  78400A     MOV.B W10, W0
001B3E  0701D1     RCALL wiz_send_data
367:               
368:                  #if _WIZCHIP_ == 5200   // for W5200 ARP errata 
369:                     setSUBR(0);
370:                  #endif
371:               
372:               	setSn_CR(sn,Sn_CR_SEND);
001B40  97BC0F     MOV [W15-16], W8
001B42  B01008     ADD #0x100, W8
001B44  DEC4CF     ASR W8, #15, W9
001B46  B3C202     MOV #0x20, W2
001B48  BE0008     MOV.D W8, W0
001B4A  070126     RCALL WIZCHIP_WRITE
373:               	/* wait to process the command... */
374:               	while(getSn_CR(sn));
001B4C  BE0008     MOV.D W8, W0
001B4E  07010E     RCALL WIZCHIP_READ
001B50  504FE0     SUB.B W0, #0x0, [W15]
001B52  3AFFFC     BRA NZ, 0x1B4C
375:                  #if _WIZCHIP_ == 5200   // for W5200 ARP errata 
376:                     setSUBR((uint8_t*)"\x00\x00\x00\x00");
377:                  #endif
378:                  while(1)
379:                  {
380:                     tmp = getSn_IR(sn);
001B54  97BD0F     MOV [W15-16], W10
001B56  B0200A     ADD #0x200, W10
001B58  DED5CF     ASR W10, #15, W11
001B5A  BE000A     MOV.D W10, W0
001B5C  070107     RCALL WIZCHIP_READ
001B5E  784200     MOV.B W0, W4
381:                     if(tmp & Sn_IR_SENDOK)
001B60  62027F     AND W4, #0x1F, W4
001B62  6202F0     AND W4, #0x10, W5
001B64  320005     BRA Z, 0x1B70
382:                     {
383:                        setSn_IR(sn, Sn_IR_SENDOK);
001B66  B3C102     MOV #0x10, W2
001B68  BE000A     MOV.D W10, W0
001B6A  070116     RCALL WIZCHIP_WRITE
384:                        break;
385:                     }
386:                     //M:20131104
387:                     //else if(tmp & Sn_IR_TIMEOUT) return SOCKERR_TIMEOUT;
388:                     else if(tmp & Sn_IR_TIMEOUT)
001B70  620268     AND W4, #0x8, W4
001B72  32FFF3     BRA Z, 0x1B5A
389:                     {
390:                        setSn_IR(sn, Sn_IR_TIMEOUT);
001B74  B3C082     MOV #0x8, W2
001B76  BE000A     MOV.D W10, W0
001B78  07010F     RCALL WIZCHIP_WRITE
391:                        return SOCKERR_TIMEOUT;
001B7A  2FFF30     MOV #0xFFF3, W0
001B7C  2FFFF1     MOV #0xFFFF, W1
001B7E  370002     BRA 0x1B84
392:                     }
393:                     ////////////
394:                  }
395:               	return len;
001B6C  B86061     MUL.UU W12, #1, W0
001B6E  37000A     BRA 0x1B84
396:               }
001B84  78074F     MOV [--W15], W14
001B86  BE064F     MOV.D [--W15], W12
001B88  BE054F     MOV.D [--W15], W10
001B8A  BE044F     MOV.D [--W15], W8
001B8C  B1006F     SUB #0x6, W15
001B8E  060000     RETURN
397:               
398:               
399:               
400:               int32_t recvfrom(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t * addr, uint16_t *port)
401:               {
001B90  4787F4     ADD W15, #0x14, W15
001B92  BE9F88     MOV.D W8, [W15++]
001B94  BE9F8A     MOV.D W10, [W15++]
001B96  BE9F8C     MOV.D W12, [W15++]
001B98  781F8E     MOV W14, [W15++]
001B9A  784500     MOV.B W0, W10
001B9C  780701     MOV W1, W14
001B9E  780682     MOV W2, W13
001BA0  780583     MOV W3, W11
001BA2  780604     MOV W4, W12
402:                  uint8_t  mr;
403:                  uint8_t  head[8];
404:               	uint16_t pack_len=0;
001BE0  EB0280     CLR W5
001BE2  9FB7D5     MOV W5, [W15-22]
405:               
406:                  CHECK_SOCKNUM();
001BA4  EB8000     SETM W0
001BA6  EB8080     SETM W1
001BA8  554FE8     SUB.B W10, #0x8, [W15]
001BAA  3E00DA     BRA GTU, 0x1D60
407:                  //CHECK_SOCKMODE(Sn_MR_UDP);
408:                  switch((mr=getSn_MR(sn)) & 0x0F)
001BAC  FB820A     ZE W10, W4
001BAE  9FBF84     MOV W4, [W15-16]
001BB0  780284     MOV W4, W5
001BB2  DD2A45     SL W5, #5, W4
001BB4  420268     ADD W4, #0x8, W4
001BB6  9FB7F4     MOV W4, [W15-18]
001BB8  B92061     MUL.SU W4, #1, W0
001BBA  0700D8     RCALL WIZCHIP_READ
001BBC  FB8000     ZE W0, W0
001BBE  9FB7E0     MOV W0, [W15-20]
001BC0  780300     MOV W0, W6
001BC2  63026F     AND W6, #0xF, W4
001BC4  520FE2     SUB W4, #0x2, [W15]
001BC6  320004     BRA Z, 0x1BD0
001BCC  520FE4     SUB W4, #0x4, [W15]
001BCE  3A00C8     BRA NZ, 0x1D60
409:                  {
410:                     case Sn_MR_UDP:
411:                     case Sn_MR_MACRAW:
412:                        break;
413:                  #if ( _WIZCHIP_ < 5200 )         
414:                     case Sn_MR_IPRAW:
415:                     case Sn_MR_PPPoE:
416:                        break;
417:                  #endif
418:                     default:
419:                        return SOCKERR_SOCKMODE;
001BC8  2FFFB0     MOV #0xFFFB, W0
001BCA  2FFFF1     MOV #0xFFFF, W1
420:                  }
421:                  CHECK_SOCKDATA();
001BD0  2FFF20     MOV #0xFFF2, W0
001BD2  2FFFF1     MOV #0xFFFF, W1
001BD4  568FE0     SUB W13, #0x0, [W15]
001BD6  3200C4     BRA Z, 0x1D60
422:                  if(sock_remained_size[sn] == 0)
001BD8  97BB8F     MOV [W15-16], W7
001BDA  438207     ADD W7, W7, W4
001BDC  20B045     MOV #0xB04, W5
001BDE  7A0265     MOV [W5+W4], W4
001BE4  520F85     SUB W4, W5, [W15]
001BE6  3A0019     BRA NZ, 0x1C1A
423:                  {
424:                     while(1)
425:                     {
426:                        pack_len = getSn_RX_RSR(sn);
001BF4  78400A     MOV.B W10, W0
001BF6  070150     RCALL getSn_RX_RSR
001BF8  9FB7D0     MOV W0, [W15-22]
427:                        if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
001BEE  97B47F     MOV [W15-18], W8
001BF0  B03008     ADD #0x300, W8
001BF2  DEC4CF     ASR W8, #15, W9
001BFA  BE0008     MOV.D W8, W0
001BFC  0700B7     RCALL WIZCHIP_READ
001BFE  504FE0     SUB.B W0, #0x0, [W15]
001C00  3200AD     BRA Z, 0x1D5C
001D5C  2FFFC0     MOV #0xFFFC, W0
001D5E  2FFFF1     MOV #0xFFFF, W1
428:                        if( (sock_io_mode & (1<<sn)) && (pack_len == 0) ) return SOCK_BUSY;
001BE8  200014     MOV #0x1, W4
001BEA  DD2207     SL W4, W7, W4
001BEC  9FB7C4     MOV W4, [W15-24]
001C02  97B34F     MOV [W15-24], W6
001C04  8058A7     MOV sock_io_mode, W7
001C06  638206     AND W7, W6, W4
001C08  320005     BRA Z, 0x1C14
001C0A  B80060     MUL.UU W0, #0, W0
001C0C  97B25F     MOV [W15-22], W4
001C0E  520FE0     SUB W4, #0x0, [W15]
001C10  3A0004     BRA NZ, 0x1C1A
001C12  3700A6     BRA 0x1D60
429:                        if(pack_len != 0) break;
001C14  97B2DF     MOV [W15-22], W5
001C16  528FE0     SUB W5, #0x0, [W15]
001C18  32FFED     BRA Z, 0x1BF4
430:                     };
431:                  }
432:                  sock_pack_info[sn] = PACK_COMPLETED;
001C1A  EB4280     CLR.B W5
001C1C  20B164     MOV #0xB16, W4
001C1E  97BB0F     MOV [W15-16], W6
001C20  7B7205     MOV.B W5, [W4+W6]
433:               	switch (mr & 0x07)
001C22  97B3EF     MOV [W15-20], W7
001C24  638267     AND W7, #0x7, W4
001C26  520FE2     SUB W4, #0x2, [W15]
001C28  320003     BRA Z, 0x1C30
001C2A  520FE4     SUB W4, #0x4, [W15]
001C2C  3A0075     BRA NZ, 0x1D18
001C2E  37003C     BRA 0x1CA8
434:               	{
435:               	   case Sn_MR_UDP :
436:               	      if(sock_remained_size[sn] == 0)
001C30  97BA8F     MOV [W15-16], W5
001C32  428205     ADD W5, W5, W4
001C34  20B045     MOV #0xB04, W5
001C36  7A0265     MOV [W5+W4], W4
001C38  520FE0     SUB W4, #0x0, [W15]
001C3A  3A0029     BRA NZ, 0x1C8E
437:               	      {
438:                  			wiz_recv_data(sn, head, 8);
001C3C  200082     MOV #0x8, W2
001C3E  2FFE01     MOV #0xFFE0, W1
001C40  40808F     ADD W1, W15, W1
001C42  78400A     MOV.B W10, W0
001C44  070182     RCALL wiz_recv_data
439:                  			setSn_CR(sn,Sn_CR_RECV);
001C46  97B47F     MOV [W15-18], W8
001C48  B01008     ADD #0x100, W8
001C4A  DEC4CF     ASR W8, #15, W9
001C4C  B3C402     MOV #0x40, W2
001C4E  BE0008     MOV.D W8, W0
001C50  0700A3     RCALL WIZCHIP_WRITE
440:                  			while(getSn_CR(sn));
001C52  BE0008     MOV.D W8, W0
001C54  07008B     RCALL WIZCHIP_READ
001C56  504FE0     SUB.B W0, #0x0, [W15]
001C58  3AFFFC     BRA NZ, 0x1C52
441:                  			// read peer's IP address, port number & packet length
442:                   			addr[0] = head[0];
001C5A  97E30F     MOV.B [W15-32], W6
001C5C  784D86     MOV.B W6, [W11]
443:                  			addr[1] = head[1];
001C5E  97E39F     MOV.B [W15-31], W7
001C60  984597     MOV.B W7, [W11+1]
444:                  			addr[2] = head[2];
001C62  97E22F     MOV.B [W15-30], W4
001C64  9845A4     MOV.B W4, [W11+2]
445:                  			addr[3] = head[3];
001C66  97E2BF     MOV.B [W15-29], W5
001C68  9845B5     MOV.B W5, [W11+3]
446:                  			*port = head[4];
447:                  			*port = (*port << 8) + head[5];
001C6A  97E2CF     MOV.B [W15-28], W5
001C6C  DD2AC8     SL W5, #8, W5
001C6E  97E25F     MOV.B [W15-27], W4
001C70  FB8204     ZE W4, W4
001C72  428E04     ADD W5, W4, [W12]
448:                  			sock_remained_size[sn] = head[6];
449:                  			sock_remained_size[sn] = (sock_remained_size[sn] << 8) + head[7];
001C74  97BB0F     MOV [W15-16], W6
001C76  430206     ADD W6, W6, W4
001C78  20B045     MOV #0xB04, W5
001C7A  428204     ADD W5, W4, W4
001C7C  97E36F     MOV.B [W15-26], W6
001C7E  DD3348     SL W6, #8, W6
001C80  97E2FF     MOV.B [W15-25], W5
001C82  FB8285     ZE W5, W5
001C84  430A05     ADD W6, W5, [W4]
450:                  			sock_pack_info[sn] = PACK_FIRST;
001C86  B3C805     MOV #0x80, W5
001C88  20B164     MOV #0xB16, W4
001C8A  97BB8F     MOV [W15-16], W7
001C8C  7BF205     MOV.B W5, [W4+W7]
001C94  7A02E5     MOV [W5+W4], W5
001C96  9FB7D5     MOV W5, [W15-22]
001C98  528F8D     SUB W5, W13, [W15]
001C9A  360001     BRA LEU, 0x1C9E
001C9C  9FB7DD     MOV W13, [W15-22]
451:                  	   }
452:               			if(len < sock_remained_size[sn]) pack_len = len;
001C8E  97BA8F     MOV [W15-16], W5
001C90  428205     ADD W5, W5, W4
001C92  20B045     MOV #0xB04, W5
453:               			else pack_len = sock_remained_size[sn];
454:               			//
455:               			// Need to packet length check (default 1472)
456:               			//
457:                  		wiz_recv_data(sn, buf, pack_len); // data copy.
001C9E  97B15F     MOV [W15-22], W2
001CA0  78008E     MOV W14, W1
001CA2  78400A     MOV.B W10, W0
001CA4  070152     RCALL wiz_recv_data
458:               			break;
001CA6  370040     BRA 0x1D28
459:               	   case Sn_MR_MACRAW :
460:               	      if(sock_remained_size[sn] == 0)
001CA8  97BB0F     MOV [W15-16], W6
001CAA  430206     ADD W6, W6, W4
001CAC  20B045     MOV #0xB04, W5
001CAE  7A0265     MOV [W5+W4], W4
001CB0  520FE0     SUB W4, #0x0, [W15]
001CB2  3A0025     BRA NZ, 0x1CFE
461:               	      {
462:                  			wiz_recv_data(sn, head, 2);
001CB4  200022     MOV #0x2, W2
001CB6  2FFE01     MOV #0xFFE0, W1
001CB8  40808F     ADD W1, W15, W1
001CBA  78400A     MOV.B W10, W0
001CBC  070146     RCALL wiz_recv_data
463:                  			setSn_CR(sn,Sn_CR_RECV);
001CBE  97B47F     MOV [W15-18], W8
001CC0  B01008     ADD #0x100, W8
001CC2  DEC4CF     ASR W8, #15, W9
001CC4  B3C402     MOV #0x40, W2
001CC6  BE0008     MOV.D W8, W0
001CC8  070067     RCALL WIZCHIP_WRITE
464:                  			while(getSn_CR(sn));
001CCA  BE0008     MOV.D W8, W0
001CCC  07004F     RCALL WIZCHIP_READ
001CCE  504FE0     SUB.B W0, #0x0, [W15]
001CD0  3AFFFC     BRA NZ, 0x1CCA
465:                  			// read peer's IP address, port number & packet length
466:                   			sock_remained_size[sn] = head[0];
001CD2  97E38F     MOV.B [W15-32], W7
001CD4  FB8287     ZE W7, W5
467:                  			sock_remained_size[sn] = (sock_remained_size[sn] <<8) + head[1];
001CD6  DD2AC8     SL W5, #8, W5
001CD8  97E21F     MOV.B [W15-31], W4
001CDA  FB8204     ZE W4, W4
001CDC  428204     ADD W5, W4, W4
001CDE  97BB0F     MOV [W15-16], W6
001CE0  430286     ADD W6, W6, W5
001CE2  20B046     MOV #0xB04, W6
001CE4  7AB304     MOV W4, [W6+W5]
468:                  			if(sock_remained_size[sn] > 1514) 
001CE6  205EA5     MOV #0x5EA, W5
001CE8  520F85     SUB W4, W5, [W15]
001CEA  360005     BRA LEU, 0x1CF6
469:                  			{
470:                  			   close(sn);
001CEC  78400A     MOV.B W10, W0
001CEE  07FE1D     RCALL close
471:                  			   return SOCKFATAL_PACKLEN;
001CF0  2FC170     MOV #0xFC17, W0
001CF2  2FFFF1     MOV #0xFFFF, W1
001CF4  370035     BRA 0x1D60
472:                  			}
473:                  			sock_pack_info[sn] = PACK_FIRST;
001CF6  B3C805     MOV #0x80, W5
001CF8  20B164     MOV #0xB16, W4
001CFA  97BB8F     MOV [W15-16], W7
001CFC  7BF205     MOV.B W5, [W4+W7]
001D04  7A02E5     MOV [W5+W4], W5
001D06  9FB7D5     MOV W5, [W15-22]
001D08  528F8D     SUB W5, W13, [W15]
001D0A  360001     BRA LEU, 0x1D0E
001D0C  9FB7DD     MOV W13, [W15-22]
474:                  	   }
475:               			if(len < sock_remained_size[sn]) pack_len = len;
001CFE  97BA8F     MOV [W15-16], W5
001D00  428205     ADD W5, W5, W4
001D02  20B045     MOV #0xB04, W5
476:               			else pack_len = sock_remained_size[sn];
477:               			wiz_recv_data(sn,buf,pack_len);
001D0E  97B15F     MOV [W15-22], W2
001D10  78008E     MOV W14, W1
001D12  78400A     MOV.B W10, W0
001D14  07011A     RCALL wiz_recv_data
478:               		   break;
001D16  370008     BRA 0x1D28
479:                  #if ( _WIZCHIP_ < 5200 )
480:               		case Sn_MR_IPRAW:
481:               		   if(sock_remained_size[sn] == 0)
482:               		   {
483:                  			wiz_recv_data(sn, head, 6);
484:                  			setSn_CR(sn,Sn_CR_RECV);
485:                  			while(getSn_CR(sn));
486:                  			addr[0] = head[0];
487:                  			addr[1] = head[1];
488:                  			addr[2] = head[2];
489:                  			addr[3] = head[3];
490:                  			sock_remained_size[sn] = head[4];
491:                  			sock_remaiend_size[sn] = (sock_remained_size[sn] << 8) + head[5];
492:                  			sock_pack_info[sn] = PACK_FIRST;
493:                        }
494:               			//
495:               			// Need to packet length check
496:               			//
497:               			if(len < sock_remained_size[sn]) pack_len = len;
498:               			else pack_len = sock_remained_size[sn];
499:                  		wiz_recv_data(sn, buf, pack_len); // data copy.
500:               			break;
501:                  #endif
502:                     default:
503:                        wiz_recv_ignore(sn, pack_len); // data copy.
001D18  97B0DF     MOV [W15-22], W1
001D1A  78400A     MOV.B W10, W0
001D1C  07014A     RCALL wiz_recv_ignore
504:                        sock_remained_size[sn] = pack_len;
001D1E  97BB0F     MOV [W15-16], W6
001D20  430206     ADD W6, W6, W4
001D22  20B045     MOV #0xB04, W5
001D24  97B3DF     MOV [W15-22], W7
001D26  7A3287     MOV W7, [W5+W4]
505:                        break;
506:                  }
507:               	setSn_CR(sn,Sn_CR_RECV);
001D28  97B47F     MOV [W15-18], W8
001D2A  B01008     ADD #0x100, W8
001D2C  DEC4CF     ASR W8, #15, W9
001D2E  B3C402     MOV #0x40, W2
001D30  BE0008     MOV.D W8, W0
001D32  070032     RCALL WIZCHIP_WRITE
508:               	/* wait to process the command... */
509:               	while(getSn_CR(sn)) ;
001D34  BE0008     MOV.D W8, W0
001D36  07001A     RCALL WIZCHIP_READ
001D38  504FE0     SUB.B W0, #0x0, [W15]
001D3A  3AFFFC     BRA NZ, 0x1D34
510:               	sock_remained_size[sn] -= pack_len;
001D3C  97BA0F     MOV [W15-16], W4
001D3E  420284     ADD W4, W4, W5
001D40  20B046     MOV #0xB04, W6
001D42  7A8266     MOV [W6+W5], W4
001D44  97B3DF     MOV [W15-22], W7
001D46  520207     SUB W4, W7, W4
001D48  7AB304     MOV W4, [W6+W5]
511:               	if(sock_remained_size[sn] != 0) sock_pack_info[sn] |= 0x01;
001D4A  320005     BRA Z, 0x1D56
001D4C  20B164     MOV #0xB16, W4
001D4E  97BB0F     MOV [W15-16], W6
001D50  7B42E4     MOV.B [W4+W6], W5
001D52  A00405     BSET.B W5, #0
001D54  7B7205     MOV.B W5, [W4+W6]
512:                	return pack_len;
001D56  97B3DF     MOV [W15-22], W7
001D58  B83861     MUL.UU W7, #1, W0
001D5A  370002     BRA 0x1D60
513:               }
001D60  78074F     MOV [--W15], W14
001D62  BE064F     MOV.D [--W15], W12
001D64  BE054F     MOV.D [--W15], W10
001D66  BE044F     MOV.D [--W15], W8
001D68  B1014F     SUB #0x14, W15
001D6A  060000     RETURN
514:               
515:               /*
516:               int8_t  ctlsocket(uint8_t sn, ctlsock_type cstype, void* arg)
517:               {
518:                  uint8_t tmp = 0;
519:                  CHECK_SOCKNUM();
520:                  switch(cstype)
521:                  {
522:                     case CS_SET_IOMODE:
523:                        tmp = *((uint8_t*)arg);
524:                        if(tmp == SOCK_IO_NONBLOCK)  sock_io_mode |= (1<<sn);
525:                        else if(tmp == SOCK_IO_BLOCK) sock_io_mode &= ~(1<<sn);
526:                        else return SOCKERR_ARG;
527:                        break;
528:                     case CS_GET_IOMODE:   
529:                        *((uint8_t*)arg) = (sock_io_mode >> sn) & 0x0001;
530:                        break;
531:                     case CS_GET_MAXTXBUF:
532:                        *((uint16_t*)arg) = getSn_TxMAX(sn);
533:                        break;
534:                     case CS_GET_MAXRXBUF:    
535:                        *((uint16_t*)arg) = getSn_RxMAX(sn);
536:                        break;
537:                     case CS_CLR_INTERRUPT:
538:                        if( (*(uint8_t*)arg) > SIK_ALL) return SOCKERR_ARG;
539:                        setSn_IR(sn,*(uint8_t*)arg);
540:                        break;
541:                     case CS_GET_INTERRUPT:
542:                        *((uint8_t*)arg) = getSn_IR(sn);
543:                        break;
544:                     case CS_SET_INTMASK:  
545:                        if( (*(uint8_t*)arg) > SIK_ALL) return SOCKERR_ARG;
546:                        setSn_IMR(sn,*(uint8_t*)arg);
547:                        break;
548:                     case CS_GET_INTMASK:   
549:                        *((uint8_t*)arg) = getSn_IMR(sn);
550:                     default:
551:                        return SOCKERR_ARG;
552:                  }
553:                  return SOCK_OK;
554:               }
555:               
556:               int8_t  setsockopt(uint8_t sn, sockopt_type sotype, void* arg)
557:               {
558:                // M20131220 : Remove warning
559:                //uint8_t tmp;
560:                  CHECK_SOCKNUM();
561:                  switch(sotype)
562:                  {
563:                     case SO_TTL:
564:                        setSn_TTL(sn,*(uint8_t*)arg);
565:                        break;
566:                     case SO_TOS:
567:                        setSn_TOS(sn,*(uint8_t*)arg);
568:                        break;
569:                     case SO_MSS:
570:                        setSn_MSSR(sn,*(uint16_t*)arg);
571:                        break;
572:                     case SO_DESTIP:
573:                        setSn_DIPR(sn, (uint8_t*)arg);
574:                        break;
575:                     case SO_DESTPORT:
576:                        setSn_DPORT(sn, *(uint16_t*)arg);
577:                        break;
578:               #if _WIZCHIP_ != 5100
579:                     case SO_KEEPALIVESEND:
580:                        CHECK_SOCKMODE(Sn_MR_TCP);
581:                        #if _WIZCHIP_ > 5200
582:                           if(getSn_KPALVTR(sn) != 0) return SOCKERR_SOCKOPT;
583:                        #endif
584:                           setSn_CR(sn,Sn_CR_SEND_KEEP);
585:                           while(getSn_CR(sn) != 0)
586:                           {
587:                              // M20131220
588:                        		//if ((tmp = getSn_IR(sn)) & Sn_IR_TIMEOUT)
589:                              if (getSn_IR(sn) & Sn_IR_TIMEOUT)
590:                        		{
591:                        			setSn_IR(sn, Sn_IR_TIMEOUT);
592:                                 return SOCKERR_TIMEOUT;
593:                        		}
594:                           }
595:                        break;
596:                  #if _WIZCHIP_ > 5200
597:                     case SO_KEEPALIVEAUTO:
598:                        CHECK_SOCKMODE(Sn_MR_TCP);
599:                        setSn_KPALVTR(sn,*(uint8_t*)arg);
600:                        break;
601:                  #endif      
602:               #endif   
603:                     default:
604:                        return SOCKERR_ARG;
605:                  }   
606:                  return SOCK_OK;
607:               }
608:               
609:               int8_t  getsockopt(uint8_t sn, sockopt_type sotype, void* arg)
610:               {
611:                  CHECK_SOCKNUM();
612:                  switch(sotype)
613:                  {
614:                     case SO_FLAG:
615:                        *(uint8_t*)arg = getSn_MR(sn) & 0xF0;
616:                        break;
617:                     case SO_TTL:
618:                        *(uint8_t*) arg = getSn_TTL(sn);
619:                        break;
620:                     case SO_TOS:
621:                        *(uint8_t*) arg = getSn_TOS(sn);
622:                        break;
623:                     case SO_MSS:   
624:                        *(uint8_t*) arg = getSn_MSSR(sn);
625:                     case SO_DESTIP:
626:                        getSn_DIPR(sn, (uint8_t*)arg);
627:                        break;
628:                     case SO_DESTPORT:  
629:                        *(uint16_t*) arg = getSn_DPORT(sn);
630:                        break;
631:                  #if _WIZCHIP_ > 5200   
632:                     case SO_KEEPALIVEAUTO:
633:                        CHECK_SOCKMODE(Sn_MR_TCP);
634:                        *(uint16_t*) arg = getSn_KPALVTR(sn);
635:                        break;
636:                  #endif      
637:                     case SO_SENDBUF:
638:                        *(uint16_t*) arg = getSn_TX_FSR(sn);
639:                     case SO_RECVBUF:
640:                        *(uint16_t*) arg = getSn_RX_RSR(sn);
641:                     case SO_STATUS:
642:                        *(uint8_t*) arg = getSn_SR(sn);
643:                        break;
644:                     case SO_REMAINSIZE:
645:                        if(getSn_MR(sn) == Sn_MR_TCP)
646:                           *(uint16_t*)arg = getSn_RX_RSR(sn);
647:                        else
648:                           *(uint16_t*)arg = sock_remained_size[sn];
649:                        break;
650:                     case SO_PACKINFO:
651:                        CHECK_SOCKMODE(Sn_MR_TCP);
652:                        *(uint8_t*)arg = sock_pack_info[sn];
653:                        break;
654:                     default:
655:                        return SOCKERR_SOCKOPT;
656:                  }
657:                  return SOCK_OK;
658:               }
659:                
660:                */
661:                
---  F:/microchip/mla/v2013_12_20/apps/usb/device/msd_internal_flash/firmware/src/Ethernet/W5500/w5500.c  
1:                 //*****************************************************************************
2:                 //
3:                 //! \file w5500.c
4:                 //! \brief W5500 HAL Interface.
5:                 //! \version 1.0.1
6:                 //! \date 2013/10/21
7:                 //! \par  Revision history
8:                 //!       <2013/10/21> 1st Release
9:                 //!       <2013/12/20> V1.0.1
10:                //!         1. Remove warning
11:                //!         2. WIZCHIP_READ_BUF WIZCHIP_WRITE_BUF in case _WIZCHIP_IO_MODE_SPI_FDM_
12:                //!            for loop optimized(removed). refer to M20131220
13:                //! \author MidnightCow
14:                //! \copyright
15:                //!
16:                //! Copyright (c)  2013, WIZnet Co., LTD.
17:                //! All rights reserved.
18:                //! 
19:                //! Redistribution and use in source and binary forms, with or without 
20:                //! modification, are permitted provided that the following conditions 
21:                //! are met: 
22:                //! 
23:                //!     * Redistributions of source code must retain the above copyright 
24:                //! notice, this list of conditions and the following disclaimer. 
25:                //!     * Redistributions in binary form must reproduce the above copyright
26:                //! notice, this list of conditions and the following disclaimer in the
27:                //! documentation and/or other materials provided with the distribution. 
28:                //!     * Neither the name of the <ORGANIZATION> nor the names of its 
29:                //! contributors may be used to endorse or promote products derived 
30:                //! from this software without specific prior written permission. 
31:                //! 
32:                //! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
33:                //! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
34:                //! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
35:                //! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
36:                //! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
37:                //! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
38:                //! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
39:                //! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
40:                //! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
41:                //! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
42:                //! THE POSSIBILITY OF SUCH DAMAGE.
43:                //
44:                //*****************************************************************************
45:                //#include <stdio.h>
46:                #include "w5500.h"
47:                
48:                
49:                #define _W5500_SPI_VDM_OP_          0x00
50:                #define _W5500_SPI_FDM_OP_LEN1_     0x01
51:                #define _W5500_SPI_FDM_OP_LEN2_     0x02
52:                #define _W5500_SPI_FDM_OP_LEN4_     0x03
53:                
54:                ////////////////////////////////////////////////////
55:                
56:                uint8_t  WIZCHIP_READ(uint32_t AddrSel)
57:                {
001D6C  BE9F88     MOV.D W8, [W15++]
001D6E  781F8A     MOV W10, [W15++]
001D70  BE0400     MOV.D W0, W8
58:                   uint8_t ret;
59:                
60:                   WIZCHIP_CRITICAL_ENTER();
61:                   WIZCHIP_CS_select();
001D72  A902CC     BCLR LATB, #0
62:                
63:                #if( (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_))
64:                
65:                   #if  ( _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_VDM_ )
66:                   	   AddrSel |= (_W5500_SPI_READ_ | _W5500_SPI_VDM_OP_);
67:                   #elif( _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_FDM_ )
68:                   	   AddrSel |= (_W5500_SPI_READ_ | _W5500_SPI_FDM_OP_LEN1_);
69:                   #else
70:                      #error "Unsupported _WIZCHIP_IO_SPI_ in W5500 !!!"
71:                   #endif
72:                
73:                   WIZCHIP_SPI_write_byte((AddrSel & 0x00FF0000) >> 16);
001D74  FB8009     ZE W9, W0
001D76  200001     MOV #0x0, W1
001D78  070333     RCALL WIZCHIP_SPI_write_byte
74:                   WIZCHIP_SPI_write_byte((AddrSel & 0x0000FF00) >>  8);
001D7A  2FF000     MOV #0xFF00, W0
001D7C  640000     AND W8, W0, W0
001D7E  200001     MOV #0x0, W1
001D80  DD0A48     SL W1, #8, W4
001D82  DE0048     LSR W0, #8, W0
001D84  720000     IOR W4, W0, W0
001D86  DE08C8     LSR W1, #8, W1
001D88  07032B     RCALL WIZCHIP_SPI_write_byte
75:                   WIZCHIP_SPI_write_byte((AddrSel & 0x000000FF) >>  0);
001D8A  784008     MOV.B W8, W0
001D8C  070329     RCALL WIZCHIP_SPI_write_byte
76:                   ret = WIZCHIP_SPI_read_byte();
001D8E  070330     RCALL WIZCHIP_SPI_read_byte
77:                
78:                #elif ( (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS_) )
79:                
80:                   #if  (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_DIR_)
81:                
82:                   #elif(_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_)
83:                
84:                   #else
85:                      #error "Unsupported _WIZCHIP_IO_MODE_BUS_ in W5500 !!!"
86:                   #endif
87:                #else
88:                   #error "Unknown _WIZCHIP_IO_MODE_ in W5000. !!!"   
89:                #endif
90:                
91:                   WIZCHIP_CS_deselect();
001D90  A802CC     BSET LATB, #0
92:                   WIZCHIP_CRITICAL_EXIT();
93:                   return ret;
94:                }
001D92  78054F     MOV [--W15], W10
001D94  BE044F     MOV.D [--W15], W8
001D96  060000     RETURN
95:                
96:                void     WIZCHIP_WRITE(uint32_t AddrSel, uint8_t wb )
97:                {
001D98  BE9F88     MOV.D W8, [W15++]
001D9A  BE9F8A     MOV.D W10, [W15++]
001D9C  784502     MOV.B W2, W10
98:                    WIZCHIP_CRITICAL_ENTER();
99:                    WIZCHIP_CS_select();
001D9E  A902CC     BCLR LATB, #0
100:               
101:               #if( (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_))
102:               
103:                  #if  ( _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_VDM_ )
104:                  	   AddrSel |= (_W5500_SPI_WRITE_ | _W5500_SPI_VDM_OP_);
001DA0  BE0400     MOV.D W0, W8
001DA2  A02008     BSET W8, #2
105:                  #elif( _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_FDM_ )
106:                  	   AddrSel |= (_W5500_SPI_WRITE_ | _W5500_SPI_FDM_OP_LEN1_);
107:                  #else
108:                     #error "Unsupported _WIZCHIP_IO_SPI_ in W5500 !!!"
109:                  #endif
110:               
111:                  WIZCHIP_SPI_write_byte((AddrSel & 0x00FF0000) >> 16);
001DA4  FB8009     ZE W9, W0
001DA6  200001     MOV #0x0, W1
001DA8  07031B     RCALL WIZCHIP_SPI_write_byte
112:                  WIZCHIP_SPI_write_byte((AddrSel & 0x0000FF00) >>  8);
001DAA  2FF000     MOV #0xFF00, W0
001DAC  640000     AND W8, W0, W0
001DAE  200001     MOV #0x0, W1
001DB0  DD0A48     SL W1, #8, W4
001DB2  DE0048     LSR W0, #8, W0
001DB4  720000     IOR W4, W0, W0
001DB6  DE08C8     LSR W1, #8, W1
001DB8  070313     RCALL WIZCHIP_SPI_write_byte
113:                  WIZCHIP_SPI_write_byte((AddrSel & 0x000000FF) >>  0);
001DBA  784008     MOV.B W8, W0
001DBC  070311     RCALL WIZCHIP_SPI_write_byte
114:                  WIZCHIP_SPI_write_byte(wb);
001DBE  78400A     MOV.B W10, W0
001DC0  07030F     RCALL WIZCHIP_SPI_write_byte
115:               
116:               #elif ( (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS_) )
117:               
118:                  #if  (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_DIR_)
119:               
120:                  #elif(_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_)
121:               
122:                  #else
123:                     #error "Unsupported _WIZCHIP_IO_MODE_BUS_ in W5500 !!!"
124:                  #endif
125:               #else
126:                  #error "Unknown _WIZCHIP_IO_MODE_ in W5500. !!!"
127:               #endif
128:               
129:                  WIZCHIP_CS_deselect();
001DC2  A802CC     BSET LATB, #0
130:                  WIZCHIP_CRITICAL_EXIT();
131:               }
001DC4  BE054F     MOV.D [--W15], W10
001DC6  BE044F     MOV.D [--W15], W8
001DC8  060000     RETURN
132:                        
133:               void     WIZCHIP_READ_BUF (uint32_t AddrSel, uint8_t* pBuf, uint16_t len)
134:               {
001DCA  BE9F88     MOV.D W8, [W15++]
001DCC  BE9F8A     MOV.D W10, [W15++]
001DCE  781F8C     MOV W12, [W15++]
001DD0  BE0400     MOV.D W0, W8
001DD2  780582     MOV W2, W11
001DD4  780503     MOV W3, W10
135:                  uint16_t i = 0;
136:                  uint16_t j = 0;
137:                  WIZCHIP_CRITICAL_ENTER();
138:                  WIZCHIP_CS_select();
001DD6  A902CC     BCLR LATB, #0
139:               
140:               #if( (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_))
141:               
142:                  #if  ( _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_VDM_ )
143:                     AddrSel |= (_W5500_SPI_READ_ | _W5500_SPI_VDM_OP_);
144:                     WIZCHIP_SPI_write_byte((AddrSel & 0x00FF0000) >> 16);
001DD8  FB8009     ZE W9, W0
001DDA  200001     MOV #0x0, W1
001DDC  070301     RCALL WIZCHIP_SPI_write_byte
145:                     WIZCHIP_SPI_write_byte((AddrSel & 0x0000FF00) >>  8);
001DDE  2FF000     MOV #0xFF00, W0
001DE0  640000     AND W8, W0, W0
001DE2  200001     MOV #0x0, W1
001DE4  DD0A48     SL W1, #8, W4
001DE6  DE0048     LSR W0, #8, W0
001DE8  720000     IOR W4, W0, W0
001DEA  DE08C8     LSR W1, #8, W1
001DEC  0702F9     RCALL WIZCHIP_SPI_write_byte
146:                     WIZCHIP_SPI_write_byte((AddrSel & 0x000000FF) >>  0);
001DEE  784008     MOV.B W8, W0
001DF0  0702F7     RCALL WIZCHIP_SPI_write_byte
147:                     for(i = 0; i < len; i++,j)
001DF2  550FE0     SUB W10, #0x0, [W15]
001DF4  320006     BRA Z, 0x1E02
001DF6  EB0400     CLR W8
001DFC  E80408     INC W8, W8
001DFE  550F88     SUB W10, W8, [W15]
001E00  3EFFFB     BRA GTU, 0x1DF8
148:                       pBuf[i] = WIZCHIP_SPI_read_byte();
001DF8  0702FB     RCALL WIZCHIP_SPI_read_byte
001DFA  7C7580     MOV.B W0, [W11+W8]
149:                  #elif( _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_FDM_ )
150:                     AddrSel |= (_W5500_SPI_READ_ | _W5500_SPI_FDM_OP_LEN4_);
151:                     for(i = 0; i < len/4; i++, j)
152:                     {
153:                        WIZCHIP_SPI_write_byte((AddrSel & 0x00FF0000) >> 16);
154:                        WIZCHIP_SPI_write_byte((AddrSel & 0x0000FF00) >>  8);
155:                        WIZCHIP_SPI_write_byte((AddrSel & 0x000000FF) >>  0);
156:                        pBuf[i*4]   = WIZCHIP_SPI_read_byte();
157:                        pBuf[i*4+1] = WIZCHIP_SPI_read_byte();
158:                        pBuf[i*4+2] = WIZCHIP_SPI_read_byte();
159:                        pBuf[i*4+3] = WIZCHIP_SPI_read_byte();
160:                        AddrSel = WIZCHIP_OFFSET_INC(AddrSel,4);
161:                     }
162:                     len %= 4;      // for the rest data
163:                     // M20131220 : remove for loop
164:                     i *= 4;        
165:                     if(len >= 2)
166:                     {
167:                        AddrSel -= 1;  // change _W5500_SPI_FDM_OP_LEN4_ to _W5500_SPI_FDM_OP_LEN2_
168:               
169:                      //for(j = 0; j < len/2 ; j++)
170:                        {
171:                           WIZCHIP_SPI_write_byte((AddrSel & 0x00FF0000) >> 16);
172:                           WIZCHIP_SPI_write_byte((AddrSel & 0x0000FF00) >>  8);
173:                           WIZCHIP_SPI_write_byte((AddrSel & 0x000000FF) >>  0);
174:                           pBuf[i]   = WIZCHIP_SPI_read_byte();
175:                           pBuf[i+1] = WIZCHIP_SPI_read_byte();
176:                           i += 2;
177:                           AddrSel = WIZCHIP_OFFSET_INC(AddrSel,2);
178:                        }
179:                     }
180:                     len %= 2;
181:                     if(len)
182:                     {
183:                       AddrSel -= 1;  // change _W5500_SPI_FDM_OP_LEN2_ to _W5500_SPI_FDM_OP_LEN1_
184:                       WIZCHIP_SPI_write_byte((AddrSel & 0x00FF0000) >> 16);
185:                       WIZCHIP_SPI_write_byte((AddrSel & 0x0000FF00) >>  8);
186:                       WIZCHIP_SPI_write_byte((AddrSel & 0x000000FF) >>  0);
187:                       pBuf[i]   = WIZCHIP_SPI_read_byte();
188:                     }      
189:                  #else
190:                     #error "Unsupported _WIZCHIP_IO_MODE_SPI_ in W5500 !!!"
191:                  #endif
192:               
193:               #elif ( (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS_) )
194:               
195:                  #if  (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_DIR_)
196:               
197:                  #elif(_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_)
198:               
199:                  #else
200:                     #error "Unsupported _WIZCHIP_IO_MODE_BUS_ in W5500 !!!"
201:                  #endif
202:               #else
203:                  #error "Unknown _WIZCHIP_IO_MODE_ in W5500. !!!!"
204:               #endif
205:               
206:                  WIZCHIP_CS_deselect();
001E02  A802CC     BSET LATB, #0
207:                  WIZCHIP_CRITICAL_EXIT();
208:               }
001E04  78064F     MOV [--W15], W12
001E06  BE054F     MOV.D [--W15], W10
001E08  BE044F     MOV.D [--W15], W8
001E0A  060000     RETURN
209:               
210:               void     WIZCHIP_WRITE_BUF(uint32_t AddrSel, uint8_t* pBuf, uint16_t len)
211:               {
001E0C  BE9F88     MOV.D W8, [W15++]
001E0E  BE9F8A     MOV.D W10, [W15++]
001E10  781F8C     MOV W12, [W15++]
001E12  BE0502     MOV.D W2, W10
212:                  uint16_t i = 0;
213:                  uint16_t j = 0;
214:                  WIZCHIP_CRITICAL_ENTER();
215:                  WIZCHIP_CS_select();
001E14  A902CC     BCLR LATB, #0
216:               
217:               #if( (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_))
218:               
219:                  #if  ( _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_VDM_ )
220:                     AddrSel |= (_W5500_SPI_WRITE_ | _W5500_SPI_VDM_OP_);
001E16  BE0400     MOV.D W0, W8
001E18  A02008     BSET W8, #2
221:                     WIZCHIP_SPI_write_byte((AddrSel & 0x00FF0000) >> 16);
001E1A  FB8009     ZE W9, W0
001E1C  200001     MOV #0x0, W1
001E1E  0702E0     RCALL WIZCHIP_SPI_write_byte
222:                     WIZCHIP_SPI_write_byte((AddrSel & 0x0000FF00) >>  8);
001E20  2FF000     MOV #0xFF00, W0
001E22  640000     AND W8, W0, W0
001E24  200001     MOV #0x0, W1
001E26  DD0A48     SL W1, #8, W4
001E28  DE0048     LSR W0, #8, W0
001E2A  720000     IOR W4, W0, W0
001E2C  DE08C8     LSR W1, #8, W1
001E2E  0702D8     RCALL WIZCHIP_SPI_write_byte
223:                     WIZCHIP_SPI_write_byte((AddrSel & 0x000000FF) >>  0);
001E30  784008     MOV.B W8, W0
001E32  0702D6     RCALL WIZCHIP_SPI_write_byte
224:                     for(i = 0; i < len; i++,j)
001E34  558FE0     SUB W11, #0x0, [W15]
001E36  320006     BRA Z, 0x1E44
001E38  EB0400     CLR W8
001E3E  E80408     INC W8, W8
001E40  558F88     SUB W11, W8, [W15]
001E42  3EFFFB     BRA GTU, 0x1E3A
225:                        WIZCHIP_SPI_write_byte(pBuf[i]);
001E3A  7C406A     MOV.B [W10+W8], W0
001E3C  0702D1     RCALL WIZCHIP_SPI_write_byte
226:                  #elif( _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_FDM_ )
227:                     AddrSel |= (_W5500_SPI_WRITE_ | _W5500_SPI_FDM_OP_LEN4_);
228:                     for(i = 0; i < len/4; i++, j)
229:                     {
230:                        WIZCHIP_SPI_write_byte((AddrSel & 0x00FF0000) >> 16);
231:                        WIZCHIP_SPI_write_byte((AddrSel & 0x0000FF00) >>  8);
232:                        WIZCHIP_SPI_write_byte((AddrSel & 0x000000FF) >>  0);
233:                        WIZCHIP_SPI_write_byte(pBuf[i*4]  );
234:                        WIZCHIP_SPI_write_byte(pBuf[i*4+1]);
235:                        WIZCHIP_SPI_write_byte(pBuf[i*4+2]);
236:                        WIZCHIP_SPI_write_byte(pBuf[i*4+3]);
237:                        AddrSel = WIZCHIP_OFFSET_INC(AddrSel,4);
238:                     }
239:                     len %= 4;      // for the rest data
240:                     // M20131220 : Remove for loop
241:                     i *= 4;
242:                     if(len >= 2)
243:                     {
244:                        AddrSel -= 1;  // change _W5500_SPI_FDM_OP_LEN4_ to _W5500_SPI_FDM_OP_LEN2_
245:               
246:                      //for(j = 0; j < len/2 ; j++)
247:                        {
248:                           WIZCHIP_SPI_write_byte((AddrSel & 0x00FF0000) >> 16);
249:                           WIZCHIP_SPI_write_byte((AddrSel & 0x0000FF00) >>  8);
250:                           WIZCHIP_SPI_write_byte((AddrSel & 0x000000FF) >>  0);
251:                           WIZCHIP_SPI_write_byte(pBuf[i]  );
252:                           WIZCHIP_SPI_write_byte(pBuf[i+1]);
253:                           i += 2;
254:                           AddrSel = WIZCHIP_OFFSET_INC(AddrSel, 2);
255:                        }
256:                        len %= 2;
257:                        if(len)
258:                        {
259:                           AddrSel -= 1;  // change _W5500_SPI_FDM_OP_LEN2_ to _W5500_SPI_FDM_OP_LEN1_
260:                           WIZCHIP_SPI_write_byte((AddrSel & 0x00FF0000) >> 16);
261:                           WIZCHIP_SPI_write_byte((AddrSel & 0x0000FF00) >>  8);
262:                           WIZCHIP_SPI_write_byte((AddrSel & 0x000000FF) >>  0);
263:                           WIZCHIP_SPI_write_byte(pBuf[i]);
264:                        }      
265:                     }
266:                  #else
267:                     #error "Unsupported _WIZCHIP_IO_SPI_ in W5500 !!!"
268:                  #endif
269:               
270:               #elif ( (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS_) )
271:               
272:                  #if  (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_DIR_)
273:               
274:                  #elif(_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_)
275:               
276:                  #else
277:                     #error "Unsupported _WIZCHIP_IO_MODE_BUS_ in W5500 !!!"
278:                  #endif
279:               #else
280:                  #error "Unknown _WIZCHIP_IO_MODE_ in W5500. !!!!"
281:               #endif
282:               
283:                  WIZCHIP_CS_deselect();
001E44  A802CC     BSET LATB, #0
284:                  WIZCHIP_CRITICAL_EXIT();
285:               }
001E46  78064F     MOV [--W15], W12
001E48  BE054F     MOV.D [--W15], W10
001E4A  BE044F     MOV.D [--W15], W8
001E4C  060000     RETURN
286:               
287:               
288:               uint16_t getSn_TX_FSR(uint8_t sn)
289:               {
001E4E  BE9F88     MOV.D W8, [W15++]
001E50  BE9F8A     MOV.D W10, [W15++]
001E52  BE9F8C     MOV.D W12, [W15++]
001E54  781F8E     MOV W14, [W15++]
290:                  uint16_t val=0,val1=0;
001E68  EB0700     CLR W14
291:                  do
292:                  {
293:                     val1 = WIZCHIP_READ(Sn_TX_FSR(sn));
001E56  FB8200     ZE W0, W4
001E58  DD2245     SL W4, #5, W4
001E5A  420268     ADD W4, #0x8, W4
001E5C  220008     MOV #0x2000, W8
001E5E  420408     ADD W4, W8, W8
001E60  DEC4CF     ASR W8, #15, W9
001E6A  BE0008     MOV.D W8, W0
001E6C  07FF7F     RCALL WIZCHIP_READ
294:                     val1 = (val1 << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_FSR(sn),1));
001E62  22100A     MOV #0x2100, W10
001E64  42050A     ADD W4, W10, W10
001E66  DED5CF     ASR W10, #15, W11
001E6E  DD06C8     SL W0, #8, W13
001E70  BE000A     MOV.D W10, W0
001E72  07FF7C     RCALL WIZCHIP_READ
001E74  FB8600     ZE W0, W12
001E76  46860C     ADD W13, W12, W12
295:                     if (val1 != 0)
001E78  320007     BRA Z, 0x1E88
296:                     {
297:                       val = WIZCHIP_READ(Sn_TX_FSR(sn));
001E7A  BE0008     MOV.D W8, W0
001E7C  07FF77     RCALL WIZCHIP_READ
298:                       val = (val << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_FSR(sn),1));
001E7E  DD06C8     SL W0, #8, W13
001E80  BE000A     MOV.D W10, W0
001E82  07FF74     RCALL WIZCHIP_READ
001E84  FB8700     ZE W0, W14
001E86  46870E     ADD W13, W14, W14
299:                     }
300:                  }while (val != val1);
001E88  570F8C     SUB W14, W12, [W15]
001E8A  3AFFEF     BRA NZ, 0x1E6A
301:                  return val;
302:               }
001E8C  78000E     MOV W14, W0
001E8E  78074F     MOV [--W15], W14
001E90  BE064F     MOV.D [--W15], W12
001E92  BE054F     MOV.D [--W15], W10
001E94  BE044F     MOV.D [--W15], W8
001E96  060000     RETURN
303:               
304:               
305:               uint16_t getSn_RX_RSR(uint8_t sn)
306:               {
001E98  BE9F88     MOV.D W8, [W15++]
001E9A  BE9F8A     MOV.D W10, [W15++]
001E9C  BE9F8C     MOV.D W12, [W15++]
001E9E  781F8E     MOV W14, [W15++]
307:                  uint16_t val=0,val1=0;
001EB2  EB0700     CLR W14
308:                  do
309:                  {
310:                     val1 = WIZCHIP_READ(Sn_RX_RSR(sn));
001EA0  FB8200     ZE W0, W4
001EA2  DD2245     SL W4, #5, W4
001EA4  420268     ADD W4, #0x8, W4
001EA6  226008     MOV #0x2600, W8
001EA8  420408     ADD W4, W8, W8
001EAA  DEC4CF     ASR W8, #15, W9
001EB4  BE0008     MOV.D W8, W0
001EB6  07FF5A     RCALL WIZCHIP_READ
311:                     val1 = (val1 << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RSR(sn),1));
001EAC  22700A     MOV #0x2700, W10
001EAE  42050A     ADD W4, W10, W10
001EB0  DED5CF     ASR W10, #15, W11
001EB8  DD06C8     SL W0, #8, W13
001EBA  BE000A     MOV.D W10, W0
001EBC  07FF57     RCALL WIZCHIP_READ
001EBE  FB8600     ZE W0, W12
001EC0  46860C     ADD W13, W12, W12
312:                     if (val1 != 0)
001EC2  320007     BRA Z, 0x1ED2
313:                     {
314:                       val = WIZCHIP_READ(Sn_RX_RSR(sn));
001EC4  BE0008     MOV.D W8, W0
001EC6  07FF52     RCALL WIZCHIP_READ
315:                       val = (val << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RSR(sn),1));
001EC8  DD06C8     SL W0, #8, W13
001ECA  BE000A     MOV.D W10, W0
001ECC  07FF4F     RCALL WIZCHIP_READ
001ECE  FB8700     ZE W0, W14
001ED0  46870E     ADD W13, W14, W14
316:                     }
317:                  }while (val != val1);
001ED2  570F8C     SUB W14, W12, [W15]
001ED4  3AFFEF     BRA NZ, 0x1EB4
318:                  return val;
319:               }
001ED6  78000E     MOV W14, W0
001ED8  78074F     MOV [--W15], W14
001EDA  BE064F     MOV.D [--W15], W12
001EDC  BE054F     MOV.D [--W15], W10
001EDE  BE044F     MOV.D [--W15], W8
001EE0  060000     RETURN
320:               
321:               void wiz_send_data(uint8_t sn, uint8_t *wizdata, uint16_t len)
322:               {
001EE2  4787E4     ADD W15, #0x4, W15
001EE4  BE9F88     MOV.D W8, [W15++]
001EE6  BE9F8A     MOV.D W10, [W15++]
001EE8  BE9F8C     MOV.D W12, [W15++]
001EEA  781F8E     MOV W14, [W15++]
001EEC  780681     MOV W1, W13
001EEE  780602     MOV W2, W12
323:                  uint16_t ptr = 0;
324:                  uint32_t addrsel = 0;
325:                  if(len == 0)  return;
001EF0  560FE0     SUB W12, #0x0, [W15]
001EF2  320025     BRA Z, 0x1F3E
326:                  ptr = getSn_TX_WR(sn);
001EF4  FB8000     ZE W0, W0
001EF6  DD0042     SL W0, #2, W0
001EF8  9FBF80     MOV W0, [W15-16]
001EFA  780200     MOV W0, W4
001EFC  E80504     INC W4, W10
001EFE  DD5543     SL W10, #3, W10
001F00  224008     MOV #0x2400, W8
001F02  450408     ADD W10, W8, W8
001F04  DEC4CF     ASR W8, #15, W9
001F06  BE0008     MOV.D W8, W0
001F08  07FF31     RCALL WIZCHIP_READ
001F0A  784700     MOV.B W0, W14
001F0C  225004     MOV #0x2500, W4
001F0E  450504     ADD W10, W4, W10
001F10  DED5CF     ASR W10, #15, W11
001F12  BE000A     MOV.D W10, W0
001F14  07FF2B     RCALL WIZCHIP_READ
001F16  78028E     MOV W14, W5
001F18  DD2F48     SL W5, #8, W14
001F1A  FB8000     ZE W0, W0
001F1C  470700     ADD W14, W0, W14
327:                  
328:                  addrsel = (ptr << 8) + (WIZCHIP_TXBUF_BLOCK(sn) << 3);
001F1E  DD7248     SL W14, #8, W4
001F20  97BA8F     MOV [W15-16], W5
001F22  E88005     INC2 W5, W0
001F24  DD0043     SL W0, #3, W0
001F26  420000     ADD W4, W0, W0
001F28  200001     MOV #0x0, W1
329:                  WIZCHIP_WRITE_BUF(addrsel,wizdata, len);
001F2A  78018C     MOV W12, W3
001F2C  78010D     MOV W13, W2
001F2E  07FF6E     RCALL WIZCHIP_WRITE_BUF
330:                  
331:                  ptr += len;
001F30  47060C     ADD W14, W12, W12
332:                  setSn_TX_WR(sn,ptr);
001F32  DE6148     LSR W12, #8, W2
001F34  BE0008     MOV.D W8, W0
001F36  07FF30     RCALL WIZCHIP_WRITE
001F38  78410C     MOV.B W12, W2
001F3A  BE000A     MOV.D W10, W0
001F3C  07FF2D     RCALL WIZCHIP_WRITE
333:               }
001F3E  78074F     MOV [--W15], W14
001F40  BE064F     MOV.D [--W15], W12
001F42  BE054F     MOV.D [--W15], W10
001F44  BE044F     MOV.D [--W15], W8
001F46  B1004F     SUB #0x4, W15
001F48  060000     RETURN
334:               
335:               void wiz_recv_data(uint8_t sn, uint8_t *wizdata, uint16_t len)
336:               {
001F4A  4787E4     ADD W15, #0x4, W15
001F4C  BE9F88     MOV.D W8, [W15++]
001F4E  BE9F8A     MOV.D W10, [W15++]
001F50  BE9F8C     MOV.D W12, [W15++]
001F52  781F8E     MOV W14, [W15++]
001F54  780681     MOV W1, W13
001F56  780602     MOV W2, W12
337:                  uint16_t ptr = 0;
338:                  uint32_t addrsel = 0;
339:                  
340:                  if(len == 0) return;
001F58  560FE0     SUB W12, #0x0, [W15]
001F5A  320025     BRA Z, 0x1FA6
341:                  ptr = getSn_RX_RD(sn);
001F5C  FB8000     ZE W0, W0
001F5E  DD0042     SL W0, #2, W0
001F60  9FBF80     MOV W0, [W15-16]
001F62  780200     MOV W0, W4
001F64  E80504     INC W4, W10
001F66  DD5543     SL W10, #3, W10
001F68  228008     MOV #0x2800, W8
001F6A  450408     ADD W10, W8, W8
001F6C  DEC4CF     ASR W8, #15, W9
001F6E  BE0008     MOV.D W8, W0
001F70  07FEFD     RCALL WIZCHIP_READ
001F72  784700     MOV.B W0, W14
001F74  229004     MOV #0x2900, W4
001F76  450504     ADD W10, W4, W10
001F78  DED5CF     ASR W10, #15, W11
001F7A  BE000A     MOV.D W10, W0
001F7C  07FEF7     RCALL WIZCHIP_READ
001F7E  78028E     MOV W14, W5
001F80  DD2F48     SL W5, #8, W14
001F82  FB8000     ZE W0, W0
001F84  470700     ADD W14, W0, W14
342:                  addrsel = (ptr << 8) + (WIZCHIP_RXBUF_BLOCK(sn) << 3);
001F86  DD7248     SL W14, #8, W4
001F88  97BA8F     MOV [W15-16], W5
001F8A  428063     ADD W5, #0x3, W0
001F8C  DD0043     SL W0, #3, W0
001F8E  420000     ADD W4, W0, W0
001F90  200001     MOV #0x0, W1
343:                  
344:                  WIZCHIP_READ_BUF(addrsel, wizdata, len);
001F92  78018C     MOV W12, W3
001F94  78010D     MOV W13, W2
001F96  07FF19     RCALL WIZCHIP_READ_BUF
345:                  ptr += len;
001F98  47060C     ADD W14, W12, W12
346:                  
347:                  setSn_RX_RD(sn,ptr);
001F9A  DE6148     LSR W12, #8, W2
001F9C  BE0008     MOV.D W8, W0
001F9E  07FEFC     RCALL WIZCHIP_WRITE
001FA0  78410C     MOV.B W12, W2
001FA2  BE000A     MOV.D W10, W0
001FA4  07FEF9     RCALL WIZCHIP_WRITE
348:               }
001FA6  78074F     MOV [--W15], W14
001FA8  BE064F     MOV.D [--W15], W12
001FAA  BE054F     MOV.D [--W15], W10
001FAC  BE044F     MOV.D [--W15], W8
001FAE  B1004F     SUB #0x4, W15
001FB0  060000     RETURN
349:               
350:               
351:               void wiz_recv_ignore(uint8_t sn, uint16_t len)
352:               {
001FB2  BE9F88     MOV.D W8, [W15++]
001FB4  BE9F8A     MOV.D W10, [W15++]
001FB6  BE9F8C     MOV.D W12, [W15++]
001FB8  780681     MOV W1, W13
353:                  uint16_t ptr = 0;
354:                  ptr = getSn_RX_RD(sn);
001FBA  FB8500     ZE W0, W10
001FBC  DD5545     SL W10, #5, W10
001FBE  450568     ADD W10, #0x8, W10
001FC0  228008     MOV #0x2800, W8
001FC2  450408     ADD W10, W8, W8
001FC4  DEC4CF     ASR W8, #15, W9
001FC6  BE0008     MOV.D W8, W0
001FC8  07FED1     RCALL WIZCHIP_READ
001FCA  784600     MOV.B W0, W12
001FCC  229004     MOV #0x2900, W4
001FCE  450504     ADD W10, W4, W10
001FD0  DED5CF     ASR W10, #15, W11
001FD2  BE000A     MOV.D W10, W0
001FD4  07FECB     RCALL WIZCHIP_READ
001FD6  DD6648     SL W12, #8, W12
001FD8  FB8000     ZE W0, W0
001FDA  460600     ADD W12, W0, W12
355:                  ptr += len;
001FDC  46060D     ADD W12, W13, W12
356:                  setSn_RX_RD(sn,ptr);
001FDE  DE6148     LSR W12, #8, W2
001FE0  BE0008     MOV.D W8, W0
001FE2  07FEDA     RCALL WIZCHIP_WRITE
001FE4  78410C     MOV.B W12, W2
001FE6  BE000A     MOV.D W10, W0
001FE8  07FED7     RCALL WIZCHIP_WRITE
357:               }
001FEA  BE064F     MOV.D [--W15], W12
001FEC  BE054F     MOV.D [--W15], W10
001FEE  BE044F     MOV.D [--W15], W8
001FF0  060000     RETURN
358:               
